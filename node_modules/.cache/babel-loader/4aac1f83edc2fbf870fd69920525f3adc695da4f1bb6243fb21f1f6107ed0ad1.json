{"ast":null,"code":"var _jsxFileName = \"C:\\\\Users\\\\ASUS\\\\Documents\\\\htm_fe\\\\src\\\\pages\\\\User\\\\Round2.tsx\",\n  _s = $RefreshSig$();\nimport Play from \"../../layouts/Play\";\nimport React, { useState, useEffect } from \"react\";\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\n// T·ª´ kh√≥a ch∆∞·ªõng ng·∫°i v·∫≠t\nconst mainKeyword = \"VIETTEL\";\n\n// T·∫°o t·ª´ kh√≥a g·ª£i √Ω v·ªõi v·ªã tr√≠ v√† h∆∞·ªõng random\nconst generateHintWords = (words, gridSize, obstacleWord) => {\n  const grid = Array(gridSize).fill(null).map(() => Array(gridSize).fill(\"\")); // M·∫£ng ki·ªÉm tra v·ªã tr√≠\n\n  const findCommonLetterPairs = words => {\n    let results = [];\n    let usedWords = new Set(); // L∆∞u l·∫°i c√°c t·ª´ ƒë√£ d√πng\n\n    let remainingPairs = [];\n    for (let i = 0; i < words.length; i++) {\n      for (let j = i + 1; j < words.length; j++) {\n        const word1 = words[i];\n        const word2 = words[j];\n\n        // T√¨m k√Ω t·ª± chung gi·ªØa 2 t·ª´\n        const commonLetters = [...new Set(word1)].filter(letter => word2.includes(letter));\n        if (commonLetters.length >= 2) {\n          // T√≠nh ƒëi·ªÉm ∆∞u ti√™n (ch·ªØ g·∫ßn trung t√¢m h∆°n)\n          const scoredLetters = commonLetters.map(letter => {\n            const index1 = word1.indexOf(letter);\n            const index2 = word2.indexOf(letter);\n            const center1 = word1.length / 2;\n            const center2 = word2.length / 2;\n            const score = Math.abs(index1 - center1) + Math.abs(index2 - center2);\n            return {\n              letter,\n              score\n            };\n          });\n\n          // S·∫Øp x·∫øp theo ƒëi·ªÉm ∆∞u ti√™n\n          scoredLetters.sort((a, b) => a.score - b.score);\n          const prioritizedLetters = scoredLetters.map(item => item.letter);\n          remainingPairs.push({\n            word1,\n            word2,\n            commonLetters: prioritizedLetters\n          });\n        }\n      }\n    }\n\n    // B∆∞·ªõc 2: Ch·ªçn t·ªëi ƒëa 2 c·∫∑p theo quy t·∫Øc\n    for (const pair of remainingPairs) {\n      if (results.length >= 2) break; // ƒê·ªß 2 c·∫∑p th√¨ d·ª´ng\n      if (!usedWords.has(pair.word1) && !usedWords.has(pair.word2)) {\n        results.push(pair);\n        usedWords.add(pair.word1);\n        usedWords.add(pair.word2);\n      }\n    }\n\n    // N·∫øu v·∫´n ch∆∞a ƒë·ªß 2 c·∫∑p, ch·ªçn ti·∫øp t·ª´ c√°c c·∫∑p c√≥ t·ª´ ƒë√£ d√πng\n    for (const pair of remainingPairs) {\n      if (results.length >= 2) break;\n      if (!usedWords.has(pair.word1) || !usedWords.has(pair.word2)) {\n        results.push(pair);\n        usedWords.add(pair.word1);\n        usedWords.add(pair.word2);\n      }\n    }\n    return results;\n  };\n\n  // üõ† Test\n  const testwords = [\"b∆∞uch√≠nh\", \"5G\", \"bqp\", \"t·∫≠pƒëo√†n\", \"h√†n·ªôi\", \"red\"];\n  const shuffledWords = testwords.sort(() => Math.random() - 0.5);\n  const placeWordsOnGrid = (words, gridSize) => {\n    let placedWords = [];\n    let occupiedPositions = new Set();\n    let placedSet = new Set(); // Set ƒë·ªÉ theo d√µi t·ª´ ƒë√£ ƒë·∫∑t\n\n    const getKey = (x, y) => `${x},${y}`;\n    const canPlaceWord = (word, x, y, direction, index) => {\n      for (let i = 0; i < word.length; i++) {\n        if (i === x + index) continue;\n        let newX = direction === \"horizontal\" ? x + i : x;\n        let newY = direction === \"horizontal\" ? y : y + i;\n        if (newX < 0 || newY < 0 || newX >= gridSize || newY >= gridSize || occupiedPositions.has(getKey(newX, newY))) {\n          return false;\n        }\n      }\n      return true;\n    };\n    const commonLetterPairs = findCommonLetterPairs(words);\n    console.log(commonLetterPairs);\n    for (const {\n      word1,\n      word2,\n      commonLetters\n    } of commonLetterPairs) {\n      if (placedSet.has(word1) || placedSet.has(word2)) continue; // Ki·ªÉm tra n·∫øu ƒë√£ ƒë·∫∑t th√¨ b·ªè qua\n\n      const commonLetter = commonLetters[0];\n      const index1 = word1.indexOf(commonLetter);\n      const index2 = word2.indexOf(commonLetter);\n      let placed = false;\n      for (let attempt = 0; attempt < 100; attempt++) {\n        let x = Math.floor(Math.random() * (gridSize - word1.length));\n        let y = Math.floor(Math.random() * (gridSize - index2) + index2);\n        if (canPlaceWord(word1, x, y, \"horizontal\", index1)) {\n          placedWords.push({\n            word: word1,\n            x,\n            y,\n            direction: \"horizontal\"\n          });\n          placedSet.add(word1); // ƒê√°nh d·∫•u t·ª´ ƒë√£ ƒë·∫∑t\n\n          let intersecrX = x + index1;\n          let intersectY = y;\n          if (canPlaceWord(word2, intersecrX, intersectY - index2, \"vertical\", index2)) {\n            for (let i = 0; i < word1.length; i++) occupiedPositions.add(getKey(x + i, y));\n            placedWords.push({\n              word: word2,\n              x: intersecrX,\n              y: intersectY - index2,\n              direction: \"vertical\"\n            });\n            placedSet.add(word2);\n            for (let i = 0; i < word2.length; i++) occupiedPositions.add(getKey(intersecrX, intersectY - index2 + i));\n            placed = true;\n            break;\n          } else {\n            placedWords.pop();\n          }\n        }\n      }\n      if (!placed) console.warn(`Kh√¥ng th·ªÉ ƒë·∫∑t c·∫∑p t·ª´: ${word1} - ${word2}`);\n    }\n    for (const word of words) {\n      if (placedSet.has(word)) continue; // N·∫øu ƒë√£ ƒë·∫∑t th√¨ b·ªè qua\n\n      let placed = false;\n      for (let attempt = 0; attempt < 100; attempt++) {\n        let direction = Math.random() < 0.5 ? \"horizontal\" : \"vertical\";\n        let x = Math.floor(Math.random() * (direction === \"horizontal\" ? gridSize - word.length : gridSize));\n        let y = Math.floor(Math.random() * (direction === \"vertical\" ? gridSize - word.length : gridSize));\n        if (canPlaceWord(word, x, y, direction, 0)) {\n          placedWords.push({\n            word,\n            x,\n            y,\n            direction\n          });\n          placedSet.add(word);\n\n          // ƒê√°nh d·∫•u c√°c √¥ ƒë√£ s·ª≠ d·ª•ng\n          for (let i = 0; i < word.length; i++) {\n            let newX = direction === \"horizontal\" ? x + i : x;\n            let newY = direction === \"horizontal\" ? y : y + i;\n            occupiedPositions.add(getKey(newX, newY));\n          }\n          placed = true;\n          break;\n        }\n      }\n      if (!placed) console.warn(`Kh√¥ng th·ªÉ ƒë·∫∑t t·ª´: ${word}`);\n    }\n    return placedWords;\n  };\n  const placedWords = placeWordsOnGrid(testwords, gridSize);\n  console.log(placedWords);\n  return placedWords;\n};\n\n// K√≠ch th∆∞·ªõc l∆∞·ªõi\nconst GRID_SIZE = 10;\n\n// T·∫°o l∆∞·ªõi tr·ªëng\nconst generateEmptyGrid = () => {\n  return Array(GRID_SIZE).fill(null).map(() => Array(GRID_SIZE).fill(\"\"));\n};\nconst ObstacleQuestionBox = ({\n  obstacleWord\n}) => {\n  _s();\n  const [grid, setGrid] = useState(generateEmptyGrid());\n  const [revealedRows, setRevealedRows] = useState(Array(GRID_SIZE).fill(false));\n  const [revealedCols, setRevealedCols] = useState(Array(GRID_SIZE).fill(false));\n  const [hintWords, setHintWords] = useState([]);\n  useEffect(() => {\n    const wordList = [\"b∆∞uch√≠nh\", \"5G\", \"bqp\", \"t·∫≠pƒëo√†n\", \"h√†n·ªôi\", \"red\"]; // Using testwords from your code\n    const randomHintWords = generateHintWords(wordList, GRID_SIZE, mainKeyword);\n    setHintWords(randomHintWords);\n    let newGrid = generateEmptyGrid();\n\n    // Th√™m t·ª´ v√†o l∆∞·ªõi\n    randomHintWords.forEach(({\n      word,\n      x,\n      y,\n      direction\n    }) => {\n      for (let i = 0; i < word.length; i++) {\n        if (direction === \"horizontal\") {\n          newGrid[y][x + i] = word[i];\n        } else {\n          newGrid[y + i][x] = word[i];\n        }\n      }\n    });\n    setGrid(newGrid);\n  }, []);\n\n  // H√†m toggle hi·ªÉn th·ªã h√†ng/c·ªôt\n  const toggleRow = rowIndex => {\n    setRevealedRows(prev => {\n      const newRevealed = [...prev];\n      newRevealed[rowIndex] = !newRevealed[rowIndex];\n      return newRevealed;\n    });\n  };\n  const toggleCol = colIndex => {\n    setRevealedCols(prev => {\n      const newRevealed = [...prev];\n      newRevealed[colIndex] = !newRevealed[colIndex];\n      return newRevealed;\n    });\n  };\n\n  // Assign numbers to words\n  const wordList = [\"b∆∞uch√≠nh\", \"5G\", \"bqp\", \"t·∫≠pƒëo√†n\", \"h√†n·ªôi\", \"red\"];\n  const wordNumberMap = new Map();\n  wordList.forEach((word, index) => wordNumberMap.set(word, index + 1));\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    className: \"flex flex-col items-center bg-white rounded-lg shadow-md p-6\",\n    children: /*#__PURE__*/_jsxDEV(\"div\", {\n      className: \"grid grid-cols-[40px_repeat(10,30px)] gap-1\",\n      children: [/*#__PURE__*/_jsxDEV(\"div\", {\n        className: \"w-10 h-10\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 247,\n        columnNumber: 17\n      }, this), \" \", grid[0].map((_, colIndex) => {\n        const verticalWord = hintWords.find(word => word.direction === \"vertical\" && word.x === colIndex);\n        const number = verticalWord ? wordNumberMap.get(verticalWord.word) : undefined;\n        return /*#__PURE__*/_jsxDEV(\"div\", {\n          className: `w-8 h-8 flex items-center justify-center ${number ? \"font-bold text-blue-500 bg-blue-100 rounded cursor-pointer hover:bg-blue-200\" : \"\"}`,\n          onClick: verticalWord ? () => toggleCol(colIndex) : undefined,\n          children: number || \"\"\n        }, colIndex, false, {\n          fileName: _jsxFileName,\n          lineNumber: 254,\n          columnNumber: 25\n        }, this);\n      }), grid.map((row, rowIndex) => {\n        const horizontalWord = hintWords.find(word => word.direction === \"horizontal\" && word.y === rowIndex);\n        const number = horizontalWord ? wordNumberMap.get(horizontalWord.word) : undefined;\n        return /*#__PURE__*/_jsxDEV(React.Fragment, {\n          children: [/*#__PURE__*/_jsxDEV(\"div\", {\n            className: `w-8 h-8 flex items-center justify-center ${number ? \"font-bold text-blue-500 bg-blue-100 rounded cursor-pointer hover:bg-blue-200\" : \"\"}`,\n            onClick: horizontalWord ? () => toggleRow(rowIndex) : undefined,\n            children: number || \"\"\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 278,\n            columnNumber: 29\n          }, this), row.map((cell, colIndex) => {\n            const isRevealed = revealedRows[rowIndex] && hintWords.some(word => word.y === rowIndex && word.direction === \"horizontal\") || revealedCols[colIndex] && hintWords.some(word => word.x === colIndex && word.direction === \"vertical\");\n            return /*#__PURE__*/_jsxDEV(\"div\", {\n              className: `w-8 h-8 border flex items-center justify-center text-lg font-semibold select-none \n                                        ${isRevealed ? \"text-black\" : \"text-transparent\"}\n                                        ${obstacleWord.includes(cell) && isRevealed ? \"font-bold text-red-500\" : \"\"}\n                                        ${cell === \"\" ? \"border-none\" : \"border-gray-400\"}\n                                    `,\n              children: cell\n            }, colIndex, false, {\n              fileName: _jsxFileName,\n              lineNumber: 298,\n              columnNumber: 37\n            }, this);\n          })]\n        }, rowIndex, true, {\n          fileName: _jsxFileName,\n          lineNumber: 276,\n          columnNumber: 25\n        }, this);\n      })]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 245,\n      columnNumber: 13\n    }, this)\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 244,\n    columnNumber: 9\n  }, this);\n};\n_s(ObstacleQuestionBox, \"0tXfE1RkmpIdWy/liPKPIQWuBnQ=\");\n_c = ObstacleQuestionBox;\nfunction Round2() {\n  return /*#__PURE__*/_jsxDEV(Play, {\n    questionComponent: /*#__PURE__*/_jsxDEV(ObstacleQuestionBox, {\n      obstacleWord: mainKeyword\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 319,\n      columnNumber: 37\n    }, this)\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 319,\n    columnNumber: 12\n  }, this);\n}\n_c2 = Round2;\nexport default Round2;\nvar _c, _c2;\n$RefreshReg$(_c, \"ObstacleQuestionBox\");\n$RefreshReg$(_c2, \"Round2\");","map":{"version":3,"names":["Play","React","useState","useEffect","jsxDEV","_jsxDEV","mainKeyword","generateHintWords","words","gridSize","obstacleWord","grid","Array","fill","map","findCommonLetterPairs","results","usedWords","Set","remainingPairs","i","length","j","word1","word2","commonLetters","filter","letter","includes","scoredLetters","index1","indexOf","index2","center1","center2","score","Math","abs","sort","a","b","prioritizedLetters","item","push","pair","has","add","testwords","shuffledWords","random","placeWordsOnGrid","placedWords","occupiedPositions","placedSet","getKey","x","y","canPlaceWord","word","direction","index","newX","newY","commonLetterPairs","console","log","commonLetter","placed","attempt","floor","intersecrX","intersectY","pop","warn","GRID_SIZE","generateEmptyGrid","ObstacleQuestionBox","_s","setGrid","revealedRows","setRevealedRows","revealedCols","setRevealedCols","hintWords","setHintWords","wordList","randomHintWords","newGrid","forEach","toggleRow","rowIndex","prev","newRevealed","toggleCol","colIndex","wordNumberMap","Map","set","className","children","fileName","_jsxFileName","lineNumber","columnNumber","_","verticalWord","find","number","get","undefined","onClick","row","horizontalWord","Fragment","cell","isRevealed","some","_c","Round2","questionComponent","_c2","$RefreshReg$"],"sources":["C:/Users/ASUS/Documents/htm_fe/src/pages/User/Round2.tsx"],"sourcesContent":["import Play from \"../../layouts/Play\";\r\nimport React, { useState, useEffect } from \"react\";\r\n\r\ninterface HintWord {\r\n    word: string;\r\n    x: number;\r\n    y: number;\r\n    direction: \"horizontal\" | \"vertical\";\r\n}\r\n\r\ninterface ObstacleQuestionBoxProps {\r\n    obstacleWord: string;\r\n}\r\n\r\ntype PlacedWord = {\r\n    word: string;\r\n    x: number;\r\n    y: number;\r\n    direction: \"horizontal\" | \"vertical\";\r\n};\r\n\r\n// T·ª´ kh√≥a ch∆∞·ªõng ng·∫°i v·∫≠t\r\nconst mainKeyword = \"VIETTEL\";\r\n\r\n// T·∫°o t·ª´ kh√≥a g·ª£i √Ω v·ªõi v·ªã tr√≠ v√† h∆∞·ªõng random\r\nconst generateHintWords = (words: string[], gridSize: number, obstacleWord: string): HintWord[] => {\r\n    const grid: string[][] = Array(gridSize)\r\n        .fill(null)\r\n        .map(() => Array(gridSize).fill(\"\")); // M·∫£ng ki·ªÉm tra v·ªã tr√≠\r\n\r\n    const findCommonLetterPairs = (words: string[]): { word1: string; word2: string; commonLetters: string[] }[] => {\r\n        let results: { word1: string; word2: string; commonLetters: string[] }[] = [];\r\n        let usedWords = new Set<string>(); // L∆∞u l·∫°i c√°c t·ª´ ƒë√£ d√πng\r\n\r\n        let remainingPairs: { word1: string; word2: string; commonLetters: string[] }[] = [];\r\n\r\n        for (let i = 0; i < words.length; i++) {\r\n            for (let j = i + 1; j < words.length; j++) {\r\n                const word1 = words[i];\r\n                const word2 = words[j];\r\n\r\n                // T√¨m k√Ω t·ª± chung gi·ªØa 2 t·ª´\r\n                const commonLetters = [...new Set(word1)].filter((letter) => word2.includes(letter));\r\n\r\n                if (commonLetters.length >= 2) {\r\n                    // T√≠nh ƒëi·ªÉm ∆∞u ti√™n (ch·ªØ g·∫ßn trung t√¢m h∆°n)\r\n                    const scoredLetters = commonLetters.map((letter) => {\r\n                        const index1 = word1.indexOf(letter);\r\n                        const index2 = word2.indexOf(letter);\r\n                        const center1 = word1.length / 2;\r\n                        const center2 = word2.length / 2;\r\n                        const score = Math.abs(index1 - center1) + Math.abs(index2 - center2);\r\n                        return { letter, score };\r\n                    });\r\n\r\n                    // S·∫Øp x·∫øp theo ƒëi·ªÉm ∆∞u ti√™n\r\n                    scoredLetters.sort((a, b) => a.score - b.score);\r\n                    const prioritizedLetters = scoredLetters.map((item) => item.letter);\r\n\r\n                    remainingPairs.push({ word1, word2, commonLetters: prioritizedLetters });\r\n                }\r\n            }\r\n        }\r\n\r\n        // B∆∞·ªõc 2: Ch·ªçn t·ªëi ƒëa 2 c·∫∑p theo quy t·∫Øc\r\n        for (const pair of remainingPairs) {\r\n            if (results.length >= 2) break; // ƒê·ªß 2 c·∫∑p th√¨ d·ª´ng\r\n            if (!usedWords.has(pair.word1) && !usedWords.has(pair.word2)) {\r\n                results.push(pair);\r\n                usedWords.add(pair.word1);\r\n                usedWords.add(pair.word2);\r\n            }\r\n        }\r\n\r\n        // N·∫øu v·∫´n ch∆∞a ƒë·ªß 2 c·∫∑p, ch·ªçn ti·∫øp t·ª´ c√°c c·∫∑p c√≥ t·ª´ ƒë√£ d√πng\r\n        for (const pair of remainingPairs) {\r\n            if (results.length >= 2) break;\r\n            if (!usedWords.has(pair.word1) || !usedWords.has(pair.word2)) {\r\n                results.push(pair);\r\n                usedWords.add(pair.word1);\r\n                usedWords.add(pair.word2);\r\n            }\r\n        }\r\n\r\n        return results;\r\n    };\r\n\r\n    // üõ† Test\r\n    const testwords = [\"b∆∞uch√≠nh\", \"5G\", \"bqp\", \"t·∫≠pƒëo√†n\", \"h√†n·ªôi\", \"red\"];\r\n\r\n    const shuffledWords = testwords.sort(() => Math.random() - 0.5);\r\n    const placeWordsOnGrid = (words: string[], gridSize: number): PlacedWord[] => {\r\n        let placedWords: PlacedWord[] = [];\r\n        let occupiedPositions = new Set<string>();\r\n        let placedSet = new Set<string>(); // Set ƒë·ªÉ theo d√µi t·ª´ ƒë√£ ƒë·∫∑t\r\n\r\n        const getKey = (x: number, y: number) => `${x},${y}`;\r\n\r\n        const canPlaceWord = (word: string, x: number, y: number, direction: \"horizontal\" | \"vertical\", index: number) => {\r\n            for (let i = 0; i < word.length; i++) {\r\n                if (i === x + index) continue;\r\n                let newX = direction === \"horizontal\" ? x + i : x;\r\n                let newY = direction === \"horizontal\" ? y : y + i;\r\n                if (newX < 0 || newY < 0 || newX >= gridSize || newY >= gridSize || occupiedPositions.has(getKey(newX, newY))) {\r\n                    return false;\r\n                }\r\n            }\r\n            return true;\r\n        };\r\n\r\n        const commonLetterPairs = findCommonLetterPairs(words);\r\n        console.log(commonLetterPairs);\r\n\r\n        for (const { word1, word2, commonLetters } of commonLetterPairs) {\r\n            if (placedSet.has(word1) || placedSet.has(word2)) continue; // Ki·ªÉm tra n·∫øu ƒë√£ ƒë·∫∑t th√¨ b·ªè qua\r\n\r\n            const commonLetter = commonLetters[0];\r\n            const index1 = word1.indexOf(commonLetter);\r\n            const index2 = word2.indexOf(commonLetter);\r\n\r\n            let placed = false;\r\n            for (let attempt = 0; attempt < 100; attempt++) {\r\n                let x = Math.floor(Math.random() * (gridSize - word1.length));\r\n                let y = Math.floor(Math.random() * (gridSize - index2) + index2);\r\n\r\n                if (canPlaceWord(word1, x, y, \"horizontal\", index1)) {\r\n                    placedWords.push({ word: word1, x, y, direction: \"horizontal\" });\r\n                    placedSet.add(word1); // ƒê√°nh d·∫•u t·ª´ ƒë√£ ƒë·∫∑t\r\n\r\n                    let intersecrX = x + index1;\r\n                    let intersectY = y;\r\n\r\n                    if (canPlaceWord(word2, intersecrX, intersectY - index2, \"vertical\", index2)) {\r\n                        for (let i = 0; i < word1.length; i++) occupiedPositions.add(getKey(x + i, y));\r\n                        placedWords.push({ word: word2, x: intersecrX, y: intersectY - index2, direction: \"vertical\" });\r\n                        placedSet.add(word2);\r\n\r\n                        for (let i = 0; i < word2.length; i++) occupiedPositions.add(getKey(intersecrX, intersectY - index2 + i));\r\n\r\n                        placed = true;\r\n                        break;\r\n                    } else {\r\n                        placedWords.pop();\r\n                    }\r\n                }\r\n            }\r\n\r\n            if (!placed) console.warn(`Kh√¥ng th·ªÉ ƒë·∫∑t c·∫∑p t·ª´: ${word1} - ${word2}`);\r\n        }\r\n\r\n        for (const word of words) {\r\n            if (placedSet.has(word)) continue; // N·∫øu ƒë√£ ƒë·∫∑t th√¨ b·ªè qua\r\n\r\n            let placed = false;\r\n            for (let attempt = 0; attempt < 100; attempt++) {\r\n                let direction: \"horizontal\" | \"vertical\" = Math.random() < 0.5 ? \"horizontal\" : \"vertical\";\r\n                let x = Math.floor(Math.random() * (direction === \"horizontal\" ? gridSize - word.length : gridSize));\r\n                let y = Math.floor(Math.random() * (direction === \"vertical\" ? gridSize - word.length : gridSize));\r\n\r\n                if (canPlaceWord(word, x, y, direction, 0)) {\r\n                    placedWords.push({ word, x, y, direction });\r\n                    placedSet.add(word);\r\n\r\n                    // ƒê√°nh d·∫•u c√°c √¥ ƒë√£ s·ª≠ d·ª•ng\r\n                    for (let i = 0; i < word.length; i++) {\r\n                        let newX = direction === \"horizontal\" ? x + i : x;\r\n                        let newY = direction === \"horizontal\" ? y : y + i;\r\n                        occupiedPositions.add(getKey(newX, newY));\r\n                    }\r\n\r\n                    placed = true;\r\n                    break;\r\n                }\r\n            }\r\n\r\n            if (!placed) console.warn(`Kh√¥ng th·ªÉ ƒë·∫∑t t·ª´: ${word}`);\r\n        }\r\n\r\n        return placedWords;\r\n    };\r\n    const placedWords = placeWordsOnGrid(testwords, gridSize);\r\n    console.log(placedWords);\r\n\r\n    return placedWords;\r\n};\r\n\r\n// K√≠ch th∆∞·ªõc l∆∞·ªõi\r\nconst GRID_SIZE = 10;\r\n\r\n// T·∫°o l∆∞·ªõi tr·ªëng\r\nconst generateEmptyGrid = () => {\r\n    return Array(GRID_SIZE).fill(null).map(() => Array(GRID_SIZE).fill(\"\"));\r\n};\r\n\r\nconst ObstacleQuestionBox: React.FC<ObstacleQuestionBoxProps> = ({ obstacleWord }) => {\r\n    const [grid, setGrid] = useState<string[][]>(generateEmptyGrid());\r\n    const [revealedRows, setRevealedRows] = useState<boolean[]>(Array(GRID_SIZE).fill(false));\r\n    const [revealedCols, setRevealedCols] = useState<boolean[]>(Array(GRID_SIZE).fill(false));\r\n    const [hintWords, setHintWords] = useState<HintWord[]>([]);\r\n\r\n    useEffect(() => {\r\n        const wordList = [\"b∆∞uch√≠nh\", \"5G\", \"bqp\", \"t·∫≠pƒëo√†n\", \"h√†n·ªôi\", \"red\"]; // Using testwords from your code\r\n        const randomHintWords = generateHintWords(wordList, GRID_SIZE, mainKeyword);\r\n        setHintWords(randomHintWords);\r\n        let newGrid = generateEmptyGrid();\r\n\r\n        // Th√™m t·ª´ v√†o l∆∞·ªõi\r\n        randomHintWords.forEach(({ word, x, y, direction }) => {\r\n            for (let i = 0; i < word.length; i++) {\r\n                if (direction === \"horizontal\") {\r\n                    newGrid[y][x + i] = word[i];\r\n                } else {\r\n                    newGrid[y + i][x] = word[i];\r\n                }\r\n            }\r\n        });\r\n\r\n        setGrid(newGrid);\r\n    }, []);\r\n\r\n    // H√†m toggle hi·ªÉn th·ªã h√†ng/c·ªôt\r\n    const toggleRow = (rowIndex: number) => {\r\n        setRevealedRows((prev) => {\r\n            const newRevealed = [...prev];\r\n            newRevealed[rowIndex] = !newRevealed[rowIndex];\r\n            return newRevealed;\r\n        });\r\n    };\r\n\r\n    const toggleCol = (colIndex: number) => {\r\n        setRevealedCols((prev) => {\r\n            const newRevealed = [...prev];\r\n            newRevealed[colIndex] = !newRevealed[colIndex];\r\n            return newRevealed;\r\n        });\r\n    };\r\n\r\n    // Assign numbers to words\r\n    const wordList = [\"b∆∞uch√≠nh\", \"5G\", \"bqp\", \"t·∫≠pƒëo√†n\", \"h√†n·ªôi\", \"red\"];\r\n    const wordNumberMap = new Map<string, number>();\r\n    wordList.forEach((word, index) => wordNumberMap.set(word, index + 1));\r\n\r\n    return (\r\n        <div className=\"flex flex-col items-center bg-white rounded-lg shadow-md p-6\">\r\n            <div className=\"grid grid-cols-[40px_repeat(10,30px)] gap-1\">\r\n                {/* Header row */}\r\n                <div className=\"w-10 h-10\" /> {/* Empty corner */}\r\n                {grid[0].map((_, colIndex) => {\r\n                    const verticalWord = hintWords.find(\r\n                        (word) => word.direction === \"vertical\" && word.x === colIndex\r\n                    );\r\n                    const number = verticalWord ? wordNumberMap.get(verticalWord.word) : undefined;\r\n                    return (\r\n                        <div\r\n                            key={colIndex}\r\n                            className={`w-8 h-8 flex items-center justify-center ${\r\n                                number\r\n                                    ? \"font-bold text-blue-500 bg-blue-100 rounded cursor-pointer hover:bg-blue-200\"\r\n                                    : \"\"\r\n                            }`}\r\n                            onClick={verticalWord ? () => toggleCol(colIndex) : undefined}\r\n                        >\r\n                            {number || \"\"}\r\n                        </div>\r\n                    );\r\n                })}\r\n\r\n                {/* Grid with row numbers */}\r\n                {grid.map((row, rowIndex) => {\r\n                    const horizontalWord = hintWords.find(\r\n                        (word) => word.direction === \"horizontal\" && word.y === rowIndex\r\n                    );\r\n                    const number = horizontalWord ? wordNumberMap.get(horizontalWord.word) : undefined;\r\n\r\n                    return (\r\n                        <React.Fragment key={rowIndex}>\r\n                            {/* Number cell before the row */}\r\n                            <div\r\n                                className={`w-8 h-8 flex items-center justify-center ${\r\n                                    number\r\n                                        ? \"font-bold text-blue-500 bg-blue-100 rounded cursor-pointer hover:bg-blue-200\"\r\n                                        : \"\"\r\n                                }`}\r\n                                onClick={horizontalWord ? () => toggleRow(rowIndex) : undefined}\r\n                            >\r\n                                {number || \"\"}\r\n                            </div>\r\n\r\n                            {/* Grid cells */}\r\n                            {row.map((cell, colIndex) => {\r\n                                const isRevealed =\r\n                                    (revealedRows[rowIndex] &&\r\n                                        hintWords.some((word) => word.y === rowIndex && word.direction === \"horizontal\")) ||\r\n                                    (revealedCols[colIndex] &&\r\n                                        hintWords.some((word) => word.x === colIndex && word.direction === \"vertical\"));\r\n\r\n                                return (\r\n                                    <div\r\n                                        key={colIndex}\r\n                                        className={`w-8 h-8 border flex items-center justify-center text-lg font-semibold select-none \r\n                                        ${isRevealed ? \"text-black\" : \"text-transparent\"}\r\n                                        ${obstacleWord.includes(cell) && isRevealed ? \"font-bold text-red-500\" : \"\"}\r\n                                        ${cell === \"\" ? \"border-none\" : \"border-gray-400\"}\r\n                                    `}\r\n                                    >\r\n                                        {cell}\r\n                                    </div>\r\n                                );\r\n                            })}\r\n                        </React.Fragment>\r\n                    );\r\n                })}\r\n            </div>\r\n        </div>\r\n    );\r\n};\r\n\r\nfunction Round2() {\r\n    return <Play questionComponent={<ObstacleQuestionBox obstacleWord={mainKeyword} />} />;\r\n}\r\n\r\nexport default Round2;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}