{"ast":null,"code":"import React from \"react\";\n\n// Define word object structure\nimport { Fragment as _Fragment, jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst CrosswordGrid = ({\n  placedWords,\n  boardSize = 20\n}) => {\n  // 0: horizontal, 1: vertical\n\n  const GRID_SIZE = 18;\n  const EMPTY_CELL = ' ';\n  function createEmptyGrid(size) {\n    return Array.from({\n      length: size\n    }, () => Array(size).fill(EMPTY_CELL));\n  }\n  function getLetterPositions(word) {\n    const map = new Map();\n    for (let i = 0; i < word.length; i++) {\n      const char = word[i];\n      if (!map.has(char)) {\n        map.set(char, []);\n      }\n      map.get(char).push(i);\n    }\n    return map;\n  }\n  function isValidPlacement(grid, word, x, y, dir) {\n    const len = word.length;\n    for (let i = 0; i < len; i++) {\n      const xi = dir === 0 ? x + i : x;\n      const yi = dir === 1 ? y + i : y;\n      if (xi < 0 || yi < 0 || xi >= GRID_SIZE || yi >= GRID_SIZE) {\n        return false;\n      }\n      const cell = grid[yi][xi];\n      if (cell !== EMPTY_CELL && cell !== word[i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n  function countMatches(grid, word, x, y, dir) {\n    const matches = [];\n    for (let i = 0; i < word.length; i++) {\n      const xi = dir === 0 ? x + i : x;\n      const yi = dir === 1 ? y + i : y;\n      if (xi >= 0 && yi >= 0 && xi < GRID_SIZE && yi < GRID_SIZE) {\n        if (grid[yi][xi] === word[i]) {\n          matches.push({\n            wordIndex: i,\n            indexInWord: i\n          });\n        }\n      }\n    }\n    return matches;\n  }\n  function placeWordOnGrid(grid, word, x, y, dir) {\n    for (let i = 0; i < word.length; i++) {\n      const xi = dir === 0 ? x + i : x;\n      const yi = dir === 1 ? y + i : y;\n      grid[yi][xi] = word[i];\n    }\n  }\n  function findBestPlacement(grid, word, placedWords, wordIndex) {\n    let best = null;\n    for (let dir of [0, 1]) {\n      for (let y = 0; y < GRID_SIZE; y++) {\n        for (let x = 0; x < GRID_SIZE; x++) {\n          if (!isValidPlacement(grid, word, x, y, dir)) continue;\n          const successfulMatches = countMatches(grid, word, x, y, dir);\n          const placement = {\n            word,\n            x,\n            y,\n            dir,\n            successfulMatches,\n            totalMatches: word.length,\n            effectiveMatches: successfulMatches.length,\n            char: [' ', `${wordIndex + 1}`, ...word.split(''), ' '],\n            string: ` ${wordIndex + 1}${word} `\n          };\n          if (!best || placement.effectiveMatches > best.effectiveMatches || placement.effectiveMatches === best.effectiveMatches && successfulMatches.length > best.successfulMatches.length) {\n            best = placement;\n          }\n        }\n      }\n    }\n    return best;\n  }\n  function generateCrossword(words) {\n    const grid = createEmptyGrid(GRID_SIZE);\n    const placements = [];\n    for (let i = 0; i < words.length; i++) {\n      const word = words[i].replace(/\\s+/g, '').toUpperCase();\n      const bestPlacement = findBestPlacement(grid, word, placements, i);\n      if (bestPlacement) {\n        placeWordOnGrid(grid, word, bestPlacement.x, bestPlacement.y, bestPlacement.dir);\n        placements.push(bestPlacement);\n      } else {\n        console.warn(`Couldn't place word: ${word}`);\n      }\n    }\n    return {\n      grid,\n      placements\n    };\n  }\n  function printGrid(grid) {\n    for (const row of grid) {\n      console.log(row.join(''));\n    }\n  }\n\n  // Sample usage:\n  const words = ['GIÓ', 'HẠT GIỐNG', 'DREAM', 'THUỐC', 'CÚC', 'CHÂU KIỆT LUÂN'];\n  const {\n    grid,\n    placements\n  } = generateCrossword(words);\n  console.log(\"Grid:\", grid);\n  // printGrid(grid);\n\n  console.log(\"\\nPlacements:\");\n  console.log(placements);\n  return /*#__PURE__*/_jsxDEV(_Fragment, {}, void 0, false);\n};\n_c = CrosswordGrid;\nexport default CrosswordGrid;\n\n// Main React Component\nconst WordBoard = () => {\n  // TypeScript version of the crossword builder with shuffled letter matches\n\n  return /*#__PURE__*/_jsxDEV(_Fragment, {}, void 0, false);\n};\n_c2 = WordBoard;\nvar _c, _c2;\n$RefreshReg$(_c, \"CrosswordGrid\");\n$RefreshReg$(_c2, \"WordBoard\");","map":{"version":3,"names":["React","Fragment","_Fragment","jsxDEV","_jsxDEV","CrosswordGrid","placedWords","boardSize","GRID_SIZE","EMPTY_CELL","createEmptyGrid","size","Array","from","length","fill","getLetterPositions","word","map","Map","i","char","has","set","get","push","isValidPlacement","grid","x","y","dir","len","xi","yi","cell","countMatches","matches","wordIndex","indexInWord","placeWordOnGrid","findBestPlacement","best","successfulMatches","placement","totalMatches","effectiveMatches","split","string","generateCrossword","words","placements","replace","toUpperCase","bestPlacement","console","warn","printGrid","row","log","join","_c","WordBoard","_c2","$RefreshReg$"],"sources":["C:/Users/ASUS/Documents/htm_fe/src/pages/Host/Management/HostRound2.tsx"],"sourcesContent":["import React, { useState, useEffect } from \"react\";\r\n\r\n// Define word object structure\r\n\r\ntype WordPlacement = {\r\n  word: string;\r\n  x: number;\r\n  y: number;\r\n  direction: \"horizontal\" | \"vertical\";\r\n};\r\n\r\ninterface CrosswordGridProps {\r\n  placedWords?: WordPlacement[];\r\n  boardSize?: number;\r\n}\r\n\r\nconst CrosswordGrid: React.FC<CrosswordGridProps> = ({ placedWords, boardSize = 20 }) => {\r\n\r\n  type Direction = 0 | 1; // 0: horizontal, 1: vertical\r\n\r\ninterface Match {\r\n  wordIndex: number;\r\n  indexInWord: number;\r\n}\r\n\r\ninterface WordPlacement {\r\n  word: string;\r\n  x: number;\r\n  y: number;\r\n  dir: Direction;\r\n  successfulMatches: Match[];\r\n  totalMatches: number;\r\n  effectiveMatches: number;\r\n  char: string[];\r\n  string: string;\r\n}\r\n\r\nconst GRID_SIZE = 18;\r\nconst EMPTY_CELL = ' ';\r\n\r\nfunction createEmptyGrid(size: number): string[][] {\r\n  return Array.from({ length: size }, () => Array(size).fill(EMPTY_CELL));\r\n}\r\n\r\nfunction getLetterPositions(word: string): Map<string, number[]> {\r\n  const map = new Map<string, number[]>();\r\n  for (let i = 0; i < word.length; i++) {\r\n    const char = word[i];\r\n    if (!map.has(char)) {\r\n      map.set(char, []);\r\n    }\r\n    map.get(char)!.push(i);\r\n  }\r\n  return map;\r\n}\r\n\r\nfunction isValidPlacement(\r\n  grid: string[][],\r\n  word: string,\r\n  x: number,\r\n  y: number,\r\n  dir: Direction\r\n): boolean {\r\n  const len = word.length;\r\n  for (let i = 0; i < len; i++) {\r\n    const xi = dir === 0 ? x + i : x;\r\n    const yi = dir === 1 ? y + i : y;\r\n\r\n    if (xi < 0 || yi < 0 || xi >= GRID_SIZE || yi >= GRID_SIZE) {\r\n      return false;\r\n    }\r\n\r\n    const cell = grid[yi][xi];\r\n    if (cell !== EMPTY_CELL && cell !== word[i]) {\r\n      return false;\r\n    }\r\n  }\r\n  return true;\r\n}\r\n\r\nfunction countMatches(\r\n  grid: string[][],\r\n  word: string,\r\n  x: number,\r\n  y: number,\r\n  dir: Direction\r\n): Match[] {\r\n  const matches: Match[] = [];\r\n  for (let i = 0; i < word.length; i++) {\r\n    const xi = dir === 0 ? x + i : x;\r\n    const yi = dir === 1 ? y + i : y;\r\n\r\n    if (xi >= 0 && yi >= 0 && xi < GRID_SIZE && yi < GRID_SIZE) {\r\n      if (grid[yi][xi] === word[i]) {\r\n        matches.push({ wordIndex: i, indexInWord: i });\r\n      }\r\n    }\r\n  }\r\n  return matches;\r\n}\r\n\r\nfunction placeWordOnGrid(\r\n  grid: string[][],\r\n  word: string,\r\n  x: number,\r\n  y: number,\r\n  dir: Direction\r\n): void {\r\n  for (let i = 0; i < word.length; i++) {\r\n    const xi = dir === 0 ? x + i : x;\r\n    const yi = dir === 1 ? y + i : y;\r\n    grid[yi][xi] = word[i];\r\n  }\r\n}\r\n\r\nfunction findBestPlacement(\r\n  grid: string[][],\r\n  word: string,\r\n  placedWords: WordPlacement[],\r\n  wordIndex: number\r\n): WordPlacement | null {\r\n  let best: WordPlacement | null = null;\r\n\r\n  for (let dir of [0, 1] as Direction[]) {\r\n    for (let y = 0; y < GRID_SIZE; y++) {\r\n      for (let x = 0; x < GRID_SIZE; x++) {\r\n        if (!isValidPlacement(grid, word, x, y, dir)) continue;\r\n\r\n        const successfulMatches = countMatches(grid, word, x, y, dir);\r\n        const placement: WordPlacement = {\r\n          word,\r\n          x,\r\n          y,\r\n          dir,\r\n          successfulMatches,\r\n          totalMatches: word.length,\r\n          effectiveMatches: successfulMatches.length,\r\n          char: [' ', `${wordIndex + 1}`, ...word.split(''), ' '],\r\n          string: ` ${wordIndex + 1}${word} `,\r\n        };\r\n\r\n        if (\r\n          !best ||\r\n          placement.effectiveMatches > best.effectiveMatches ||\r\n          (placement.effectiveMatches === best.effectiveMatches &&\r\n            successfulMatches.length > best.successfulMatches.length)\r\n        ) {\r\n          best = placement;\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  return best;\r\n}\r\n\r\nfunction generateCrossword(words: string[]): {\r\n  grid: string[][];\r\n  placements: WordPlacement[];\r\n} {\r\n  const grid = createEmptyGrid(GRID_SIZE);\r\n  const placements: WordPlacement[] = [];\r\n\r\n  for (let i = 0; i < words.length; i++) {\r\n    const word = words[i].replace(/\\s+/g, '').toUpperCase();\r\n    const bestPlacement = findBestPlacement(grid, word, placements, i);\r\n\r\n    if (bestPlacement) {\r\n      placeWordOnGrid(grid, word, bestPlacement.x, bestPlacement.y, bestPlacement.dir);\r\n      placements.push(bestPlacement);\r\n    } else {\r\n      console.warn(`Couldn't place word: ${word}`);\r\n    }\r\n  }\r\n\r\n  return { grid, placements };\r\n}\r\n\r\nfunction printGrid(grid: string[][]): void {\r\n  for (const row of grid) {\r\n    console.log(row.join(''));\r\n  }\r\n}\r\n\r\n// Sample usage:\r\nconst words = ['GIÓ', 'HẠT GIỐNG', 'DREAM', 'THUỐC', 'CÚC', 'CHÂU KIỆT LUÂN'];\r\nconst { grid, placements } = generateCrossword(words);\r\n\r\nconsole.log(\"Grid:\",grid);\r\n// printGrid(grid);\r\n\r\nconsole.log(\"\\nPlacements:\");\r\nconsole.log(placements);\r\n\r\n  return (\r\n    <>\r\n    </>\r\n  );\r\n};\r\n\r\nexport default CrosswordGrid;\r\n\r\n\r\n// Main React Component\r\nconst WordBoard: React.FC = () => {\r\n  // TypeScript version of the crossword builder with shuffled letter matches\r\n\r\n\r\n\r\n  return (\r\n    <>\r\n    </>\r\n  );\r\n};\r\n\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}