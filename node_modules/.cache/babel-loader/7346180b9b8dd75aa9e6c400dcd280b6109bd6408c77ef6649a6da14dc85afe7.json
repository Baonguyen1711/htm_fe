{"ast":null,"code":"import React from \"react\";\n\n// Define word object structure\nimport { Fragment as _Fragment, jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst CrosswordGrid = ({\n  placedWords,\n  boardSize = 20\n}) => {\n  // 1. Create initial grid\n  function createEmptyGrid(width, height) {\n    return Array.from({\n      length: height\n    }, () => Array.from({\n      length: width\n    }, () => null));\n  }\n\n  // 2. Convert word to WordObj\n  function wordToObj(word, index) {\n    return {\n      string: `${index + 1}${word}`,\n      char: ` ${index + 1}${word} `.split(''),\n      dir: 0,\n      x: -1,\n      y: -1,\n      totalMatches: 0,\n      effectiveMatches: 0,\n      successfulMatches: []\n    };\n  }\n\n  // 3. Check if a word can be placed\n  function canPlaceWord(grid, word, x, y, dir) {\n    const {\n      char\n    } = word;\n    for (let i = 0; i < char.length; i++) {\n      const xi = dir === 0 ? x + i : x;\n      const yi = dir === 1 ? y + i : y;\n      if (yi >= grid.length || xi >= grid[0].length) return false;\n      console.log(\"yi\", yi);\n      console.log();\n      const cell = grid[yi][xi];\n      if (cell && cell.char !== char[i]) return false;\n    }\n    return true;\n  }\n\n  // 4. Place word on grid\n  function placeWord(grid, word, x, y, dir, index) {\n    word.x = x;\n    word.y = y;\n    word.dir = dir;\n    for (let i = 0; i < word.char.length; i++) {\n      const xi = dir === 0 ? x + i : x;\n      const yi = dir === 1 ? y + i : y;\n      grid[yi][xi] = {\n        char: word.char[i],\n        wordIndex: index\n      };\n    }\n  }\n\n  // 5. Try placing word with maximum overlap\n  function tryPlaceWithOverlap(grid, words, word, index) {\n    let bestPlacement = null;\n    let maxMatches = 0;\n    for (let placedWord of words) {\n      for (let i = 0; i < placedWord.char.length; i++) {\n        for (let j = 0; j < word.char.length; j++) {\n          if (placedWord.char[i] !== word.char[j]) continue;\n          const dir = placedWord.dir === 0 ? 1 : 0;\n          const x = placedWord.x + (placedWord.dir === 0 ? i : 0) - (dir === 0 ? j : 0);\n          const y = placedWord.y + (placedWord.dir === 1 ? i : 0) - (dir === 1 ? j : 0);\n          if (canPlaceWord(grid, word, x, y, dir)) {\n            const matches = countEffectiveMatches(grid, word, x, y, dir);\n            if (matches > maxMatches) {\n              maxMatches = matches;\n              bestPlacement = {\n                x,\n                y,\n                dir\n              };\n            }\n          }\n        }\n      }\n    }\n    if (bestPlacement) {\n      placeWord(grid, word, bestPlacement.x, bestPlacement.y, bestPlacement.dir, index);\n      word.effectiveMatches = maxMatches;\n      return true;\n    }\n    return false;\n  }\n\n  // 6. Count effective matches at a given position\n  function countEffectiveMatches(grid, word, x, y, dir) {\n    let count = 0;\n    for (let i = 0; i < word.char.length; i++) {\n      var _grid$yi;\n      const xi = dir === 0 ? x + i : x;\n      const yi = dir === 1 ? y + i : y;\n      const cell = (_grid$yi = grid[yi]) === null || _grid$yi === void 0 ? void 0 : _grid$yi[xi];\n      if (cell && cell.char === word.char[i]) count++;\n    }\n    return count;\n  }\n\n  // 7. Main logic to place all words\n  function placeWords(wordList) {\n    const grid = createEmptyGrid(18, 18);\n    const words = wordList.map(wordToObj);\n    placeWord(grid, words[0], 12, 12, 0, 0);\n    for (let i = 1; i < words.length; i++) {\n      if (!tryPlaceWithOverlap(grid, words.slice(0, i), words[i], i)) {\n        // fallback: just place it further down if overlap fails\n        placeWord(grid, words[i], 2, 2 + i * 5, 0, i);\n      }\n    }\n    return words;\n  }\n  const wordList = ['GIÓ', 'HẠT GIỐNG', 'DREAM', 'THUỐC', 'CÚC', 'CHÂU KIỆT LUÂN'];\n  console.log(placeWords(wordList));\n  return /*#__PURE__*/_jsxDEV(_Fragment, {}, void 0, false);\n};\n_c = CrosswordGrid;\nexport default CrosswordGrid;\n\n// Main React Component\nconst WordBoard = () => {\n  // TypeScript version of the crossword builder with shuffled letter matches\n\n  return /*#__PURE__*/_jsxDEV(_Fragment, {}, void 0, false);\n};\n_c2 = WordBoard;\nvar _c, _c2;\n$RefreshReg$(_c, \"CrosswordGrid\");\n$RefreshReg$(_c2, \"WordBoard\");","map":{"version":3,"names":["React","Fragment","_Fragment","jsxDEV","_jsxDEV","CrosswordGrid","placedWords","boardSize","createEmptyGrid","width","height","Array","from","length","wordToObj","word","index","string","char","split","dir","x","y","totalMatches","effectiveMatches","successfulMatches","canPlaceWord","grid","i","xi","yi","console","log","cell","placeWord","wordIndex","tryPlaceWithOverlap","words","bestPlacement","maxMatches","placedWord","j","matches","countEffectiveMatches","count","_grid$yi","placeWords","wordList","map","slice","_c","WordBoard","_c2","$RefreshReg$"],"sources":["C:/Users/ASUS/Documents/htm_fe/src/pages/Host/Management/HostRound2.tsx"],"sourcesContent":["import React, { useState, useEffect } from \"react\";\r\n\r\n// Define word object structure\r\n\r\ntype WordPlacement = {\r\n  word: string;\r\n  x: number;\r\n  y: number;\r\n  direction: \"horizontal\" | \"vertical\";\r\n};\r\n\r\ninterface CrosswordGridProps {\r\n  placedWords?: WordPlacement[];\r\n  boardSize?: number;\r\n}\r\n\r\nconst CrosswordGrid: React.FC<CrosswordGridProps> = ({ placedWords, boardSize = 20 }) => {\r\n\r\n  interface WordObj {\r\n    string: string;\r\n    char: string[];\r\n    dir: 0 | 1; // 0 = horizontal, 1 = vertical\r\n    x: number;\r\n    y: number;\r\n    totalMatches: number;\r\n    effectiveMatches: number;\r\n    successfulMatches: { x: number; y: number }[];\r\n  }\r\n\r\n  interface GridCell {\r\n    char: string;\r\n    wordIndex: number;\r\n  }\r\n\r\n  type Grid = (GridCell | null)[][];\r\n\r\n  // 1. Create initial grid\r\n  function createEmptyGrid(width: number, height: number): Grid {\r\n    return Array.from({ length: height }, () => Array.from({ length: width }, () => null));\r\n  }\r\n\r\n  // 2. Convert word to WordObj\r\n  function wordToObj(word: string, index: number): WordObj {\r\n    return {\r\n      string: `${index + 1}${word}`,\r\n      char: (` ${index + 1}${word} `).split(''),\r\n      dir: 0,\r\n      x: -1,\r\n      y: -1,\r\n      totalMatches: 0,\r\n      effectiveMatches: 0,\r\n      successfulMatches: [],\r\n    };\r\n  }\r\n\r\n  // 3. Check if a word can be placed\r\n  function canPlaceWord(grid: Grid, word: WordObj, x: number, y: number, dir: 0 | 1): boolean {\r\n    const { char } = word;\r\n    for (let i = 0; i < char.length; i++) {\r\n      const xi = dir === 0 ? x + i : x;\r\n      const yi = dir === 1 ? y + i : y;\r\n      if (yi >= grid.length || xi >= grid[0].length) return false;\r\n      console.log(\"yi\", yi);\r\n      console.log();\r\n      \r\n      \r\n      const cell = grid[yi][xi];\r\n      if (cell && cell.char !== char[i]) return false;\r\n    }\r\n    return true;\r\n  }\r\n\r\n  // 4. Place word on grid\r\n  function placeWord(grid: Grid, word: WordObj, x: number, y: number, dir: 0 | 1, index: number): void {\r\n    word.x = x;\r\n    word.y = y;\r\n    word.dir = dir;\r\n    for (let i = 0; i < word.char.length; i++) {\r\n      const xi = dir === 0 ? x + i : x;\r\n      const yi = dir === 1 ? y + i : y;\r\n      grid[yi][xi] = { char: word.char[i], wordIndex: index };\r\n    }\r\n  }\r\n\r\n  // 5. Try placing word with maximum overlap\r\n  function tryPlaceWithOverlap(grid: Grid, words: WordObj[], word: WordObj, index: number): boolean {\r\n    let bestPlacement = null;\r\n    let maxMatches = 0;\r\n\r\n    for (let placedWord of words) {\r\n      for (let i = 0; i < placedWord.char.length; i++) {\r\n        for (let j = 0; j < word.char.length; j++) {\r\n          if (placedWord.char[i] !== word.char[j]) continue;\r\n\r\n          const dir = placedWord.dir === 0 ? 1 : 0;\r\n          const x = placedWord.x + (placedWord.dir === 0 ? i : 0) - (dir === 0 ? j : 0);\r\n          const y = placedWord.y + (placedWord.dir === 1 ? i : 0) - (dir === 1 ? j : 0);\r\n\r\n          if (canPlaceWord(grid, word, x, y, dir)) {\r\n            const matches = countEffectiveMatches(grid, word, x, y, dir);\r\n            if (matches > maxMatches) {\r\n              maxMatches = matches;\r\n              bestPlacement = { x, y, dir };\r\n            }\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    if (bestPlacement) {\r\n      placeWord(grid, word, bestPlacement.x, bestPlacement.y, bestPlacement.dir as 0 | 1, index);\r\n      word.effectiveMatches = maxMatches;\r\n      return true;\r\n    }\r\n\r\n    return false;\r\n  }\r\n\r\n  // 6. Count effective matches at a given position\r\n  function countEffectiveMatches(grid: Grid, word: WordObj, x: number, y: number, dir: 0 | 1): number {\r\n    let count = 0;\r\n    for (let i = 0; i < word.char.length; i++) {\r\n      const xi = dir === 0 ? x + i : x;\r\n      const yi = dir === 1 ? y + i : y;\r\n      const cell = grid[yi]?.[xi];\r\n      if (cell && cell.char === word.char[i]) count++;\r\n    }\r\n    return count;\r\n  }\r\n\r\n  // 7. Main logic to place all words\r\n  function placeWords(wordList: string[]): WordObj[] {\r\n    const grid = createEmptyGrid(18, 18);\r\n    const words: WordObj[] = wordList.map(wordToObj);\r\n\r\n    placeWord(grid, words[0], 12, 12, 0, 0);\r\n\r\n    for (let i = 1; i < words.length; i++) {\r\n      if (!tryPlaceWithOverlap(grid, words.slice(0, i), words[i], i)) {\r\n        // fallback: just place it further down if overlap fails\r\n        placeWord(grid, words[i], 2, 2 + i * 5, 0, i);\r\n      }\r\n    }\r\n\r\n    return words;\r\n  }\r\n\r\n  const wordList = [\r\n    'GIÓ',\r\n    'HẠT GIỐNG',\r\n    'DREAM',\r\n    'THUỐC',\r\n    'CÚC',\r\n    'CHÂU KIỆT LUÂN',\r\n  ]\r\n\r\n  console.log(placeWords(wordList));\r\n  \r\n\r\n  return (\r\n    <>\r\n    </>\r\n  );\r\n};\r\n\r\nexport default CrosswordGrid;\r\n\r\n\r\n// Main React Component\r\nconst WordBoard: React.FC = () => {\r\n  // TypeScript version of the crossword builder with shuffled letter matches\r\n\r\n\r\n\r\n  return (\r\n    <>\r\n    </>\r\n  );\r\n};\r\n\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}