{"ast":null,"code":"var _jsxFileName = \"C:\\\\Users\\\\ASUS\\\\Documents\\\\htm_fe\\\\src\\\\pages\\\\User\\\\Round2.tsx\",\n  _s = $RefreshSig$();\nimport Play from \"../../layouts/Play\";\nimport React, { useState, useEffect } from \"react\";\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst mainKeyword = \"VIETTEL\";\nconst GRID_SIZE = 20; // 🔹 Tăng kích thước lên 20x20\n\nconst generateHintWords = (words, gridSize) => {\n  const placedWords = [];\n  const occupiedPositions = new Set();\n  const getKey = (x, y) => `${x},${y}`;\n  const canPlaceWord = (word, x, y, direction) => {\n    for (let i = 0; i < word.length; i++) {\n      let newX = direction === \"horizontal\" ? x + i : x;\n      let newY = direction === \"horizontal\" ? y : y + i;\n      if (newX >= gridSize || newY >= gridSize || occupiedPositions.has(getKey(newX, newY))) {\n        return false;\n      }\n    }\n    return true;\n  };\n  words.forEach(word => {\n    for (let attempt = 0; attempt < 100; attempt++) {\n      let direction = Math.random() < 0.5 ? \"horizontal\" : \"vertical\";\n      let x = Math.floor(Math.random() * (direction === \"horizontal\" ? gridSize - word.length : gridSize));\n      let y = Math.floor(Math.random() * (direction === \"vertical\" ? gridSize - word.length : gridSize));\n      if (canPlaceWord(word, x, y, direction)) {\n        placedWords.push({\n          word,\n          x,\n          y,\n          direction\n        });\n        for (let i = 0; i < word.length; i++) {\n          let newX = direction === \"horizontal\" ? x + i : x;\n          let newY = direction === \"horizontal\" ? y : y + i;\n          occupiedPositions.add(getKey(newX, newY));\n        }\n        break;\n      }\n    }\n  });\n  return placedWords;\n};\nconst generateEmptyGrid = () => {\n  return Array(GRID_SIZE).fill(null).map(() => Array(GRID_SIZE).fill(\"\"));\n};\nconst ObstacleQuestionBox = ({\n  obstacleWord\n}) => {\n  _s();\n  const [grid, setGrid] = useState(generateEmptyGrid());\n  const [revealedCells, setRevealedCells] = useState(Array(GRID_SIZE).fill(null).map(() => Array(GRID_SIZE).fill(false)));\n  const [hintWords, setHintWords] = useState([]);\n  useEffect(() => {\n    const randomHintWords = generateHintWords([\"GIÓ\", \"HẠT\", \"DREAM\", \"THUỐC\", \"CÚC\", \"CHÂU\"], GRID_SIZE);\n    setHintWords(randomHintWords);\n    let newGrid = generateEmptyGrid();\n    randomHintWords.forEach(({\n      word,\n      x,\n      y,\n      direction\n    }) => {\n      for (let i = 0; i < word.length; i++) {\n        if (direction === \"horizontal\") {\n          newGrid[y][x + i] = word[i];\n        } else {\n          newGrid[y + i][x] = word[i];\n        }\n      }\n    });\n    setGrid(newGrid);\n  }, []);\n  const toggleCell = (row, col) => {\n    setRevealedCells(prev => {\n      const newRevealed = prev.map(r => [...r]);\n      newRevealed[row][col] = !newRevealed[row][col];\n      return newRevealed;\n    });\n  };\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    className: \"flex flex-col items-center bg-white rounded-lg shadow-md p-6\",\n    children: /*#__PURE__*/_jsxDEV(\"div\", {\n      className: \"grid grid-cols-20 gap-0\",\n      children: grid.map((row, rowIndex) => row.map((cell, colIndex) => {\n        const isRevealed = revealedCells[rowIndex][colIndex];\n        return /*#__PURE__*/_jsxDEV(\"div\", {\n          onClick: () => toggleCell(rowIndex, colIndex),\n          className: `w-6 h-6 border flex items-center justify-center text-lg font-semibold select-none \n                                    ${isRevealed ? \"text-black\" : \"text-transparent\"}\n                                    ${obstacleWord.includes(cell) && isRevealed ? \"font-bold text-red-500\" : \"\"}\n                                    ${cell === \"\" ? \"border-none\" : \"border-gray-400\"}\n                                `,\n          children: cell\n        }, `${rowIndex}-${colIndex}`, false, {\n          fileName: _jsxFileName,\n          lineNumber: 108,\n          columnNumber: 29\n        }, this);\n      }))\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 102,\n      columnNumber: 13\n    }, this)\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 101,\n    columnNumber: 9\n  }, this);\n};\n_s(ObstacleQuestionBox, \"ueFfNWUjLtYYmW2QZ2Ay4xmz6dM=\");\n_c = ObstacleQuestionBox;\nfunction Round2() {\n  return /*#__PURE__*/_jsxDEV(Play, {\n    questionComponent: /*#__PURE__*/_jsxDEV(ObstacleQuestionBox, {\n      obstacleWord: mainKeyword\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 128,\n      columnNumber: 37\n    }, this)\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 128,\n    columnNumber: 12\n  }, this);\n}\n_c2 = Round2;\nexport default Round2;\nvar _c, _c2;\n$RefreshReg$(_c, \"ObstacleQuestionBox\");\n$RefreshReg$(_c2, \"Round2\");","map":{"version":3,"names":["Play","React","useState","useEffect","jsxDEV","_jsxDEV","mainKeyword","GRID_SIZE","generateHintWords","words","gridSize","placedWords","occupiedPositions","Set","getKey","x","y","canPlaceWord","word","direction","i","length","newX","newY","has","forEach","attempt","Math","random","floor","push","add","generateEmptyGrid","Array","fill","map","ObstacleQuestionBox","obstacleWord","_s","grid","setGrid","revealedCells","setRevealedCells","hintWords","setHintWords","randomHintWords","newGrid","toggleCell","row","col","prev","newRevealed","r","className","children","rowIndex","cell","colIndex","isRevealed","onClick","includes","fileName","_jsxFileName","lineNumber","columnNumber","_c","Round2","questionComponent","_c2","$RefreshReg$"],"sources":["C:/Users/ASUS/Documents/htm_fe/src/pages/User/Round2.tsx"],"sourcesContent":["import Play from \"../../layouts/Play\";\r\nimport React, { useState, useEffect } from \"react\";\r\n\r\ninterface HintWord {\r\n    word: string;\r\n    x: number;\r\n    y: number;\r\n    direction: \"horizontal\" | \"vertical\";\r\n}\r\n\r\ninterface ObstacleQuestionBoxProps {\r\n    obstacleWord: string;\r\n}\r\n\r\ntype PlacedWord = {\r\n    word: string;\r\n    x: number;\r\n    y: number;\r\n    direction: \"horizontal\" | \"vertical\";\r\n};\r\n\r\nconst mainKeyword = \"VIETTEL\";\r\nconst GRID_SIZE = 20; // 🔹 Tăng kích thước lên 20x20\r\n\r\nconst generateHintWords = (words: string[], gridSize: number): HintWord[] => {\r\n    const placedWords: PlacedWord[] = [];\r\n    const occupiedPositions = new Set<string>();\r\n\r\n    const getKey = (x: number, y: number) => `${x},${y}`;\r\n\r\n    const canPlaceWord = (word: string, x: number, y: number, direction: \"horizontal\" | \"vertical\") => {\r\n        for (let i = 0; i < word.length; i++) {\r\n            let newX = direction === \"horizontal\" ? x + i : x;\r\n            let newY = direction === \"horizontal\" ? y : y + i;\r\n            if (newX >= gridSize || newY >= gridSize || occupiedPositions.has(getKey(newX, newY))) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    };\r\n\r\n    words.forEach((word) => {\r\n        for (let attempt = 0; attempt < 100; attempt++) {\r\n            let direction: \"horizontal\" | \"vertical\" = Math.random() < 0.5 ? \"horizontal\" : \"vertical\";\r\n            let x = Math.floor(Math.random() * (direction === \"horizontal\" ? gridSize - word.length : gridSize));\r\n            let y = Math.floor(Math.random() * (direction === \"vertical\" ? gridSize - word.length : gridSize));\r\n\r\n            if (canPlaceWord(word, x, y, direction)) {\r\n                placedWords.push({ word, x, y, direction });\r\n                for (let i = 0; i < word.length; i++) {\r\n                    let newX = direction === \"horizontal\" ? x + i : x;\r\n                    let newY = direction === \"horizontal\" ? y : y + i;\r\n                    occupiedPositions.add(getKey(newX, newY));\r\n                }\r\n                break;\r\n            }\r\n        }\r\n    });\r\n\r\n    return placedWords;\r\n};\r\n\r\nconst generateEmptyGrid = () => {\r\n    return Array(GRID_SIZE).fill(null).map(() => Array(GRID_SIZE).fill(\"\"));\r\n};\r\n\r\nconst ObstacleQuestionBox: React.FC<ObstacleQuestionBoxProps> = ({ obstacleWord }) => {\r\n    const [grid, setGrid] = useState<string[][]>(generateEmptyGrid());\r\n    const [revealedCells, setRevealedCells] = useState<boolean[][]>(\r\n        Array(GRID_SIZE).fill(null).map(() => Array(GRID_SIZE).fill(false))\r\n    );\r\n    const [hintWords, setHintWords] = useState<HintWord[]>([]);\r\n\r\n    useEffect(() => {\r\n        const randomHintWords = generateHintWords([\"GIÓ\", \"HẠT\", \"DREAM\", \"THUỐC\", \"CÚC\", \"CHÂU\"], GRID_SIZE);\r\n        setHintWords(randomHintWords);\r\n        let newGrid = generateEmptyGrid();\r\n\r\n        randomHintWords.forEach(({ word, x, y, direction }) => {\r\n            for (let i = 0; i < word.length; i++) {\r\n                if (direction === \"horizontal\") {\r\n                    newGrid[y][x + i] = word[i];\r\n                } else {\r\n                    newGrid[y + i][x] = word[i];\r\n                }\r\n            }\r\n        });\r\n\r\n        setGrid(newGrid);\r\n    }, []);\r\n\r\n    const toggleCell = (row: number, col: number) => {\r\n        setRevealedCells((prev) => {\r\n            const newRevealed = prev.map((r) => [...r]);\r\n            newRevealed[row][col] = !newRevealed[row][col];\r\n            return newRevealed;\r\n        });\r\n    };\r\n\r\n    return (\r\n        <div className=\"flex flex-col items-center bg-white rounded-lg shadow-md p-6\">\r\n            <div className=\"grid grid-cols-20 gap-0\">\r\n                {grid.map((row, rowIndex) =>\r\n                    row.map((cell, colIndex) => {\r\n                        const isRevealed = revealedCells[rowIndex][colIndex];\r\n\r\n                        return (\r\n                            <div\r\n                                key={`${rowIndex}-${colIndex}`}\r\n                                onClick={() => toggleCell(rowIndex, colIndex)}\r\n                                className={`w-6 h-6 border flex items-center justify-center text-lg font-semibold select-none \r\n                                    ${isRevealed ? \"text-black\" : \"text-transparent\"}\r\n                                    ${obstacleWord.includes(cell) && isRevealed ? \"font-bold text-red-500\" : \"\"}\r\n                                    ${cell === \"\" ? \"border-none\" : \"border-gray-400\"}\r\n                                `}\r\n                            >\r\n                                {cell}\r\n                            </div>\r\n                        );\r\n                    })\r\n                )}\r\n            </div>\r\n        </div>\r\n    );\r\n};\r\n\r\nfunction Round2() {\r\n    return <Play questionComponent={<ObstacleQuestionBox obstacleWord={mainKeyword} />} />;\r\n}\r\n\r\nexport default Round2;\r\n"],"mappings":";;AAAA,OAAOA,IAAI,MAAM,oBAAoB;AACrC,OAAOC,KAAK,IAAIC,QAAQ,EAAEC,SAAS,QAAQ,OAAO;AAAC,SAAAC,MAAA,IAAAC,OAAA;AAoBnD,MAAMC,WAAW,GAAG,SAAS;AAC7B,MAAMC,SAAS,GAAG,EAAE,CAAC,CAAC;;AAEtB,MAAMC,iBAAiB,GAAGA,CAACC,KAAe,EAAEC,QAAgB,KAAiB;EACzE,MAAMC,WAAyB,GAAG,EAAE;EACpC,MAAMC,iBAAiB,GAAG,IAAIC,GAAG,CAAS,CAAC;EAE3C,MAAMC,MAAM,GAAGA,CAACC,CAAS,EAAEC,CAAS,KAAK,GAAGD,CAAC,IAAIC,CAAC,EAAE;EAEpD,MAAMC,YAAY,GAAGA,CAACC,IAAY,EAAEH,CAAS,EAAEC,CAAS,EAAEG,SAAoC,KAAK;IAC/F,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGF,IAAI,CAACG,MAAM,EAAED,CAAC,EAAE,EAAE;MAClC,IAAIE,IAAI,GAAGH,SAAS,KAAK,YAAY,GAAGJ,CAAC,GAAGK,CAAC,GAAGL,CAAC;MACjD,IAAIQ,IAAI,GAAGJ,SAAS,KAAK,YAAY,GAAGH,CAAC,GAAGA,CAAC,GAAGI,CAAC;MACjD,IAAIE,IAAI,IAAIZ,QAAQ,IAAIa,IAAI,IAAIb,QAAQ,IAAIE,iBAAiB,CAACY,GAAG,CAACV,MAAM,CAACQ,IAAI,EAAEC,IAAI,CAAC,CAAC,EAAE;QACnF,OAAO,KAAK;MAChB;IACJ;IACA,OAAO,IAAI;EACf,CAAC;EAEDd,KAAK,CAACgB,OAAO,CAAEP,IAAI,IAAK;IACpB,KAAK,IAAIQ,OAAO,GAAG,CAAC,EAAEA,OAAO,GAAG,GAAG,EAAEA,OAAO,EAAE,EAAE;MAC5C,IAAIP,SAAoC,GAAGQ,IAAI,CAACC,MAAM,CAAC,CAAC,GAAG,GAAG,GAAG,YAAY,GAAG,UAAU;MAC1F,IAAIb,CAAC,GAAGY,IAAI,CAACE,KAAK,CAACF,IAAI,CAACC,MAAM,CAAC,CAAC,IAAIT,SAAS,KAAK,YAAY,GAAGT,QAAQ,GAAGQ,IAAI,CAACG,MAAM,GAAGX,QAAQ,CAAC,CAAC;MACpG,IAAIM,CAAC,GAAGW,IAAI,CAACE,KAAK,CAACF,IAAI,CAACC,MAAM,CAAC,CAAC,IAAIT,SAAS,KAAK,UAAU,GAAGT,QAAQ,GAAGQ,IAAI,CAACG,MAAM,GAAGX,QAAQ,CAAC,CAAC;MAElG,IAAIO,YAAY,CAACC,IAAI,EAAEH,CAAC,EAAEC,CAAC,EAAEG,SAAS,CAAC,EAAE;QACrCR,WAAW,CAACmB,IAAI,CAAC;UAAEZ,IAAI;UAAEH,CAAC;UAAEC,CAAC;UAAEG;QAAU,CAAC,CAAC;QAC3C,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGF,IAAI,CAACG,MAAM,EAAED,CAAC,EAAE,EAAE;UAClC,IAAIE,IAAI,GAAGH,SAAS,KAAK,YAAY,GAAGJ,CAAC,GAAGK,CAAC,GAAGL,CAAC;UACjD,IAAIQ,IAAI,GAAGJ,SAAS,KAAK,YAAY,GAAGH,CAAC,GAAGA,CAAC,GAAGI,CAAC;UACjDR,iBAAiB,CAACmB,GAAG,CAACjB,MAAM,CAACQ,IAAI,EAAEC,IAAI,CAAC,CAAC;QAC7C;QACA;MACJ;IACJ;EACJ,CAAC,CAAC;EAEF,OAAOZ,WAAW;AACtB,CAAC;AAED,MAAMqB,iBAAiB,GAAGA,CAAA,KAAM;EAC5B,OAAOC,KAAK,CAAC1B,SAAS,CAAC,CAAC2B,IAAI,CAAC,IAAI,CAAC,CAACC,GAAG,CAAC,MAAMF,KAAK,CAAC1B,SAAS,CAAC,CAAC2B,IAAI,CAAC,EAAE,CAAC,CAAC;AAC3E,CAAC;AAED,MAAME,mBAAuD,GAAGA,CAAC;EAAEC;AAAa,CAAC,KAAK;EAAAC,EAAA;EAClF,MAAM,CAACC,IAAI,EAAEC,OAAO,CAAC,GAAGtC,QAAQ,CAAa8B,iBAAiB,CAAC,CAAC,CAAC;EACjE,MAAM,CAACS,aAAa,EAAEC,gBAAgB,CAAC,GAAGxC,QAAQ,CAC9C+B,KAAK,CAAC1B,SAAS,CAAC,CAAC2B,IAAI,CAAC,IAAI,CAAC,CAACC,GAAG,CAAC,MAAMF,KAAK,CAAC1B,SAAS,CAAC,CAAC2B,IAAI,CAAC,KAAK,CAAC,CACtE,CAAC;EACD,MAAM,CAACS,SAAS,EAAEC,YAAY,CAAC,GAAG1C,QAAQ,CAAa,EAAE,CAAC;EAE1DC,SAAS,CAAC,MAAM;IACZ,MAAM0C,eAAe,GAAGrC,iBAAiB,CAAC,CAAC,KAAK,EAAE,KAAK,EAAE,OAAO,EAAE,OAAO,EAAE,KAAK,EAAE,MAAM,CAAC,EAAED,SAAS,CAAC;IACrGqC,YAAY,CAACC,eAAe,CAAC;IAC7B,IAAIC,OAAO,GAAGd,iBAAiB,CAAC,CAAC;IAEjCa,eAAe,CAACpB,OAAO,CAAC,CAAC;MAAEP,IAAI;MAAEH,CAAC;MAAEC,CAAC;MAAEG;IAAU,CAAC,KAAK;MACnD,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGF,IAAI,CAACG,MAAM,EAAED,CAAC,EAAE,EAAE;QAClC,IAAID,SAAS,KAAK,YAAY,EAAE;UAC5B2B,OAAO,CAAC9B,CAAC,CAAC,CAACD,CAAC,GAAGK,CAAC,CAAC,GAAGF,IAAI,CAACE,CAAC,CAAC;QAC/B,CAAC,MAAM;UACH0B,OAAO,CAAC9B,CAAC,GAAGI,CAAC,CAAC,CAACL,CAAC,CAAC,GAAGG,IAAI,CAACE,CAAC,CAAC;QAC/B;MACJ;IACJ,CAAC,CAAC;IAEFoB,OAAO,CAACM,OAAO,CAAC;EACpB,CAAC,EAAE,EAAE,CAAC;EAEN,MAAMC,UAAU,GAAGA,CAACC,GAAW,EAAEC,GAAW,KAAK;IAC7CP,gBAAgB,CAAEQ,IAAI,IAAK;MACvB,MAAMC,WAAW,GAAGD,IAAI,CAACf,GAAG,CAAEiB,CAAC,IAAK,CAAC,GAAGA,CAAC,CAAC,CAAC;MAC3CD,WAAW,CAACH,GAAG,CAAC,CAACC,GAAG,CAAC,GAAG,CAACE,WAAW,CAACH,GAAG,CAAC,CAACC,GAAG,CAAC;MAC9C,OAAOE,WAAW;IACtB,CAAC,CAAC;EACN,CAAC;EAED,oBACI9C,OAAA;IAAKgD,SAAS,EAAC,8DAA8D;IAAAC,QAAA,eACzEjD,OAAA;MAAKgD,SAAS,EAAC,yBAAyB;MAAAC,QAAA,EACnCf,IAAI,CAACJ,GAAG,CAAC,CAACa,GAAG,EAAEO,QAAQ,KACpBP,GAAG,CAACb,GAAG,CAAC,CAACqB,IAAI,EAAEC,QAAQ,KAAK;QACxB,MAAMC,UAAU,GAAGjB,aAAa,CAACc,QAAQ,CAAC,CAACE,QAAQ,CAAC;QAEpD,oBACIpD,OAAA;UAEIsD,OAAO,EAAEA,CAAA,KAAMZ,UAAU,CAACQ,QAAQ,EAAEE,QAAQ,CAAE;UAC9CJ,SAAS,EAAE;AAC3C,sCAAsCK,UAAU,GAAG,YAAY,GAAG,kBAAkB;AACpF,sCAAsCrB,YAAY,CAACuB,QAAQ,CAACJ,IAAI,CAAC,IAAIE,UAAU,GAAG,wBAAwB,GAAG,EAAE;AAC/G,sCAAsCF,IAAI,KAAK,EAAE,GAAG,aAAa,GAAG,iBAAiB;AACrF,iCAAkC;UAAAF,QAAA,EAEDE;QAAI,GARA,GAAGD,QAAQ,IAAIE,QAAQ,EAAE;UAAAI,QAAA,EAAAC,YAAA;UAAAC,UAAA;UAAAC,YAAA;QAAA,OAS7B,CAAC;MAEd,CAAC,CACL;IAAC;MAAAH,QAAA,EAAAC,YAAA;MAAAC,UAAA;MAAAC,YAAA;IAAA,OACA;EAAC;IAAAH,QAAA,EAAAC,YAAA;IAAAC,UAAA;IAAAC,YAAA;EAAA,OACL,CAAC;AAEd,CAAC;AAAC1B,EAAA,CA1DIF,mBAAuD;AAAA6B,EAAA,GAAvD7B,mBAAuD;AA4D7D,SAAS8B,MAAMA,CAAA,EAAG;EACd,oBAAO7D,OAAA,CAACL,IAAI;IAACmE,iBAAiB,eAAE9D,OAAA,CAAC+B,mBAAmB;MAACC,YAAY,EAAE/B;IAAY;MAAAuD,QAAA,EAAAC,YAAA;MAAAC,UAAA;MAAAC,YAAA;IAAA,OAAE;EAAE;IAAAH,QAAA,EAAAC,YAAA;IAAAC,UAAA;IAAAC,YAAA;EAAA,OAAE,CAAC;AAC1F;AAACI,GAAA,GAFQF,MAAM;AAIf,eAAeA,MAAM;AAAC,IAAAD,EAAA,EAAAG,GAAA;AAAAC,YAAA,CAAAJ,EAAA;AAAAI,YAAA,CAAAD,GAAA","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}