{"ast":null,"code":"var _jsxFileName = \"C:\\\\Users\\\\ASUS\\\\Documents\\\\htm_fe\\\\src\\\\pages\\\\Host\\\\Management\\\\HostRound2.tsx\";\nimport React from \"react\";\n\n// Define word object structure\nimport { jsxDEV as _jsxDEV, Fragment as _Fragment } from \"react/jsx-dev-runtime\";\nconst CrosswordGrid = ({\n  placedWords,\n  boardSize = 25\n}) => {\n  class WordObj {\n    constructor(word) {\n      this.string = void 0;\n      this.char = void 0;\n      this.totalMatches = 0;\n      this.effectiveMatches = 0;\n      this.successfulMatches = [];\n      this.x = 0;\n      this.y = 0;\n      this.dir = 0;\n      this.string = word;\n      this.char = word.split('');\n    }\n  }\n  function shuffleArray(array) {\n    const arr = [...array];\n    for (let i = arr.length - 1; i > 0; i--) {\n      const j = Math.floor(Math.random() * (i + 1));\n      [arr[i], arr[j]] = [arr[j], arr[i]];\n    }\n    return arr;\n  }\n  function generateCrossword(words) {\n    const boardSize = 20;\n    const board = Array.from({\n      length: boardSize\n    }, () => Array(boardSize).fill(null));\n    const wordObjs = words.map((word, i) => new WordObj(` ${i + 1}${word} `));\n    const placedWords = [];\n\n    // Calculate totalMatches\n    for (let i = 0; i < wordObjs.length; i++) {\n      for (let j = 0; j < wordObjs[i].char.length; j++) {\n        for (let k = 0; k < wordObjs.length; k++) {\n          if (k === i) continue;\n          for (let l = 0; l < wordObjs[k].char.length; l++) {\n            if (wordObjs[i].char[j] === wordObjs[k].char[l]) {\n              wordObjs[i].totalMatches++;\n            }\n          }\n        }\n      }\n    }\n    function canPlaceWord(word, x, y, dir) {\n      for (let i = 0; i < word.char.length; i++) {\n        const xi = dir === 0 ? x + i : x;\n        const yi = dir === 1 ? y + i : y;\n        if (xi < 0 || xi >= boardSize || yi < 0 || yi >= boardSize) return false;\n        if (board[xi][yi] && board[xi][yi] !== word.char[i]) return false;\n      }\n      return true;\n    }\n    function placeWord(word, x, y, dir) {\n      for (let i = 0; i < word.char.length; i++) {\n        const xi = dir === 0 ? x + i : x;\n        const yi = dir === 1 ? y + i : y;\n        board[xi][yi] = word.char[i];\n      }\n      word.x = x;\n      word.y = y;\n      word.dir = dir;\n      placedWords.push(word);\n    }\n    function addWordToBoard() {\n      if (placedWords.length === 0) {\n        // Place the word with fewest totalMatches in center\n        let idx = 0;\n        for (let i = 1; i < wordObjs.length; i++) {\n          if (wordObjs[i].totalMatches < wordObjs[idx].totalMatches) idx = i;\n        }\n        const word = wordObjs.splice(idx, 1)[0];\n        placeWord(word, Math.floor(boardSize / 2), Math.floor(boardSize / 2), 0);\n        return true;\n      }\n      let selectedIdx = -1;\n      let minDiff = Infinity;\n      for (let i = 0; i < wordObjs.length; i++) {\n        const word = wordObjs[i];\n        word.effectiveMatches = 0;\n        word.successfulMatches = [];\n        for (const j of shuffleArray([...Array(word.char.length).keys()])) {\n          const curChar = word.char[j];\n          for (const existing of placedWords) {\n            for (const l of shuffleArray([...Array(existing.char.length).keys()])) {\n              const testChar = existing.char[l];\n              if (curChar === testChar) {\n                word.effectiveMatches++;\n                const cross = {\n                  x: existing.x,\n                  y: existing.y,\n                  dir: 0\n                };\n                if (existing.dir === 0) {\n                  cross.dir = 1;\n                  cross.x += l;\n                  cross.y -= j;\n                } else {\n                  cross.dir = 0;\n                  cross.y += l;\n                  cross.x -= j;\n                }\n                if (canPlaceWord(word, cross.x, cross.y, cross.dir)) {\n                  word.successfulMatches.push(cross);\n                }\n              }\n            }\n          }\n        }\n        const diff = word.totalMatches - word.effectiveMatches;\n        if (diff < minDiff && word.successfulMatches.length > 0) {\n          minDiff = diff;\n          selectedIdx = i;\n        }\n      }\n      if (selectedIdx === -1) return false;\n      const selectedWord = wordObjs.splice(selectedIdx, 1)[0];\n      const shuffledMatches = shuffleArray(selectedWord.successfulMatches);\n      const chosen = shuffledMatches[0];\n      placeWord(selectedWord, chosen.x, chosen.y, chosen.dir);\n      return true;\n    }\n    while (wordObjs.length > 0 && addWordToBoard());\n    return placedWords.map(w => ({\n      word: w.string.trim().substring(w.string.indexOf(w.char[1])),\n      x: w.x,\n      y: w.y,\n      direction: w.dir === 0 ? 'horizontal' : 'vertical'\n    }));\n  }\n\n  // Example usage:\n  const result = generateCrossword(['GIÓ', 'HẠT GIỐNG', 'DREAM', 'THUỐC', 'CÚC', 'CHÂU KIỆT LUÂN']);\n  console.log(result);\n  // Initialize board\n  const board = Array.from({\n    length: boardSize\n  }, () => Array(boardSize).fill(null));\n\n  // Place words\n  for (const {\n    word,\n    x,\n    y,\n    direction\n  } of placedWords) {\n    for (let i = 0; i < word.length; i++) {\n      const char = word[i];\n      const dx = direction === \"horizontal\" ? i : 0;\n      const dy = direction === \"vertical\" ? i : 0;\n      const row = y + dy;\n      const col = x + dx;\n      if (row >= 0 && row < boardSize && col >= 0 && col < boardSize) {\n        board[row][col] = char;\n      }\n    }\n  }\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    className: \"grid bg-gray-500\",\n    style: {\n      gridTemplateColumns: `repeat(${boardSize}, 1.75rem)`,\n      gridAutoRows: \"1.75rem\"\n    },\n    children: board.flatMap((row, rowIndex) => row.map((char, colIndex) => /*#__PURE__*/_jsxDEV(\"div\", {\n      className: `w-7 h-7 text-sm flex items-center justify-center font-bold border border-gray-300 ${char ? \"bg-yellow-100 text-black\" : \"bg-white\"}`,\n      children: char\n    }, `${rowIndex}-${colIndex}`, false, {\n      fileName: _jsxFileName,\n      lineNumber: 209,\n      columnNumber: 11\n    }, this)))\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 200,\n    columnNumber: 5\n  }, this);\n};\n_c = CrosswordGrid;\nexport default CrosswordGrid;\n\n// Main React Component\nconst WordBoard = () => {\n  // TypeScript version of the crossword builder with shuffled letter matches\n\n  return /*#__PURE__*/_jsxDEV(_Fragment, {}, void 0, false);\n};\n_c2 = WordBoard;\nvar _c, _c2;\n$RefreshReg$(_c, \"CrosswordGrid\");\n$RefreshReg$(_c2, \"WordBoard\");","map":{"version":3,"names":["React","jsxDEV","_jsxDEV","Fragment","_Fragment","CrosswordGrid","placedWords","boardSize","WordObj","constructor","word","string","char","totalMatches","effectiveMatches","successfulMatches","x","y","dir","split","shuffleArray","array","arr","i","length","j","Math","floor","random","generateCrossword","words","board","Array","from","fill","wordObjs","map","k","l","canPlaceWord","xi","yi","placeWord","push","addWordToBoard","idx","splice","selectedIdx","minDiff","Infinity","keys","curChar","existing","testChar","cross","diff","selectedWord","shuffledMatches","chosen","w","trim","substring","indexOf","direction","result","console","log","dx","dy","row","col","className","style","gridTemplateColumns","gridAutoRows","children","flatMap","rowIndex","colIndex","fileName","_jsxFileName","lineNumber","columnNumber","_c","WordBoard","_c2","$RefreshReg$"],"sources":["C:/Users/ASUS/Documents/htm_fe/src/pages/Host/Management/HostRound2.tsx"],"sourcesContent":["import React, { useState, useEffect } from \"react\";\r\n\r\n// Define word object structure\r\n\r\ntype WordPlacement = {\r\n  word: string;\r\n  x: number;\r\n  y: number;\r\n  direction: \"horizontal\" | \"vertical\";\r\n};\r\n\r\ninterface CrosswordGridProps {\r\n  placedWords: WordPlacement[];\r\n  boardSize?: number;\r\n}\r\n\r\nconst CrosswordGrid: React.FC<CrosswordGridProps> = ({ placedWords, boardSize = 25 }) => {\r\n\r\n  type Direction = 'horizontal' | 'vertical';\r\n\r\n  interface PlacedWord {\r\n    word: string;\r\n    x: number;\r\n    y: number;\r\n    direction: Direction;\r\n  }\r\n\r\n  class WordObj {\r\n    string: string;\r\n    char: string[];\r\n    totalMatches: number = 0;\r\n    effectiveMatches: number = 0;\r\n    successfulMatches: { x: number; y: number; dir: number }[] = [];\r\n    x: number = 0;\r\n    y: number = 0;\r\n    dir: number = 0;\r\n\r\n    constructor(word: string) {\r\n      this.string = word;\r\n      this.char = word.split('');\r\n    }\r\n  }\r\n\r\n  function shuffleArray<T>(array: T[]): T[] {\r\n    const arr = [...array];\r\n    for (let i = arr.length - 1; i > 0; i--) {\r\n      const j = Math.floor(Math.random() * (i + 1));\r\n      [arr[i], arr[j]] = [arr[j], arr[i]];\r\n    }\r\n    return arr;\r\n  }\r\n\r\n  function generateCrossword(words: string[]): PlacedWord[] {\r\n    const boardSize = 20;\r\n    const board: (string | null)[][] = Array.from({ length: boardSize }, () => Array(boardSize).fill(null));\r\n    const wordObjs: WordObj[] = words.map((word, i) => new WordObj(` ${i + 1}${word} `));\r\n    const placedWords: WordObj[] = [];\r\n\r\n    // Calculate totalMatches\r\n    for (let i = 0; i < wordObjs.length; i++) {\r\n      for (let j = 0; j < wordObjs[i].char.length; j++) {\r\n        for (let k = 0; k < wordObjs.length; k++) {\r\n          if (k === i) continue;\r\n          for (let l = 0; l < wordObjs[k].char.length; l++) {\r\n            if (wordObjs[i].char[j] === wordObjs[k].char[l]) {\r\n              wordObjs[i].totalMatches++;\r\n            }\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    function canPlaceWord(word: WordObj, x: number, y: number, dir: number): boolean {\r\n      for (let i = 0; i < word.char.length; i++) {\r\n        const xi = dir === 0 ? x + i : x;\r\n        const yi = dir === 1 ? y + i : y;\r\n\r\n        if (xi < 0 || xi >= boardSize || yi < 0 || yi >= boardSize) return false;\r\n        if (board[xi][yi] && board[xi][yi] !== word.char[i]) return false;\r\n      }\r\n      return true;\r\n    }\r\n\r\n    function placeWord(word: WordObj, x: number, y: number, dir: number) {\r\n      for (let i = 0; i < word.char.length; i++) {\r\n        const xi = dir === 0 ? x + i : x;\r\n        const yi = dir === 1 ? y + i : y;\r\n        board[xi][yi] = word.char[i];\r\n      }\r\n      word.x = x;\r\n      word.y = y;\r\n      word.dir = dir;\r\n      placedWords.push(word);\r\n    }\r\n\r\n    function addWordToBoard(): boolean {\r\n      if (placedWords.length === 0) {\r\n        // Place the word with fewest totalMatches in center\r\n        let idx = 0;\r\n        for (let i = 1; i < wordObjs.length; i++) {\r\n          if (wordObjs[i].totalMatches < wordObjs[idx].totalMatches) idx = i;\r\n        }\r\n        const word = wordObjs.splice(idx, 1)[0];\r\n        placeWord(word, Math.floor(boardSize / 2), Math.floor(boardSize / 2), 0);\r\n        return true;\r\n      }\r\n\r\n      let selectedIdx = -1;\r\n      let minDiff = Infinity;\r\n\r\n      for (let i = 0; i < wordObjs.length; i++) {\r\n        const word = wordObjs[i];\r\n        word.effectiveMatches = 0;\r\n        word.successfulMatches = [];\r\n\r\n        for (const j of shuffleArray([...Array(word.char.length).keys()])) {\r\n          const curChar = word.char[j];\r\n          for (const existing of placedWords) {\r\n            for (const l of shuffleArray([...Array(existing.char.length).keys()])) {\r\n              const testChar = existing.char[l];\r\n              if (curChar === testChar) {\r\n                word.effectiveMatches++;\r\n\r\n                const cross = { x: existing.x, y: existing.y, dir: 0 };\r\n                if (existing.dir === 0) {\r\n                  cross.dir = 1;\r\n                  cross.x += l;\r\n                  cross.y -= j;\r\n                } else {\r\n                  cross.dir = 0;\r\n                  cross.y += l;\r\n                  cross.x -= j;\r\n                }\r\n\r\n                if (canPlaceWord(word, cross.x, cross.y, cross.dir)) {\r\n                  word.successfulMatches.push(cross);\r\n                }\r\n              }\r\n            }\r\n          }\r\n        }\r\n\r\n        const diff = word.totalMatches - word.effectiveMatches;\r\n        if (diff < minDiff && word.successfulMatches.length > 0) {\r\n          minDiff = diff;\r\n          selectedIdx = i;\r\n        }\r\n      }\r\n\r\n      if (selectedIdx === -1) return false;\r\n\r\n      const selectedWord = wordObjs.splice(selectedIdx, 1)[0];\r\n      const shuffledMatches = shuffleArray(selectedWord.successfulMatches);\r\n      const chosen = shuffledMatches[0];\r\n      placeWord(selectedWord, chosen.x, chosen.y, chosen.dir);\r\n      return true;\r\n    }\r\n\r\n    while (wordObjs.length > 0 && addWordToBoard());\r\n\r\n    return placedWords.map(w => ({\r\n      word: w.string.trim().substring(w.string.indexOf(w.char[1])),\r\n      x: w.x,\r\n      y: w.y,\r\n      direction: w.dir === 0 ? 'horizontal' : 'vertical'\r\n    }));\r\n  }\r\n\r\n\r\n  // Example usage:\r\n  const result = generateCrossword([\r\n    'GIÓ',\r\n    'HẠT GIỐNG',\r\n    'DREAM',\r\n    'THUỐC',\r\n    'CÚC',\r\n    'CHÂU KIỆT LUÂN',\r\n  ]);\r\n  console.log(result);\r\n  // Initialize board\r\n  const board: (string | null)[][] = Array.from({ length: boardSize }, () =>\r\n    Array(boardSize).fill(null)\r\n  );\r\n\r\n  // Place words\r\n  for (const { word, x, y, direction } of placedWords) {\r\n    for (let i = 0; i < word.length; i++) {\r\n      const char = word[i];\r\n      const dx = direction === \"horizontal\" ? i : 0;\r\n      const dy = direction === \"vertical\" ? i : 0;\r\n      const row = y + dy;\r\n      const col = x + dx;\r\n      if (row >= 0 && row < boardSize && col >= 0 && col < boardSize) {\r\n        board[row][col] = char;\r\n      }\r\n    }\r\n  }\r\n\r\n  return (\r\n    <div\r\n      className=\"grid bg-gray-500\"\r\n      style={{\r\n        gridTemplateColumns: `repeat(${boardSize}, 1.75rem)`,\r\n        gridAutoRows: \"1.75rem\",\r\n      }}\r\n    >\r\n      {board.flatMap((row, rowIndex) =>\r\n        row.map((char, colIndex) => (\r\n          <div\r\n            key={`${rowIndex}-${colIndex}`}\r\n            className={`w-7 h-7 text-sm flex items-center justify-center font-bold border border-gray-300 ${\r\n              char ? \"bg-yellow-100 text-black\" : \"bg-white\"\r\n            }`}\r\n          >\r\n            {char}\r\n          </div>\r\n        ))\r\n      )}\r\n    </div>\r\n  );\r\n};\r\n\r\nexport default CrosswordGrid;\r\n\r\n\r\n// Main React Component\r\nconst WordBoard: React.FC = () => {\r\n  // TypeScript version of the crossword builder with shuffled letter matches\r\n\r\n  \r\n\r\n  return (\r\n    <>\r\n    </>\r\n  );\r\n};\r\n\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}