{"ast":null,"code":"// T·∫°o t·ª´ kh√≥a g·ª£i √Ω v·ªõi v·ªã tr√≠ v√† h∆∞·ªõng random\n\nexport const findCommonLetterIndexes = (word1, word2) => {\n  const result = [];\n  for (let i = 0; i < word1.length; i++) {\n    for (let j = 0; j < word2.length; j++) {\n      if (word1[i] === word2[j]) {\n        result.push({\n          word1: i,\n          word2: j\n        });\n      }\n    }\n  }\n  return result;\n};\nexport const findCommonLetterPairs = (wordList, gridSize) => {\n  let found = false;\n  let pairs = 0;\n  const tempWordList = [...wordList];\n  const commonPairs = [];\n  while (pairs < 2 && !found) {\n    for (let i = 0; i < tempWordList.length; i++) {\n      const word1 = tempWordList[i];\n      for (let j = 0; j < tempWordList.length; j++) {\n        if (tempWordList[j] === word1) continue;\n        const result = findCommonLetterIndexes(word1, tempWordList[j]);\n        if (result.length > 0) {\n          commonPairs.push(result[0]);\n          pairs++;\n        }\n        if (i == tempWordList.length - 1 && j == tempWordList.length - 1) {\n          found = true;\n        }\n      }\n    }\n  }\n};\nexport const generateHintWords = (words, gridSize, obstacleWord) => {\n  const grid = Array(gridSize).fill(null).map(() => Array(gridSize).fill(\"\")); // M·∫£ng ki·ªÉm tra v·ªã tr√≠\n\n  const findCommonLetterPairs = words => {\n    let results = [];\n    let usedWords = new Set(); // L∆∞u l·∫°i c√°c t·ª´ ƒë√£ d√πng\n\n    let remainingPairs = [];\n    for (let i = 0; i < words.length; i++) {\n      for (let j = i + 1; j < words.length; j++) {\n        const word1 = words[i];\n        const word2 = words[j];\n\n        // T√¨m k√Ω t·ª± chung gi·ªØa 2 t·ª´\n        const commonLetters = [...new Set(word1)].filter(letter => word2.includes(letter));\n        if (commonLetters.length >= 2) {\n          // T√≠nh ƒëi·ªÉm ∆∞u ti√™n (ch·ªØ g·∫ßn trung t√¢m h∆°n)\n          const scoredLetters = commonLetters.map(letter => {\n            const index1 = word1.indexOf(letter);\n            const index2 = word2.indexOf(letter);\n            const center1 = word1.length / 2;\n            const center2 = word2.length / 2;\n            const score = Math.abs(index1 - center1) + Math.abs(index2 - center2);\n            return {\n              letter,\n              score\n            };\n          });\n\n          // S·∫Øp x·∫øp theo ƒëi·ªÉm ∆∞u ti√™n\n          scoredLetters.sort((a, b) => a.score - b.score);\n          const prioritizedLetters = scoredLetters.map(item => item.letter);\n          remainingPairs.push({\n            word1,\n            word2,\n            commonLetters: prioritizedLetters\n          });\n        }\n      }\n    }\n\n    // B∆∞·ªõc 2: Ch·ªçn t·ªëi ƒëa 2 c·∫∑p theo quy t·∫Øc\n    for (const pair of remainingPairs) {\n      if (results.length >= 2) break; // ƒê·ªß 2 c·∫∑p th√¨ d·ª´ng\n      if (!usedWords.has(pair.word1) && !usedWords.has(pair.word2)) {\n        results.push(pair);\n        usedWords.add(pair.word1);\n        usedWords.add(pair.word2);\n      }\n    }\n\n    // N·∫øu v·∫´n ch∆∞a ƒë·ªß 2 c·∫∑p, ch·ªçn ti·∫øp t·ª´ c√°c c·∫∑p c√≥ t·ª´ ƒë√£ d√πng\n    for (const pair of remainingPairs) {\n      if (results.length >= 2) break;\n      if (!usedWords.has(pair.word1) || !usedWords.has(pair.word2)) {\n        results.push(pair);\n        usedWords.add(pair.word1);\n        usedWords.add(pair.word2);\n      }\n    }\n    return results;\n  };\n\n  // üõ† Test\n  //const testwords = [\"B∆ØUCH√çNH\", \"5G\", \"BQP\", \"T·∫¨PƒêO√ÄN\", \"H√ÄN·ªòI\", \"RED\"];\n\n  const shuffledWords = [...words].sort(() => Math.random() - 0.5);\n  const placeWordsOnGrid = (words, gridSize) => {\n    while (true) {\n      let placedWords = [];\n      let occupiedPositions = new Set();\n      let placedSet = new Set(); // Set ƒë·ªÉ theo d√µi t·ª´ ƒë√£ ƒë·∫∑t\n      let allPlaced = true; // C·ªù ki·ªÉm tra xem t·∫•t c·∫£ t·ª´ c√≥ ƒë∆∞·ª£c ƒë·∫∑t hay kh√¥ng\n\n      const getKey = (x, y) => `${x},${y}`;\n      const canPlaceWord = (word, x, y, direction, index) => {\n        for (let i = 0; i < word.length; i++) {\n          if (i === x + index) continue;\n          let newX = direction === \"horizontal\" ? x + i : x;\n          let newY = direction === \"horizontal\" ? y : y + i;\n          if (newX < 0 || newY < 0 || newX >= gridSize || newY >= gridSize || occupiedPositions.has(getKey(newX, newY))) {\n            return false;\n          }\n        }\n        return true;\n      };\n      const commonLetterPairs = findCommonLetterPairs(words);\n      console.log(commonLetterPairs);\n      for (const {\n        word1,\n        word2,\n        commonLetters\n      } of commonLetterPairs) {\n        if (placedSet.has(word1) || placedSet.has(word2)) continue; // Ki·ªÉm tra n·∫øu ƒë√£ ƒë·∫∑t th√¨ b·ªè qua\n\n        const commonLetter = commonLetters[0];\n        const index1 = word1.indexOf(commonLetter);\n        const index2 = word2.indexOf(commonLetter);\n        let placed = false;\n        for (let attempt = 0; attempt < 100; attempt++) {\n          let x = Math.floor(Math.random() * (gridSize - word1.length)) + 1;\n          let y = Math.floor(Math.random() * (gridSize - index2) + index2) + 1;\n          if (canPlaceWord(word1, x, y, \"horizontal\", index1)) {\n            placedWords.push({\n              word: word1,\n              x,\n              y,\n              direction: \"horizontal\"\n            });\n            placedSet.add(word1);\n            let intersecrX = x + index1;\n            let intersectY = y;\n            if (canPlaceWord(word2, intersecrX, intersectY - index2, \"vertical\", index2)) {\n              for (let i = 0; i < word1.length; i++) occupiedPositions.add(getKey(x + i, y));\n              placedWords.push({\n                word: word2,\n                x: intersecrX,\n                y: intersectY - index2,\n                direction: \"vertical\"\n              });\n              placedSet.add(word2);\n              for (let i = 0; i < word2.length; i++) occupiedPositions.add(getKey(intersecrX, intersectY - index2 + i));\n              placed = true;\n              break;\n            } else {\n              placedWords.pop();\n            }\n          }\n        }\n        if (!placed) {\n          console.warn(`Kh√¥ng th·ªÉ ƒë·∫∑t c·∫∑p t·ª´: ${word1} - ${word2}`);\n          allPlaced = false;\n          break;\n        }\n      }\n      for (const word of words) {\n        if (placedSet.has(word)) continue;\n        let placed = false;\n        let found = false;\n        for (let j = placedWords.length - 1; j >= 0; j--) {\n          for (let attempt = 0; attempt < 10; attempt++) {\n            let direction = placedWords[j].direction === \"horizontal\" ? \"vertical\" : \"horizontal\";\n            const shift = Math.random() < 0.5 ? 1 : -1;\n            let x = placedWords[j].direction === \"horizontal\" ? placedWords[j].word.length + placedWords[j].x : placedWords[j].x + 1;\n            let y = placedWords[j].direction === \"horizontal\" ? placedWords[j].y + 2 : placedWords[j].word.length + placedWords[j].y;\n            if (canPlaceWord(word, x, y, direction, 0)) {\n              placedWords.push({\n                word,\n                x,\n                y,\n                direction\n              });\n              placedSet.add(word);\n              for (let i = 0; i < word.length; i++) {\n                let newX = direction === \"horizontal\" ? x + i : x;\n                let newY = direction === \"horizontal\" ? y : y + i;\n                occupiedPositions.add(getKey(newX, newY));\n              }\n              placed = true;\n              found = true;\n              break;\n            }\n          }\n          if (found) break;\n        }\n        if (!placed) {\n          console.warn(`Kh√¥ng th·ªÉ ƒë·∫∑t t·ª´: ${word}`);\n          allPlaced = false;\n          break;\n        }\n      }\n      if (!allPlaced) continue; // N·∫øu c√≥ t·ª´ kh√¥ng ƒë·∫∑t ƒë∆∞·ª£c, restart v√≤ng l·∫∑p\n\n      if (allPlaced) return placedWords; // N·∫øu t·∫•t c·∫£ t·ª´ ƒë·ªÅu ƒë∆∞·ª£c ƒë·∫∑t, tho√°t kh·ªèi v√≤ng l·∫∑p v√† tr·∫£ v·ªÅ k·∫øt qu·∫£\n    }\n  };\n  const placedWords = placeWordsOnGrid(shuffledWords, gridSize);\n  console.log(placedWords);\n  return placedWords;\n};\nexport const renderGrid = (wordList, mainKeyword, GRID_SIZE) => {\n  console.log(\"wordList on render\", wordList);\n  const maxAttempts = 100;\n  const generateEmptyGrid = () => {\n    return Array(GRID_SIZE).fill(null).map(() => Array(GRID_SIZE).fill(\"\"));\n  };\n  const getKey = (x, y) => `${x},${y}`;\n  const canPlaceNumber = (x, y) => {\n    if (x < 0 || y < 0 || x >= GRID_SIZE || y >= GRID_SIZE) return false;\n    return !occupiedPositions.has(getKey(x, y));\n  };\n  const hasCommonLetter = (word1, word2) => {\n    return [...new Set(word1)].some(letter => word2.includes(letter));\n  };\n\n  // Try to place words and numbers until a valid configuration is found\n  let attempts = 0;\n  let randomHintWords = [];\n  let newGrid = generateEmptyGrid();\n  let occupiedPositions = new Set();\n  let occupiedRows = new Set();\n  let occupiedCols = new Set();\n  while (attempts < maxAttempts) {\n    randomHintWords = generateHintWords(wordList, GRID_SIZE, mainKeyword);\n    newGrid = generateEmptyGrid();\n    occupiedPositions.clear();\n    occupiedRows.clear();\n    occupiedCols.clear();\n    let canPlaceAll = true;\n\n    // First pass: Place words and mark their positions\n    for (const {\n      word,\n      x,\n      y,\n      direction\n    } of randomHintWords) {\n      if (direction === \"horizontal\") {\n        occupiedRows.add(y);\n        // Check for adjacent rows\n        for (const other of randomHintWords) {\n          if (other.word === word || other.direction !== \"horizontal\") continue; // Fixed comparison\n          if (Math.abs(other.y - y) === 1 && !hasCommonLetter(word, other.word)) {\n            canPlaceAll = false;\n            break;\n          }\n        }\n      } else {\n        occupiedCols.add(x);\n        // Check for adjacent columns\n        for (const other of randomHintWords) {\n          if (other.word === word || other.direction !== \"vertical\") continue; // Fixed comparison\n          if (Math.abs(other.x - x) === 1 && !hasCommonLetter(word, other.word)) {\n            canPlaceAll = false;\n            break;\n          }\n        }\n      }\n      if (!canPlaceAll) break;\n      for (let i = 0; i < word.length; i++) {\n        let newX = direction === \"horizontal\" ? x + i : x;\n        let newY = direction === \"horizontal\" ? y : y + i;\n        newGrid[newY][newX] = word[i];\n        occupiedPositions.add(getKey(newX, newY));\n      }\n    }\n    if (!canPlaceAll) {\n      attempts++;\n      continue;\n    }\n\n    // Second pass: Check if numbers can be placed without overlap\n\n    for (const {\n      word,\n      x,\n      y,\n      direction\n    } of randomHintWords) {\n      const wordNumber = wordList.includes(word) ? wordList.indexOf(word) + 1 : -1; // Ki·ªÉm tra tr∆∞·ªõc khi l·∫•y s·ªë\n\n      if (wordNumber === -1) {\n        console.error(`Kh√¥ng t√¨m th·∫•y t·ª´ ${word} trong wordList`);\n        continue; // N·∫øu kh√¥ng t√¨m th·∫•y, ti·∫øp t·ª•c v√≤ng l·∫∑p\n      }\n      if (direction === \"horizontal\" && x > 0) {\n        if (!canPlaceNumber(x - 1, y)) {\n          canPlaceAll = false;\n          break;\n        }\n      } else if (direction === \"vertical\" && y > 0) {\n        if (!canPlaceNumber(x, y - 1)) {\n          canPlaceAll = false;\n          break;\n        }\n      }\n    }\n    if (canPlaceAll) {\n      // Place numbers if all checks pass\n      randomHintWords.forEach(({\n        word,\n        x,\n        y,\n        direction\n      }) => {\n        const wordNumber = wordList.indexOf(word) + 1;\n        console.log(\"wordList\", wordList);\n        console.log(\"word\", word);\n        console.log(\"wordNumber\", wordNumber);\n        let newY = y; // T·∫°o bi·∫øn m·ªõi ƒë·ªÉ l∆∞u tr·ªØ v·ªã tr√≠ x ƒë√£ ƒëi·ªÅu ch·ªânh\n\n        // Ki·ªÉm tra n·∫øu √¥ b√™n tr√°i ƒë√£ b·ªã chi·∫øm, th√¨ d·ªãch sang ph·∫£i\n        if (newGrid[x][y - 1] !== '') {\n          newY = y + 1; // D·ªãch sang ph·∫£i 1 ƒë∆°n v·ªã\n\n          // N·∫øu l√† horizontal, c·∫ßn ki·ªÉm tra to√†n b·ªô c√°c √¥ c·ªßa word v√† d·ªãch ch√∫ng\n          if (direction === \"horizontal\") {\n            // Ki·ªÉm tra xem sau khi d·ªãch c√≥ ƒë·ªß kh√¥ng gian kh√¥ng\n            if (newY + word.length > newGrid[0].length) {\n              // C√≥ th·ªÉ c·∫ßn x·ª≠ l√Ω tr∆∞·ªùng h·ª£p v∆∞·ª£t qu√° k√≠ch th∆∞·ªõc grid\n              console.error(\"Kh√¥ng d·ªãch ƒë∆∞·ª£c sang ph·∫£i\");\n              return;\n            }\n            // C·∫≠p nh·∫≠t c√°c √¥ c·ªßa word ·ªü v·ªã tr√≠ m·ªõi\n            for (let i = 0; i < word.length; i++) {\n              newGrid[x][newY + i] = word[i];\n              occupiedPositions.add(getKey(x, newY + i));\n            }\n            occupiedPositions.delete(getKey(x, y));\n            newGrid[x][y] = \"\";\n          }\n        }\n        if (direction === \"horizontal\" && x > 0) {\n          newGrid[y][x - 1] = `number${wordNumber.toString()}`;\n          occupiedPositions.add(getKey(x - 1, y));\n        } else if (direction === \"vertical\" && y > 0) {\n          newGrid[y - 1][x] = `number${wordNumber.toString()}`;\n          occupiedPositions.add(getKey(x, y - 1));\n        }\n      });\n      break; // Valid configuration found, exit loop\n    }\n    attempts++;\n  }\n  if (attempts >= maxAttempts) {\n    console.warn(\"Could not find a valid grid configuration without overlapping numbers or adjacent non-shared words after max attempts.\");\n  }\n  return {\n    randomHintWords,\n    newGrid\n  };\n};","map":{"version":3,"names":["findCommonLetterIndexes","word1","word2","result","i","length","j","push","findCommonLetterPairs","wordList","gridSize","found","pairs","tempWordList","commonPairs","generateHintWords","words","obstacleWord","grid","Array","fill","map","results","usedWords","Set","remainingPairs","commonLetters","filter","letter","includes","scoredLetters","index1","indexOf","index2","center1","center2","score","Math","abs","sort","a","b","prioritizedLetters","item","pair","has","add","shuffledWords","random","placeWordsOnGrid","placedWords","occupiedPositions","placedSet","allPlaced","getKey","x","y","canPlaceWord","word","direction","index","newX","newY","commonLetterPairs","console","log","commonLetter","placed","attempt","floor","intersecrX","intersectY","pop","warn","shift","renderGrid","mainKeyword","GRID_SIZE","maxAttempts","generateEmptyGrid","canPlaceNumber","hasCommonLetter","some","attempts","randomHintWords","newGrid","occupiedRows","occupiedCols","clear","canPlaceAll","other","wordNumber","error","forEach","delete","toString"],"sources":["C:/Users/ASUS/Documents/htm_fe/src/layouts/RoundBase/utils.ts"],"sourcesContent":["// T·∫°o t·ª´ kh√≥a g·ª£i √Ω v·ªõi v·ªã tr√≠ v√† h∆∞·ªõng random\r\n\r\ninterface HintWord {\r\n    word: string;\r\n    x: number;\r\n    y: number;\r\n    direction: \"horizontal\" | \"vertical\";\r\n}\r\n\r\ninterface ObstacleQuestionBoxProps {\r\n    obstacleWord: string;\r\n}\r\n\r\ntype PlacedWord = {\r\n    word: string;\r\n    x: number;\r\n    y: number;\r\n    direction: \"horizontal\" | \"vertical\";\r\n};\r\n\r\n\r\nexport const findCommonLetterIndexes = (word1: string, word2: string) => {\r\n    const result = []\r\n    for (let i=0;i<word1.length;i++) {\r\n        for(let j =0;j<word2.length;j++) {\r\n            if(word1[i] === word2[j]) {\r\n                result.push({\r\n                    word1: i,\r\n                    word2: j\r\n                })\r\n            }\r\n        }\r\n    }\r\n\r\n    return result\r\n}\r\n\r\nexport const findCommonLetterPairs = (wordList: string[], gridSize: number) => {\r\n    let found = false\r\n    let pairs = 0\r\n    const tempWordList = [...wordList]\r\n    const commonPairs = []\r\n\r\n\r\n    while (pairs <2 && !found) {\r\n        \r\n        for (let i =0;i<tempWordList.length;i++) {\r\n            const word1 = tempWordList[i]\r\n\r\n            for (let j =0;j<tempWordList.length;j++) {\r\n                if (tempWordList[j] === word1) continue\r\n\r\n                const result = findCommonLetterIndexes(word1,tempWordList[j])\r\n\r\n                if(result.length >0) {\r\n                    commonPairs.push(result[0])\r\n                    pairs++\r\n                }\r\n\r\n                if(i==tempWordList.length-1 && j==tempWordList.length-1) {\r\n                    found = true\r\n                }\r\n            }\r\n            \r\n\r\n            \r\n        }\r\n    }\r\n    \r\n}\r\n\r\nexport const generateHintWords = (words: string[], gridSize: number, obstacleWord: string): HintWord[] => {\r\n    const grid: string[][] = Array(gridSize)\r\n        .fill(null)\r\n        .map(() => Array(gridSize).fill(\"\")); // M·∫£ng ki·ªÉm tra v·ªã tr√≠\r\n\r\n    const findCommonLetterPairs = (words: string[]): { word1: string; word2: string; commonLetters: string[] }[] => {\r\n        let results: { word1: string; word2: string; commonLetters: string[] }[] = [];\r\n        let usedWords = new Set<string>(); // L∆∞u l·∫°i c√°c t·ª´ ƒë√£ d√πng\r\n\r\n        let remainingPairs: { word1: string; word2: string; commonLetters: string[] }[] = [];\r\n\r\n        for (let i = 0; i < words.length; i++) {\r\n            for (let j = i + 1; j < words.length; j++) {\r\n                const word1 = words[i];\r\n                const word2 = words[j];\r\n\r\n                // T√¨m k√Ω t·ª± chung gi·ªØa 2 t·ª´\r\n                const commonLetters = [...new Set(word1)].filter((letter) => word2.includes(letter));\r\n\r\n                if (commonLetters.length >= 2) {\r\n                    // T√≠nh ƒëi·ªÉm ∆∞u ti√™n (ch·ªØ g·∫ßn trung t√¢m h∆°n)\r\n                    const scoredLetters = commonLetters.map((letter) => {\r\n                        const index1 = word1.indexOf(letter);\r\n                        const index2 = word2.indexOf(letter);\r\n                        const center1 = word1.length / 2;\r\n                        const center2 = word2.length / 2;\r\n                        const score = Math.abs(index1 - center1) + Math.abs(index2 - center2);\r\n                        return { letter, score };\r\n                    });\r\n\r\n                    // S·∫Øp x·∫øp theo ƒëi·ªÉm ∆∞u ti√™n\r\n                    scoredLetters.sort((a, b) => a.score - b.score);\r\n                    const prioritizedLetters = scoredLetters.map((item) => item.letter);\r\n\r\n                    remainingPairs.push({ word1, word2, commonLetters: prioritizedLetters });\r\n                }\r\n            }\r\n        }\r\n\r\n        // B∆∞·ªõc 2: Ch·ªçn t·ªëi ƒëa 2 c·∫∑p theo quy t·∫Øc\r\n        for (const pair of remainingPairs) {\r\n            if (results.length >= 2) break; // ƒê·ªß 2 c·∫∑p th√¨ d·ª´ng\r\n            if (!usedWords.has(pair.word1) && !usedWords.has(pair.word2)) {\r\n                results.push(pair);\r\n                usedWords.add(pair.word1);\r\n                usedWords.add(pair.word2);\r\n            }\r\n        }\r\n\r\n        // N·∫øu v·∫´n ch∆∞a ƒë·ªß 2 c·∫∑p, ch·ªçn ti·∫øp t·ª´ c√°c c·∫∑p c√≥ t·ª´ ƒë√£ d√πng\r\n        for (const pair of remainingPairs) {\r\n            if (results.length >= 2) break;\r\n            if (!usedWords.has(pair.word1) || !usedWords.has(pair.word2)) {\r\n                results.push(pair);\r\n                usedWords.add(pair.word1);\r\n                usedWords.add(pair.word2);\r\n            }\r\n        }\r\n\r\n        return results;\r\n    };\r\n\r\n    // üõ† Test\r\n    //const testwords = [\"B∆ØUCH√çNH\", \"5G\", \"BQP\", \"T·∫¨PƒêO√ÄN\", \"H√ÄN·ªòI\", \"RED\"];\r\n\r\n    const shuffledWords = [...words].sort(() => Math.random() - 0.5);\r\n    const placeWordsOnGrid = (words: string[], gridSize: number): PlacedWord[] => {\r\n        while (true) {\r\n            let placedWords: PlacedWord[] = [];\r\n            let occupiedPositions = new Set<string>();\r\n            let placedSet = new Set<string>(); // Set ƒë·ªÉ theo d√µi t·ª´ ƒë√£ ƒë·∫∑t\r\n            let allPlaced = true; // C·ªù ki·ªÉm tra xem t·∫•t c·∫£ t·ª´ c√≥ ƒë∆∞·ª£c ƒë·∫∑t hay kh√¥ng\r\n\r\n            const getKey = (x: number, y: number) => `${x},${y}`;\r\n\r\n            const canPlaceWord = (word: string, x: number, y: number, direction: \"horizontal\" | \"vertical\", index: number) => {\r\n                for (let i = 0; i < word.length; i++) {\r\n                    if (i === x + index) continue;\r\n                    let newX = direction === \"horizontal\" ? x + i : x;\r\n                    let newY = direction === \"horizontal\" ? y : y + i;\r\n                    if (newX < 0 || newY < 0 || newX >= gridSize || newY >= gridSize || occupiedPositions.has(getKey(newX, newY))) {\r\n                        return false;\r\n                    }\r\n                }\r\n                return true;\r\n            };\r\n\r\n            const commonLetterPairs = findCommonLetterPairs(words);\r\n            console.log(commonLetterPairs);\r\n\r\n            for (const { word1, word2, commonLetters } of commonLetterPairs) {\r\n                if (placedSet.has(word1) || placedSet.has(word2)) continue; // Ki·ªÉm tra n·∫øu ƒë√£ ƒë·∫∑t th√¨ b·ªè qua\r\n\r\n                const commonLetter = commonLetters[0];\r\n                const index1 = word1.indexOf(commonLetter);\r\n                const index2 = word2.indexOf(commonLetter);\r\n\r\n                let placed = false;\r\n                for (let attempt = 0; attempt < 100; attempt++) {\r\n                    let x = Math.floor(Math.random() * (gridSize - word1.length)) + 1;\r\n                    let y = Math.floor(Math.random() * (gridSize - index2) + index2) + 1;\r\n\r\n                    if (canPlaceWord(word1, x, y, \"horizontal\", index1)) {\r\n                        placedWords.push({ word: word1, x, y, direction: \"horizontal\" });\r\n                        placedSet.add(word1);\r\n\r\n                        let intersecrX = x + index1;\r\n                        let intersectY = y;\r\n\r\n                        if (canPlaceWord(word2, intersecrX, intersectY - index2, \"vertical\", index2)) {\r\n                            for (let i = 0; i < word1.length; i++) occupiedPositions.add(getKey(x + i, y));\r\n                            placedWords.push({ word: word2, x: intersecrX, y: intersectY - index2, direction: \"vertical\" });\r\n                            placedSet.add(word2);\r\n\r\n                            for (let i = 0; i < word2.length; i++) occupiedPositions.add(getKey(intersecrX, intersectY - index2 + i));\r\n\r\n                            placed = true;\r\n                            break;\r\n                        } else {\r\n                            placedWords.pop();\r\n                        }\r\n                    }\r\n                }\r\n\r\n                if (!placed) {\r\n                    console.warn(`Kh√¥ng th·ªÉ ƒë·∫∑t c·∫∑p t·ª´: ${word1} - ${word2}`);\r\n                    allPlaced = false;\r\n                    break;\r\n                }\r\n            }\r\n\r\n\r\n\r\n            for (const word of words) {\r\n                if (placedSet.has(word)) continue;\r\n\r\n                let placed = false;\r\n                let found = false;\r\n\r\n                for (let j = placedWords.length - 1; j >= 0; j--) {\r\n                    for (let attempt = 0; attempt < 10; attempt++) {\r\n                        let direction: \"horizontal\" | \"vertical\" = placedWords[j].direction === \"horizontal\" ? \"vertical\" : \"horizontal\";\r\n                        const shift = Math.random() < 0.5 ? 1 : -1;\r\n                        let x = placedWords[j].direction === \"horizontal\" ? placedWords[j].word.length + placedWords[j].x : placedWords[j].x + 1;\r\n                        let y = placedWords[j].direction === \"horizontal\" ? placedWords[j].y + 2 : placedWords[j].word.length + placedWords[j].y;\r\n\r\n                        if (canPlaceWord(word, x, y, direction, 0)) {\r\n                            placedWords.push({ word, x, y, direction });\r\n                            placedSet.add(word);\r\n\r\n                            for (let i = 0; i < word.length; i++) {\r\n                                let newX = direction === \"horizontal\" ? x + i : x;\r\n                                let newY = direction === \"horizontal\" ? y : y + i;\r\n                                occupiedPositions.add(getKey(newX, newY));\r\n                            }\r\n\r\n                            placed = true;\r\n                            found = true;\r\n                            break;\r\n                        }\r\n                    }\r\n\r\n                    if (found) break;\r\n                }\r\n\r\n                if (!placed) {\r\n                    console.warn(`Kh√¥ng th·ªÉ ƒë·∫∑t t·ª´: ${word}`);\r\n                    allPlaced = false;\r\n                    break;\r\n                }\r\n            }\r\n            if (!allPlaced) continue; // N·∫øu c√≥ t·ª´ kh√¥ng ƒë·∫∑t ƒë∆∞·ª£c, restart v√≤ng l·∫∑p\r\n\r\n            if (allPlaced) return placedWords; // N·∫øu t·∫•t c·∫£ t·ª´ ƒë·ªÅu ƒë∆∞·ª£c ƒë·∫∑t, tho√°t kh·ªèi v√≤ng l·∫∑p v√† tr·∫£ v·ªÅ k·∫øt qu·∫£\r\n        }\r\n    };\r\n\r\n    const placedWords = placeWordsOnGrid(shuffledWords, gridSize);\r\n    console.log(placedWords);\r\n\r\n    return placedWords;\r\n};\r\n\r\n\r\nexport const renderGrid = (wordList: string[], mainKeyword:string, GRID_SIZE:number) => {\r\n    console.log(\"wordList on render\", wordList);\r\n    \r\n    const maxAttempts = 100;\r\n\r\n    const generateEmptyGrid = () => {\r\n        return Array(GRID_SIZE).fill(null).map(() => Array(GRID_SIZE).fill(\"\"));\r\n    };\r\n\r\n    const getKey = (x: number, y: number) => `${x},${y}`;\r\n\r\n    const canPlaceNumber = (x: number, y: number) => {\r\n        if (x < 0 || y < 0 || x >= GRID_SIZE || y >= GRID_SIZE) return false;\r\n        return !occupiedPositions.has(getKey(x, y));\r\n    };\r\n\r\n    const hasCommonLetter = (word1: string, word2: string) => {\r\n        return [...new Set(word1)].some((letter) => word2.includes(letter));\r\n    };\r\n\r\n    // Try to place words and numbers until a valid configuration is found\r\n    let attempts = 0;\r\n    let randomHintWords: HintWord[] = [];\r\n    let newGrid = generateEmptyGrid();\r\n    let occupiedPositions = new Set<string>();\r\n    let occupiedRows = new Set<number>();\r\n    let occupiedCols = new Set<number>();\r\n\r\n\r\n    while (attempts < maxAttempts) {\r\n        randomHintWords = generateHintWords(wordList, GRID_SIZE, mainKeyword);\r\n        newGrid = generateEmptyGrid();\r\n        occupiedPositions.clear();\r\n        occupiedRows.clear();\r\n        occupiedCols.clear();\r\n\r\n        let canPlaceAll = true;\r\n\r\n        // First pass: Place words and mark their positions\r\n        for (const { word, x, y, direction } of randomHintWords) {\r\n            if (direction === \"horizontal\") {\r\n                occupiedRows.add(y);\r\n                // Check for adjacent rows\r\n                for (const other of randomHintWords) {\r\n                    if (other.word === word || other.direction !== \"horizontal\") continue; // Fixed comparison\r\n                    if (Math.abs(other.y - y) === 1 && !hasCommonLetter(word, other.word)) {\r\n                        canPlaceAll = false;\r\n                        break;\r\n                    }\r\n                }\r\n            } else {\r\n                occupiedCols.add(x);\r\n                // Check for adjacent columns\r\n                for (const other of randomHintWords) {\r\n                    if (other.word === word || other.direction !== \"vertical\") continue; // Fixed comparison\r\n                    if (Math.abs(other.x - x) === 1 && !hasCommonLetter(word, other.word)) {\r\n                        canPlaceAll = false;\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n\r\n            if (!canPlaceAll) break;\r\n\r\n            for (let i = 0; i < word.length; i++) {\r\n                let newX = direction === \"horizontal\" ? x + i : x;\r\n                let newY = direction === \"horizontal\" ? y : y + i;\r\n                newGrid[newY][newX] = word[i];\r\n                occupiedPositions.add(getKey(newX, newY));\r\n            }\r\n        }\r\n\r\n        if (!canPlaceAll) {\r\n            attempts++;\r\n            continue;\r\n        }\r\n\r\n        // Second pass: Check if numbers can be placed without overlap\r\n\r\n        for (const { word, x, y, direction } of randomHintWords) {\r\n            const wordNumber = wordList.includes(word) ? wordList.indexOf(word) + 1 : -1; // Ki·ªÉm tra tr∆∞·ªõc khi l·∫•y s·ªë\r\n\r\n            if (wordNumber === -1) {\r\n                console.error(`Kh√¥ng t√¨m th·∫•y t·ª´ ${word} trong wordList`);\r\n                continue; // N·∫øu kh√¥ng t√¨m th·∫•y, ti·∫øp t·ª•c v√≤ng l·∫∑p\r\n            }\r\n\r\n            if (direction === \"horizontal\" && x > 0) {\r\n                if (!canPlaceNumber(x - 1, y)) {\r\n                    canPlaceAll = false;\r\n                    break;\r\n                }\r\n            } else if (direction === \"vertical\" && y > 0) {\r\n                if (!canPlaceNumber(x, y - 1)) {\r\n                    canPlaceAll = false;\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n\r\n\r\n        if (canPlaceAll) {\r\n            // Place numbers if all checks pass\r\n            randomHintWords.forEach(({ word, x, y, direction }) => {\r\n                const wordNumber = wordList.indexOf(word) + 1;\r\n                console.log(\"wordList\",wordList)\r\n                console.log(\"word\",word);\r\n                \r\n                console.log(\"wordNumber\",wordNumber)\r\n                let newY = y; // T·∫°o bi·∫øn m·ªõi ƒë·ªÉ l∆∞u tr·ªØ v·ªã tr√≠ x ƒë√£ ƒëi·ªÅu ch·ªânh\r\n\r\n                // Ki·ªÉm tra n·∫øu √¥ b√™n tr√°i ƒë√£ b·ªã chi·∫øm, th√¨ d·ªãch sang ph·∫£i\r\n                if (newGrid[x][y-1] !== '') {\r\n                    newY = y + 1; // D·ªãch sang ph·∫£i 1 ƒë∆°n v·ªã\r\n                    \r\n                    // N·∫øu l√† horizontal, c·∫ßn ki·ªÉm tra to√†n b·ªô c√°c √¥ c·ªßa word v√† d·ªãch ch√∫ng\r\n                    if (direction === \"horizontal\") {\r\n                        // Ki·ªÉm tra xem sau khi d·ªãch c√≥ ƒë·ªß kh√¥ng gian kh√¥ng\r\n                        if (newY + word.length > newGrid[0].length) {\r\n                            // C√≥ th·ªÉ c·∫ßn x·ª≠ l√Ω tr∆∞·ªùng h·ª£p v∆∞·ª£t qu√° k√≠ch th∆∞·ªõc grid\r\n                            console.error(\"Kh√¥ng d·ªãch ƒë∆∞·ª£c sang ph·∫£i\")\r\n                            return;\r\n                        }\r\n                        // C·∫≠p nh·∫≠t c√°c √¥ c·ªßa word ·ªü v·ªã tr√≠ m·ªõi\r\n                        for (let i = 0; i < word.length; i++) {\r\n                            newGrid[x][newY+i] = word[i];\r\n                            occupiedPositions.add(getKey(x, newY+i));\r\n                        }\r\n\r\n                        occupiedPositions.delete(getKey(x,y))\r\n                        newGrid[x][y] = \"\"\r\n                    }\r\n                }\r\n                if (direction === \"horizontal\" && x > 0) {\r\n                    newGrid[y][x - 1] = `number${wordNumber.toString()}`;\r\n                    occupiedPositions.add(getKey(x - 1, y));\r\n                } else if (direction === \"vertical\" && y > 0) {\r\n                    newGrid[y - 1][x] = `number${wordNumber.toString()}`;\r\n                    occupiedPositions.add(getKey(x, y - 1));\r\n                }\r\n            });\r\n\r\n\r\n            break; // Valid configuration found, exit loop\r\n        }\r\n\r\n        attempts++;\r\n    }\r\n\r\n    if (attempts >= maxAttempts) {\r\n        console.warn(\"Could not find a valid grid configuration without overlapping numbers or adjacent non-shared words after max attempts.\");\r\n    }\r\n\r\n    return {randomHintWords, newGrid}\r\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}