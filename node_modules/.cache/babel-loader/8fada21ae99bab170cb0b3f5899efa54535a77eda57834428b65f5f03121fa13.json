{"ast":null,"code":"import React from \"react\";\n\n// Define word object structure\n\n// Main React Component\nimport { Fragment as _Fragment, jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst WordBoard = () => {\n  const BOARD_SIZE = 50;\n  const CENTER = Math.floor(BOARD_SIZE / 2);\n  let board = Array.from({\n    length: BOARD_SIZE\n  }, () => Array(BOARD_SIZE).fill(null));\n  let isPos = Array.from({\n    length: BOARD_SIZE\n  }, () => Array(BOARD_SIZE).fill(false));\n  let classesOfBoard = Array.from({\n    length: BOARD_SIZE\n  }, () => Array.from({\n    length: BOARD_SIZE\n  }, () => []));\n  const Bounds = {\n    top: CENTER,\n    bottom: CENTER,\n    left: CENTER,\n    right: CENTER,\n    Update(x, y) {\n      this.top = Math.min(this.top, y);\n      this.bottom = Math.max(this.bottom, y);\n      this.left = Math.min(this.left, x);\n      this.right = Math.max(this.right, x);\n    }\n  };\n  let wordBank = [];\n  let wordsActive = [];\n  let wordArr = [];\n  function createWordObj(word) {\n    return {\n      string: ` ${word} `,\n      char: ` ${word} `.split(''),\n      totalMatches: 0,\n      effectiveMatches: 0,\n      successfulMatches: [],\n      x: 0,\n      y: 0,\n      dir: 0\n    };\n  }\n  function prepareBoard(words) {\n    wordArr = words;\n    wordBank = wordArr.map(w => createWordObj(w));\n    for (let i = 0; i < wordBank.length; i++) {\n      const wA = wordBank[i];\n      for (let j = 0; j < wA.char.length; j++) {\n        const cA = wA.char[j];\n        for (let k = 0; k < wordBank.length; k++) {\n          if (k === i) continue;\n          const wB = wordBank[k];\n          for (let l = 0; l < wB.char.length; l++) {\n            wA.totalMatches += cA === wB.char[l] ? 1 : 0;\n          }\n        }\n      }\n    }\n  }\n  function findWordIdx(givenWord) {\n    givenWord = givenWord.trim();\n    return wordArr.findIndex(w => w === givenWord);\n  }\n  function addWordToBoard() {\n    let curIndex = -1;\n    let minMatchDiff = 9999;\n    if (wordsActive.length < 1) {\n      curIndex = wordBank.reduce((minIdx, word, i) => word.totalMatches < wordBank[minIdx].totalMatches ? i : minIdx, 0);\n      wordBank[curIndex].successfulMatches = [{\n        x: CENTER,\n        y: CENTER,\n        dir: 0\n      }];\n    } else {\n      for (let i = 0; i < wordBank.length; i++) {\n        const curWord = wordBank[i];\n        curWord.effectiveMatches = 0;\n        curWord.successfulMatches = [];\n        for (let j = 0; j < curWord.char.length; j++) {\n          if (j === 1) continue;\n          const curChar = curWord.char[j];\n          for (const testWord of wordsActive) {\n            for (let l = 0; l < testWord.char.length; l++) {\n              if (l === 1) continue;\n              const testChar = testWord.char[l];\n              if (curChar === testChar) {\n                curWord.effectiveMatches++;\n                const curCross = {\n                  x: testWord.x,\n                  y: testWord.y,\n                  dir: testWord.dir === 0 ? 1 : 0\n                };\n                if (testWord.dir === 0) {\n                  curCross.x += l;\n                  curCross.y -= j;\n                } else {\n                  curCross.y += l;\n                  curCross.x -= j;\n                }\n                let isMatch = true;\n                for (let m = -1; m <= curWord.char.length; m++) {\n                  if (m === j) continue;\n                  if (curCross.dir === 0) {\n                    const x = curCross.x + m;\n                    if (x < 0 || x >= BOARD_SIZE) {\n                      isMatch = false;\n                      break;\n                    }\n                    const y = curCross.y;\n                    const around = [y, y + 1, y - 1].map(yy => {\n                      var _board$x$yy;\n                      return (_board$x$yy = board[x][yy]) !== null && _board$x$yy !== void 0 ? _board$x$yy : null;\n                    });\n                    if (m >= 0 && m < curWord.char.length && around[0] !== null && around[0] !== curWord.char[m]) {\n                      isMatch = false;\n                      break;\n                    } else if ((m === -1 || m === curWord.char.length) && around[0] !== null) {\n                      isMatch = false;\n                      break;\n                    }\n                  } else {\n                    const y = curCross.y + m;\n                    if (y < 0 || y >= BOARD_SIZE) {\n                      isMatch = false;\n                      break;\n                    }\n                    const x = curCross.x;\n                    const around = [x, x + 1, x - 1].map(xx => {\n                      var _board$xx$y;\n                      return (_board$xx$y = board[xx][y]) !== null && _board$xx$y !== void 0 ? _board$xx$y : null;\n                    });\n                    if (m >= 0 && m < curWord.char.length && around[0] !== null && around[0] !== curWord.char[m]) {\n                      isMatch = false;\n                      break;\n                    } else if ((m === -1 || m === curWord.char.length) && around[0] !== null) {\n                      isMatch = false;\n                      break;\n                    }\n                  }\n                }\n                if (isMatch) curWord.successfulMatches.push(curCross);\n              }\n            }\n          }\n        }\n        const curMatchDiff = curWord.totalMatches - curWord.effectiveMatches;\n        if (curMatchDiff <= minMatchDiff && curWord.successfulMatches.length > 0) {\n          minMatchDiff = curMatchDiff;\n          curIndex = i;\n        }\n      }\n      if (curIndex === -1) return false;\n    }\n    const placedWord = wordBank.splice(curIndex, 1)[0];\n    const matchArr = placedWord.successfulMatches;\n    const match = matchArr[Math.floor(Math.random() * matchArr.length)];\n    placedWord.x = match.x;\n    placedWord.y = match.y;\n    placedWord.dir = match.dir;\n    for (let i = 0; i < placedWord.char.length; i++) {\n      const x = match.dir === 0 ? match.x + i : match.x;\n      const y = match.dir === 1 ? match.y + i : match.y;\n      board[x][y] = placedWord.char[i];\n      isPos[x][y] = i === 1;\n      const idx = findWordIdx(placedWord.string.trim());\n      classesOfBoard[x][y].push(idx + 1);\n      Bounds.Update(x, y);\n    }\n    wordsActive.push(placedWord);\n    return true;\n  }\n  function populate(words) {\n    prepareBoard(words);\n    while (wordBank.length > 0) {\n      const success = addWordToBoard();\n      if (!success) break;\n    }\n    return wordsActive.map(wordObj => ({\n      word: wordObj.string.trim(),\n      x: wordObj.x,\n      y: wordObj.y,\n      direction: wordObj.dir === 0 ? 'horizontal' : 'vertical'\n    }));\n  }\n\n  // Example usage:\n  const result = populate(['GIÓ', 'HẠT GIỐNG', 'DREAM', 'THUỐC', 'CÚC', 'CHÂU KIỆT LUÂN']);\n  console.log(result);\n  return /*#__PURE__*/_jsxDEV(_Fragment, {}, void 0, false);\n};\n_c = WordBoard;\nexport default WordBoard;\nvar _c;\n$RefreshReg$(_c, \"WordBoard\");","map":{"version":3,"names":["React","Fragment","_Fragment","jsxDEV","_jsxDEV","WordBoard","BOARD_SIZE","CENTER","Math","floor","board","Array","from","length","fill","isPos","classesOfBoard","Bounds","top","bottom","left","right","Update","x","y","min","max","wordBank","wordsActive","wordArr","createWordObj","word","string","char","split","totalMatches","effectiveMatches","successfulMatches","dir","prepareBoard","words","map","w","i","wA","j","cA","k","wB","l","findWordIdx","givenWord","trim","findIndex","addWordToBoard","curIndex","minMatchDiff","reduce","minIdx","curWord","curChar","testWord","testChar","curCross","isMatch","m","around","yy","_board$x$yy","xx","_board$xx$y","push","curMatchDiff","placedWord","splice","matchArr","match","random","idx","populate","success","wordObj","direction","result","console","log","_c","$RefreshReg$"],"sources":["C:/Users/ASUS/Documents/htm_fe/src/pages/Host/Management/HostRound2.tsx"],"sourcesContent":["import React, { useState, useEffect } from \"react\";\r\n\r\n// Define word object structure\r\n\r\n\r\n// Main React Component\r\nconst WordBoard: React.FC = () => {\r\n  type Direction = 'horizontal' | 'vertical';\r\n\r\n  interface PlacedWord {\r\n    word: string;\r\n    x: number;\r\n    y: number;\r\n    direction: Direction;\r\n  }\r\n\r\n  interface WordObj {\r\n    string: string;\r\n    char: string[];\r\n    totalMatches: number;\r\n    effectiveMatches: number;\r\n    successfulMatches: { x: number; y: number; dir: number }[];\r\n    x: number;\r\n    y: number;\r\n    dir: number;\r\n  }\r\n\r\n  const BOARD_SIZE = 50;\r\n  const CENTER = Math.floor(BOARD_SIZE / 2);\r\n\r\n  let board: (string | null)[][] = Array.from({ length: BOARD_SIZE }, () =>\r\n    Array(BOARD_SIZE).fill(null)\r\n  );\r\n  let isPos: boolean[][] = Array.from({ length: BOARD_SIZE }, () =>\r\n    Array(BOARD_SIZE).fill(false)\r\n  );\r\n  let classesOfBoard: number[][][] = Array.from({ length: BOARD_SIZE }, () =>\r\n    Array.from({ length: BOARD_SIZE }, () => [])\r\n  );\r\n\r\n  const Bounds = {\r\n    top: CENTER,\r\n    bottom: CENTER,\r\n    left: CENTER,\r\n    right: CENTER,\r\n    Update(x: number, y: number) {\r\n      this.top = Math.min(this.top, y);\r\n      this.bottom = Math.max(this.bottom, y);\r\n      this.left = Math.min(this.left, x);\r\n      this.right = Math.max(this.right, x);\r\n    },\r\n  };\r\n\r\n  let wordBank: WordObj[] = [];\r\n  let wordsActive: WordObj[] = [];\r\n  let wordArr: string[] = [];\r\n\r\n  function createWordObj(word: string): WordObj {\r\n    return {\r\n      string: ` ${word} `,\r\n      char: ` ${word} `.split(''),\r\n      totalMatches: 0,\r\n      effectiveMatches: 0,\r\n      successfulMatches: [],\r\n      x: 0,\r\n      y: 0,\r\n      dir: 0,\r\n    };\r\n  }\r\n\r\n  function prepareBoard(words: string[]) {\r\n    wordArr = words;\r\n    wordBank = wordArr.map((w) => createWordObj(w));\r\n    for (let i = 0; i < wordBank.length; i++) {\r\n      const wA = wordBank[i];\r\n      for (let j = 0; j < wA.char.length; j++) {\r\n        const cA = wA.char[j];\r\n        for (let k = 0; k < wordBank.length; k++) {\r\n          if (k === i) continue;\r\n          const wB = wordBank[k];\r\n          for (let l = 0; l < wB.char.length; l++) {\r\n            wA.totalMatches += cA === wB.char[l] ? 1 : 0;\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  function findWordIdx(givenWord: string): number {\r\n    givenWord = givenWord.trim();\r\n    return wordArr.findIndex((w) => w === givenWord);\r\n  }\r\n\r\n  function addWordToBoard(): boolean {\r\n    let curIndex: number = -1;\r\n    let minMatchDiff = 9999;\r\n\r\n    if (wordsActive.length < 1) {\r\n      curIndex = wordBank.reduce(\r\n        (minIdx, word, i) =>\r\n          word.totalMatches < wordBank[minIdx].totalMatches ? i : minIdx,\r\n        0\r\n      );\r\n      wordBank[curIndex].successfulMatches = [{ x: CENTER, y: CENTER, dir: 0 }];\r\n    } else {\r\n      for (let i = 0; i < wordBank.length; i++) {\r\n        const curWord = wordBank[i];\r\n        curWord.effectiveMatches = 0;\r\n        curWord.successfulMatches = [];\r\n\r\n        for (let j = 0; j < curWord.char.length; j++) {\r\n          if (j === 1) continue;\r\n          const curChar = curWord.char[j];\r\n\r\n          for (const testWord of wordsActive) {\r\n            for (let l = 0; l < testWord.char.length; l++) {\r\n              if (l === 1) continue;\r\n              const testChar = testWord.char[l];\r\n\r\n              if (curChar === testChar) {\r\n                curWord.effectiveMatches++;\r\n                const curCross = {\r\n                  x: testWord.x,\r\n                  y: testWord.y,\r\n                  dir: testWord.dir === 0 ? 1 : 0,\r\n                };\r\n\r\n                if (testWord.dir === 0) {\r\n                  curCross.x += l;\r\n                  curCross.y -= j;\r\n                } else {\r\n                  curCross.y += l;\r\n                  curCross.x -= j;\r\n                }\r\n\r\n                let isMatch = true;\r\n                for (let m = -1; m <= curWord.char.length; m++) {\r\n                  if (m === j) continue;\r\n\r\n                  if (curCross.dir === 0) {\r\n                    const x = curCross.x + m;\r\n                    if (x < 0 || x >= BOARD_SIZE) {\r\n                      isMatch = false;\r\n                      break;\r\n                    }\r\n                    const y = curCross.y;\r\n                    const around = [y, y + 1, y - 1].map((yy) =>\r\n                      board[x][yy] ?? null\r\n                    );\r\n\r\n                    if (\r\n                      m >= 0 &&\r\n                      m < curWord.char.length &&\r\n                      (around[0] !== null && around[0] !== curWord.char[m])\r\n                    ) {\r\n                      isMatch = false;\r\n                      break;\r\n                    } else if (\r\n                      (m === -1 || m === curWord.char.length) &&\r\n                      around[0] !== null\r\n                    ) {\r\n                      isMatch = false;\r\n                      break;\r\n                    }\r\n                  } else {\r\n                    const y = curCross.y + m;\r\n                    if (y < 0 || y >= BOARD_SIZE) {\r\n                      isMatch = false;\r\n                      break;\r\n                    }\r\n                    const x = curCross.x;\r\n                    const around = [x, x + 1, x - 1].map((xx) =>\r\n                      board[xx][y] ?? null\r\n                    );\r\n\r\n                    if (\r\n                      m >= 0 &&\r\n                      m < curWord.char.length &&\r\n                      (around[0] !== null && around[0] !== curWord.char[m])\r\n                    ) {\r\n                      isMatch = false;\r\n                      break;\r\n                    } else if (\r\n                      (m === -1 || m === curWord.char.length) &&\r\n                      around[0] !== null\r\n                    ) {\r\n                      isMatch = false;\r\n                      break;\r\n                    }\r\n                  }\r\n                }\r\n\r\n                if (isMatch) curWord.successfulMatches.push(curCross);\r\n              }\r\n            }\r\n          }\r\n        }\r\n\r\n        const curMatchDiff = curWord.totalMatches - curWord.effectiveMatches;\r\n        if (\r\n          curMatchDiff <= minMatchDiff &&\r\n          curWord.successfulMatches.length > 0\r\n        ) {\r\n          minMatchDiff = curMatchDiff;\r\n          curIndex = i;\r\n        }\r\n      }\r\n\r\n      if (curIndex === -1) return false;\r\n    }\r\n\r\n    const placedWord = wordBank.splice(curIndex, 1)[0];\r\n    const matchArr = placedWord.successfulMatches;\r\n    const match = matchArr[Math.floor(Math.random() * matchArr.length)];\r\n\r\n    placedWord.x = match.x;\r\n    placedWord.y = match.y;\r\n    placedWord.dir = match.dir;\r\n\r\n    for (let i = 0; i < placedWord.char.length; i++) {\r\n      const x = match.dir === 0 ? match.x + i : match.x;\r\n      const y = match.dir === 1 ? match.y + i : match.y;\r\n      board[x][y] = placedWord.char[i];\r\n      isPos[x][y] = i === 1;\r\n      const idx = findWordIdx(placedWord.string.trim());\r\n      classesOfBoard[x][y].push(idx + 1);\r\n      Bounds.Update(x, y);\r\n    }\r\n\r\n    wordsActive.push(placedWord);\r\n    return true;\r\n  }\r\n\r\n  function populate(words: string[]): PlacedWord[] {\r\n    prepareBoard(words);\r\n    while (wordBank.length > 0) {\r\n      const success = addWordToBoard();\r\n      if (!success) break;\r\n    }\r\n\r\n    return wordsActive.map((wordObj) => ({\r\n      word: wordObj.string.trim(),\r\n      x: wordObj.x,\r\n      y: wordObj.y,\r\n      direction: wordObj.dir === 0 ? 'horizontal' : 'vertical',\r\n    }));\r\n  }\r\n\r\n  // Example usage:\r\n  const result = populate([\r\n    'GIÓ',\r\n    'HẠT GIỐNG',\r\n    'DREAM',\r\n    'THUỐC',\r\n    'CÚC',\r\n    'CHÂU KIỆT LUÂN',\r\n  ]);\r\n  console.log(result);\r\n\r\n  return (\r\n    <>\r\n    </>\r\n  );\r\n};\r\n\r\nexport default WordBoard;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}