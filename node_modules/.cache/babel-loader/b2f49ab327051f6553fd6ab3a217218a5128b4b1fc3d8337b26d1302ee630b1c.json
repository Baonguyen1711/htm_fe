{"ast":null,"code":"// // Tạo từ khóa gợi ý với vị trí và hướng random\n\n// interface HintWord {\n//     word: string;\n//     x: number;\n//     y: number;\n//     direction: \"horizontal\" | \"vertical\";\n// }\n\n// interface ObstacleQuestionBoxProps {\n//     obstacleWord: string;\n// }\n\n// type PlacedWord = {\n//     word: string;\n//     x: number;\n//     y: number;\n//     direction: \"horizontal\" | \"vertical\";\n// };\n\n// export const findCommonLetterIndexes = (word1: string, word2: string) => {\n//     const result = []\n//     for (let i=0;i<word1.length;i++) {\n//         for(let j =0;j<word2.length;j++) {\n//             if(word1[i] === word2[j]) {\n//                 result.push({\n//                     [word1] : i,\n//                     [word2] : j\n//                 })\n//             }\n//         }\n//     }\n\n//     return result\n// }\n\n// const canPlaceWord = (word: string, x:number, y:number, grid:string[][], direction:\"horizontal\"|\"vertical\") => {\n//     if(direction == \"horizontal\") {\n//         for (let i=0;i<word.length;i++) {\n//             if (grid[x][y+i] !== \"\" || grid[x][y+i] == undefined) return false\n//         }\n//     }\n\n//     if(direction ==\"vertical\") {\n//         for (let i=0;i<word.length;i++) {\n//             if (grid[x+i][y] !== \"\") return false\n//         }\n//     }\n\n//     return true\n// }\n\n// export const findCommonLetterPairs = (wordList: string[], gridSize: number, grid: string[][]) => {\n//     const REQUIRE_PAIRS = Math.floor(Math.random()*2) + 1\n//     console.log(\"REQUIRE_PAIRS\",REQUIRE_PAIRS);\n\n//     const tempWordList = [...wordList]\n//     const commonPairs = [\n//     ]\n//     const placedWords = new Set()\n//     const wordsCoordinate: PlacedWord[] = []\n\n//     let found = false\n//     let pairs = 0\n//     let direction = \"horizontal\"\n//     let nextPosition:{x:number, y:number} = {\n//         x: 0,\n//         y: 0\n//     }\n\n//     if(REQUIRE_PAIRS == 2) {\n//         while (pairs <REQUIRE_PAIRS && !found) {\n\n//             for (let i =0;i<tempWordList.length;i++) {\n//                 if(pairs==REQUIRE_PAIRS || found == true) break\n\n//                 const word1 = tempWordList[i]\n//                 if(placedWords.has(word1)) continue\n\n//                 for (let j =0;j<tempWordList.length;j++) {\n//                     if (tempWordList[j] === word1) continue\n\n//                     if(placedWords.has(tempWordList[j])) continue\n\n//                     const result = findCommonLetterIndexes(word1,tempWordList[j])\n\n//                     if(result.length >0) {\n//                         console.log(\"result\",result);\n//                         const index = Math.floor(Math.random() * result.length)\n//                         console.log(\"index\",index);\n\n//                         commonPairs.push(result[index])\n//                         console.log(\"pairs\",pairs);\n//                         placedWords.add(word1)\n//                         placedWords.add(tempWordList[j])\n//                         pairs = pairs + 1\n//                         break\n//                     }\n\n//                     if(i==tempWordList.length-1 && j==tempWordList.length-1) {\n//                         found = true\n//                         break\n//                     }\n\n//                 }\n//             }\n//         }\n//     }\n\n//     if(REQUIRE_PAIRS == 1) {\n//         const sortedTempWordList = [...tempWordList].sort((a, b) => b.length - a.length);\n//         let index = -1\n//         while (!found) {\n\n//             for (let i =0;i<sortedTempWordList.length;i++) {\n//                 if(found == true) break\n\n//                 const word1 = sortedTempWordList[i]\n//                 if(placedWords.has(word1)) continue\n\n//                 for (let j =0;j<sortedTempWordList.length;j++) {\n//                     if (sortedTempWordList[j] === word1) continue\n\n//                     const result = findCommonLetterIndexes(word1,sortedTempWordList[j])\n\n//                     if(result.length >0) {\n//                         console.log(\"result\",result);\n//                         const index = Math.floor(Math.random() * result.length)\n//                         console.log(\"index\",index);\n\n//                         commonPairs.push(result[index])\n//                         console.log(\"pairs\",pairs);\n//                         placedWords.add(word1)\n//                         placedWords.add(sortedTempWordList[j])\n\n//                     }\n\n//                     if(commonPairs.length ==2) {\n//                         found = true\n//                         break\n//                     }\n\n//                     if(i==tempWordList.length-1 && j==tempWordList.length-1) {\n//                         found = true\n//                         break\n//                     }\n\n//                 }\n//             }\n//         }\n//     }\n\n//     //loop until 2 pairs are found or go through all the array\n\n//     for (let pairs of commonPairs){\n//         const keys = Object.keys(pairs);\n//         const x = Math.floor(Math.random() * gridSize)\n//         const y = Math.floor(Math.random() * (gridSize-keys[0].length))\n//         const word1Coordinate: PlacedWord = {\n//             word: keys[0],\n//             x: x,\n//             y: y,\n//             direction: \"horizontal\"\n//         }\n\n//         const word2Coordinate: PlacedWord = {\n//             word: keys[1],\n//             x: 1,\n//             y: pairs[keys[0]] + 1,\n//             direction: \"vertical\"\n//         }\n\n//         placedWords.add(word1Coordinate)\n//         placedWords.add(word2Coordinate)\n\n//     }\n\n//     return commonPairs\n\n// }\n\n// export const generateHintWords = (words: string[], gridSize: number, obstacleWord: string): HintWord[] => {\n//     const grid: string[][] = Array(gridSize)\n//         .fill(null)\n//         .map(() => Array(gridSize).fill(\"\")); // Mảng kiểm tra vị trí\n\n//     const findCommonLetterPairs = (words: string[]): { word1: string; word2: string; commonLetters: string[] }[] => {\n//         let results: { word1: string; word2: string; commonLetters: string[] }[] = [];\n//         let usedWords = new Set<string>(); // Lưu lại các từ đã dùng\n\n//         let remainingPairs: { word1: string; word2: string; commonLetters: string[] }[] = [];\n\n//         for (let i = 0; i < words.length; i++) {\n//             for (let j = i + 1; j < words.length; j++) {\n//                 const word1 = words[i];\n//                 const word2 = words[j];\n\n//                 // Tìm ký tự chung giữa 2 từ\n//                 const commonLetters = [...new Set(word1)].filter((letter) => word2.includes(letter));\n\n//                 if (commonLetters.length >= 2) {\n//                     // Tính điểm ưu tiên (chữ gần trung tâm hơn)\n//                     const scoredLetters = commonLetters.map((letter) => {\n//                         const index1 = word1.indexOf(letter);\n//                         const index2 = word2.indexOf(letter);\n//                         const center1 = word1.length / 2;\n//                         const center2 = word2.length / 2;\n//                         const score = Math.abs(index1 - center1) + Math.abs(index2 - center2);\n//                         return { letter, score };\n//                     });\n\n//                     // Sắp xếp theo điểm ưu tiên\n//                     scoredLetters.sort((a, b) => a.score - b.score);\n//                     const prioritizedLetters = scoredLetters.map((item) => item.letter);\n\n//                     remainingPairs.push({ word1, word2, commonLetters: prioritizedLetters });\n//                 }\n//             }\n//         }\n\n//         // Bước 2: Chọn tối đa 2 cặp theo quy tắc\n//         for (const pair of remainingPairs) {\n//             if (results.length >= 2) break; // Đủ 2 cặp thì dừng\n//             if (!usedWords.has(pair.word1) && !usedWords.has(pair.word2)) {\n//                 results.push(pair);\n//                 usedWords.add(pair.word1);\n//                 usedWords.add(pair.word2);\n//             }\n//         }\n\n//         // Nếu vẫn chưa đủ 2 cặp, chọn tiếp từ các cặp có từ đã dùng\n//         for (const pair of remainingPairs) {\n//             if (results.length >= 2) break;\n//             if (!usedWords.has(pair.word1) || !usedWords.has(pair.word2)) {\n//                 results.push(pair);\n//                 usedWords.add(pair.word1);\n//                 usedWords.add(pair.word2);\n//             }\n//         }\n\n//         return results;\n//     };\n\n//     // 🛠 Test\n//     //const testwords = [\"BƯUCHÍNH\", \"5G\", \"BQP\", \"TẬPĐOÀN\", \"HÀNỘI\", \"RED\"];\n\n//     const shuffledWords = [...words].sort(() => Math.random() - 0.5);\n//     const placeWordsOnGrid = (words: string[], gridSize: number): PlacedWord[] => {\n//         while (true) {\n//             let placedWords: PlacedWord[] = [];\n//             let occupiedPositions = new Set<string>();\n//             let placedSet = new Set<string>(); // Set để theo dõi từ đã đặt\n//             let allPlaced = true; // Cờ kiểm tra xem tất cả từ có được đặt hay không\n\n//             const getKey = (x: number, y: number) => `${x},${y}`;\n\n//             const canPlaceWord = (word: string, x: number, y: number, direction: \"horizontal\" | \"vertical\", index: number) => {\n//                 for (let i = 0; i < word.length; i++) {\n//                     if (i === x + index) continue;\n//                     let newX = direction === \"horizontal\" ? x + i : x;\n//                     let newY = direction === \"horizontal\" ? y : y + i;\n//                     if (newX < 0 || newY < 0 || newX >= gridSize || newY >= gridSize || occupiedPositions.has(getKey(newX, newY))) {\n//                         return false;\n//                     }\n//                 }\n//                 return true;\n//             };\n\n//             const commonLetterPairs = findCommonLetterPairs(words);\n//             console.log(commonLetterPairs);\n\n//             for (const { word1, word2, commonLetters } of commonLetterPairs) {\n//                 if (placedSet.has(word1) || placedSet.has(word2)) continue; // Kiểm tra nếu đã đặt thì bỏ qua\n\n//                 const commonLetter = commonLetters[0];\n//                 const index1 = word1.indexOf(commonLetter);\n//                 const index2 = word2.indexOf(commonLetter);\n\n//                 let placed = false;\n//                 for (let attempt = 0; attempt < 100; attempt++) {\n//                     let x = Math.floor(Math.random() * (gridSize - word1.length)) + 1;\n//                     let y = Math.floor(Math.random() * (gridSize - index2) + index2) + 1;\n\n//                     if (canPlaceWord(word1, x, y, \"horizontal\", index1)) {\n//                         placedWords.push({ word: word1, x, y, direction: \"horizontal\" });\n//                         placedSet.add(word1);\n\n//                         let intersecrX = x + index1;\n//                         let intersectY = y;\n\n//                         if (canPlaceWord(word2, intersecrX, intersectY - index2, \"vertical\", index2)) {\n//                             for (let i = 0; i < word1.length; i++) occupiedPositions.add(getKey(x + i, y));\n//                             placedWords.push({ word: word2, x: intersecrX, y: intersectY - index2, direction: \"vertical\" });\n//                             placedSet.add(word2);\n\n//                             for (let i = 0; i < word2.length; i++) occupiedPositions.add(getKey(intersecrX, intersectY - index2 + i));\n\n//                             placed = true;\n//                             break;\n//                         } else {\n//                             placedWords.pop();\n//                         }\n//                     }\n//                 }\n\n//                 if (!placed) {\n//                     console.warn(`Không thể đặt cặp từ: ${word1} - ${word2}`);\n//                     allPlaced = false;\n//                     break;\n//                 }\n//             }\n\n//             for (const word of words) {\n//                 if (placedSet.has(word)) continue;\n\n//                 let placed = false;\n//                 let found = false;\n\n//                 for (let j = placedWords.length - 1; j >= 0; j--) {\n//                     for (let attempt = 0; attempt < 10; attempt++) {\n//                         let direction: \"horizontal\" | \"vertical\" = placedWords[j].direction === \"horizontal\" ? \"vertical\" : \"horizontal\";\n//                         const shift = Math.random() < 0.5 ? 1 : -1;\n//                         let x = placedWords[j].direction === \"horizontal\" ? placedWords[j].word.length + placedWords[j].x : placedWords[j].x + 1;\n//                         let y = placedWords[j].direction === \"horizontal\" ? placedWords[j].y + 2 : placedWords[j].word.length + placedWords[j].y;\n\n//                         if (canPlaceWord(word, x, y, direction, 0)) {\n//                             placedWords.push({ word, x, y, direction });\n//                             placedSet.add(word);\n\n//                             for (let i = 0; i < word.length; i++) {\n//                                 let newX = direction === \"horizontal\" ? x + i : x;\n//                                 let newY = direction === \"horizontal\" ? y : y + i;\n//                                 occupiedPositions.add(getKey(newX, newY));\n//                             }\n\n//                             placed = true;\n//                             found = true;\n//                             break;\n//                         }\n//                     }\n\n//                     if (found) break;\n//                 }\n\n//                 if (!placed) {\n//                     console.warn(`Không thể đặt từ: ${word}`);\n//                     allPlaced = false;\n//                     break;\n//                 }\n//             }\n//             if (!allPlaced) continue; // Nếu có từ không đặt được, restart vòng lặp\n\n//             if (allPlaced) return placedWords; // Nếu tất cả từ đều được đặt, thoát khỏi vòng lặp và trả về kết quả\n//         }\n//     };\n\n//     const placedWords = placeWordsOnGrid(shuffledWords, gridSize);\n//     console.log(placedWords);\n\n//     return placedWords;\n// };\n\n// export const renderGrid = (wordList: string[], mainKeyword:string, GRID_SIZE:number) => {\n//     console.log(\"wordList on render\", wordList);\n\n//     const maxAttempts = 100;\n\n//     const generateEmptyGrid = () => {\n//         return Array(GRID_SIZE).fill(null).map(() => Array(GRID_SIZE).fill(\"\"));\n//     };\n\n//     const getKey = (x: number, y: number) => `${x},${y}`;\n\n//     const canPlaceNumber = (x: number, y: number) => {\n//         if (x < 0 || y < 0 || x >= GRID_SIZE || y >= GRID_SIZE) return false;\n//         return !occupiedPositions.has(getKey(x, y));\n//     };\n\n//     const hasCommonLetter = (word1: string, word2: string) => {\n//         return [...new Set(word1)].some((letter) => word2.includes(letter));\n//     };\n\n//     // Try to place words and numbers until a valid configuration is found\n//     let attempts = 0;\n//     let randomHintWords: HintWord[] = [];\n//     let newGrid = generateEmptyGrid();\n//     let occupiedPositions = new Set<string>();\n//     let occupiedRows = new Set<number>();\n//     let occupiedCols = new Set<number>();\n\n//     while (attempts < maxAttempts) {\n//         randomHintWords = generateHintWords(wordList, GRID_SIZE, mainKeyword);\n//         newGrid = generateEmptyGrid();\n//         occupiedPositions.clear();\n//         occupiedRows.clear();\n//         occupiedCols.clear();\n\n//         let canPlaceAll = true;\n\n//         // First pass: Place words and mark their positions\n//         for (const { word, x, y, direction } of randomHintWords) {\n//             if (direction === \"horizontal\") {\n//                 occupiedRows.add(y);\n//                 // Check for adjacent rows\n//                 for (const other of randomHintWords) {\n//                     if (other.word === word || other.direction !== \"horizontal\") continue; // Fixed comparison\n//                     if (Math.abs(other.y - y) === 1 && !hasCommonLetter(word, other.word)) {\n//                         canPlaceAll = false;\n//                         break;\n//                     }\n//                 }\n//             } else {\n//                 occupiedCols.add(x);\n//                 // Check for adjacent columns\n//                 for (const other of randomHintWords) {\n//                     if (other.word === word || other.direction !== \"vertical\") continue; // Fixed comparison\n//                     if (Math.abs(other.x - x) === 1 && !hasCommonLetter(word, other.word)) {\n//                         canPlaceAll = false;\n//                         break;\n//                     }\n//                 }\n//             }\n\n//             if (!canPlaceAll) break;\n\n//             for (let i = 0; i < word.length; i++) {\n//                 let newX = direction === \"horizontal\" ? x + i : x;\n//                 let newY = direction === \"horizontal\" ? y : y + i;\n//                 newGrid[newY][newX] = word[i];\n//                 occupiedPositions.add(getKey(newX, newY));\n//             }\n//         }\n\n//         if (!canPlaceAll) {\n//             attempts++;\n//             continue;\n//         }\n\n//         // Second pass: Check if numbers can be placed without overlap\n\n//         for (const { word, x, y, direction } of randomHintWords) {\n//             const wordNumber = wordList.includes(word) ? wordList.indexOf(word) + 1 : -1; // Kiểm tra trước khi lấy số\n\n//             if (wordNumber === -1) {\n//                 console.error(`Không tìm thấy từ ${word} trong wordList`);\n//                 continue; // Nếu không tìm thấy, tiếp tục vòng lặp\n//             }\n\n//             if (direction === \"horizontal\" && x > 0) {\n//                 if (!canPlaceNumber(x - 1, y)) {\n//                     canPlaceAll = false;\n//                     break;\n//                 }\n//             } else if (direction === \"vertical\" && y > 0) {\n//                 if (!canPlaceNumber(x, y - 1)) {\n//                     canPlaceAll = false;\n//                     break;\n//                 }\n//             }\n//         }\n\n//         if (canPlaceAll) {\n//             // Place numbers if all checks pass\n//             randomHintWords.forEach(({ word, x, y, direction }) => {\n//                 const wordNumber = wordList.indexOf(word) + 1;\n//                 console.log(\"wordList\",wordList)\n//                 console.log(\"word\",word);\n\n//                 console.log(\"wordNumber\",wordNumber)\n//                 let newY = y; // Tạo biến mới để lưu trữ vị trí x đã điều chỉnh\n\n//                 // Kiểm tra nếu ô bên trái đã bị chiếm, thì dịch sang phải\n//                 if (newGrid[x][y-1] !== '') {\n//                     newY = y + 1; // Dịch sang phải 1 đơn vị\n\n//                     // Nếu là horizontal, cần kiểm tra toàn bộ các ô của word và dịch chúng\n//                     if (direction === \"horizontal\") {\n//                         // Kiểm tra xem sau khi dịch có đủ không gian không\n//                         if (newY + word.length > newGrid[0].length) {\n//                             // Có thể cần xử lý trường hợp vượt quá kích thước grid\n//                             console.error(\"Không dịch được sang phải\")\n//                             return;\n//                         }\n//                         // Cập nhật các ô của word ở vị trí mới\n//                         for (let i = 0; i < word.length; i++) {\n//                             newGrid[x][newY+i] = word[i];\n//                             occupiedPositions.add(getKey(x, newY+i));\n//                         }\n\n//                         occupiedPositions.delete(getKey(x,y))\n//                         newGrid[x][y] = \"\"\n//                     }\n//                 }\n//                 if (direction === \"horizontal\" && x > 0) {\n//                     newGrid[y][x - 1] = `number${wordNumber.toString()}`;\n//                     occupiedPositions.add(getKey(x - 1, y));\n//                 } else if (direction === \"vertical\" && y > 0) {\n//                     newGrid[y - 1][x] = `number${wordNumber.toString()}`;\n//                     occupiedPositions.add(getKey(x, y - 1));\n//                 }\n//             });\n\n//             break; // Valid configuration found, exit loop\n//         }\n\n//         attempts++;\n//     }\n\n//     if (attempts >= maxAttempts) {\n//         console.warn(\"Could not find a valid grid configuration without overlapping numbers or adjacent non-shared words after max attempts.\");\n//     }\n\n//     return {randomHintWords, newGrid}\n// }\n\n// interface Word {\n//     string: string;\n//     char: string[];\n//     index: number;\n//     successfulMatches: Match[];\n//     totalMatches: number;\n//     effectiveMatches: number;\n//     x?: number;\n//     y?: number;\n//     dir?: number;\n//   }\n\n//   interface Match {\n//     x: number;\n//     y: number;\n//     dir: number;\n//   }\n\n//   interface Bounds {\n//     minX: number;\n//     maxX: number;\n//     minY: number;\n//     maxY: number;\n//     update: (x: number, y: number) => void;\n//   }\n\n//   interface CrosswordResult {\n//     board: (string | null)[][];\n//     wordsActive: Word[];\n//     success: boolean;\n//     message?: string;\n//   }\n\n//   export function generateCrossword(wordList: string[], board: (string | null)[][]): CrosswordResult {\n//     // Kiểm tra đầu vào\n//     if (!Array.isArray(wordList) || wordList.length !== 6 || !wordList.every(w => typeof w === 'string')) {\n//       return { board: [], wordsActive: [], success: false, message: 'wordList must be an array of 6 strings' };\n//     }\n//     if (!Array.isArray(board) || board.length === 0 || board[0].length !== 20) {\n//       board = Array.from({ length: 20 }, () => Array(20).fill(null)) as (string | null)[][];\n//     }\n\n//     // Khởi tạo cấu trúc dữ liệu\n//     const wordsActive: Word[] = [];\n//     const wordBank: Word[] = wordList.map((word, idx) => ({\n//       string: word.toUpperCase(),\n//       char: word.toUpperCase().split(''),\n//       index: idx,\n//       successfulMatches: [],\n//       totalMatches: 0,\n//       effectiveMatches: 0\n//     }));\n//     const bounds: Bounds = {\n//       minX: 0,\n//       maxX: 0,\n//       minY: 0,\n//       maxY: 0,\n//       update: function(x: number, y: number) {\n//         this.minX = Math.min(this.minX, x);\n//         this.maxX = Math.max(this.maxX, x);\n//         this.minY = Math.min(this.minY, y);\n//         this.maxY = Math.max(this.maxY, y);\n//       }\n//     };\n\n//     // Hàm kiểm tra xem ô có hợp lệ để đặt ký tự không\n//     function isValidPosition(x: number, y: number, char: string, board: (string | null)[][], dir: number, word: Word, i: number): boolean {\n//       if (x < 0 || x >= board.length || y < 0 || y >= board[0].length) return false;\n//       if (board[x][y] === null) return true;\n//       if (board[x][y] === char) {\n//         // Kiểm tra xung đột với từ khác tại giao điểm\n//         const crossDir = dir === 0 ? 1 : 0;\n//         const crossVal = [\n//           crossDir === 0 ? (x > 0 ? board[x-1][y] : null) : (y > 0 ? board[x][y-1] : null),\n//           board[x][y],\n//           crossDir === 0 ? (x < board.length-1 ? board[x+1][y] : null) : (y < board[0].length-1 ? board[x][y+1] : null)\n//         ];\n//         return crossVal[0] === null && crossVal[2] === null && board[x][y] === char;\n//       }\n//       return false;\n//     }\n\n//     // Hàm mở rộng bảng nếu cần\n//     function expandBoard(board: (string | null)[][], x: number, y: number): void {\n//       while (x >= board.length) {\n//         board.push(Array(board[0].length).fill(null));\n//       }\n//       while (y >= board[0].length) {\n//         for (let i = 0; i < board.length; i++) {\n//           board[i].push(null);\n//         }\n//       }\n//     }\n\n//     // Hàm tìm các vị trí giao nhau hợp lệ cho một từ\n//     function findMatches(word: Word, board: (string | null)[][], wordsActive: Word[]): void {\n//       word.successfulMatches = [];\n//       word.totalMatches = 0;\n//       word.effectiveMatches = 0;\n\n//       if (wordsActive.length === 0) {\n//         // Nếu bảng rỗng, đặt từ đầu tiên ở giữa\n//         const x = Math.floor(board.length / 2);\n//         const y = Math.floor(board[0].length / 2);\n//         const dir = Math.random() < 0.5 ? 0 : 1;\n//         word.successfulMatches.push({ x, y, dir });\n//         word.totalMatches = 1;\n//         word.effectiveMatches = 1;\n//         return;\n//       }\n\n//       for (const placedWord of wordsActive) {\n//         for (let i = 0; i < word.char.length; i++) {\n//           for (let k = 0; k < placedWord.char.length; k++) {\n//             if (word.char[i] === placedWord.char[k]) {\n//               word.totalMatches++;\n//               // Thử đặt từ theo hướng ngang (dir=0) và dọc (dir=1)\n//               for (let dir = 0; dir <= 1; dir++) {\n//                 const x = dir === 0 ? placedWord.x! + k - i : placedWord.x! + k;\n//                 const y = dir === 0 ? placedWord.y! : placedWord.y! - i;\n//                 let isValid = true;\n//                 // Kiểm tra toàn bộ từ có thể đặt được không\n//                 for (let m = 0; m < word.char.length; m++) {\n//                   const xPos = dir === 0 ? x + m : x;\n//                   const yPos = dir === 0 ? y : y + m;\n//                   expandBoard(board, xPos, yPos);\n//                   if (!isValidPosition(xPos, yPos, word.char[m], board, dir, word, m)) {\n//                     isValid = false;\n//                     break;\n//                   }\n//                 }\n//                 if (isValid) {\n//                   word.successfulMatches.push({ x, y, dir });\n//                   word.effectiveMatches++;\n//                 }\n//               }\n//             }\n//           }\n//         }\n//       }\n//     }\n\n//     // Hàm đặt từ lên bảng\n//     function placeWord(word: Word, board: (string | null)[][], wordsActive: Word[]): boolean {\n//       if (word.successfulMatches.length === 0) return false;\n\n//       // Chọn ngẫu nhiên một vị trí giao nhau hợp lệ\n//       const matchIndex = Math.floor(Math.random() * word.successfulMatches.length);\n//       const matchData = word.successfulMatches[matchIndex];\n\n//       // Cập nhật thông tin từ\n//       word.x = matchData.x;\n//       word.y = matchData.y;\n//       word.dir = matchData.dir;\n\n//       // Đặt từng ký tự lên bảng\n//       for (let i = 0; i < word.char.length; i++) {\n//         const xIndex = matchData.dir === 0 ? matchData.x + i : matchData.x;\n//         const yIndex = matchData.dir === 0 ? matchData.y : matchData.y + i;\n//         expandBoard(board, xIndex, yIndex);\n//         board[xIndex][yIndex] = word.char[i];\n//         bounds.update(xIndex, yIndex);\n//       }\n\n//       wordsActive.push(word);\n//       return true;\n//     }\n\n//     // Hàm chính để đặt tất cả từ\n//     while (wordBank.length > 0) {\n//       let minMatchDiff = Infinity;\n//       let curIndex = -1;\n\n//       // Tìm từ tốt nhất để đặt\n//       for (let i = 0; i < wordBank.length; i++) {\n//         const curWord = wordBank[i];\n//         findMatches(curWord, board, wordsActive);\n//         const curMatchDiff = curWord.totalMatches - curWord.effectiveMatches;\n//         if (curMatchDiff < minMatchDiff && curWord.successfulMatches.length > 0) {\n//           minMatchDiff = curMatchDiff;\n//           curIndex = i;\n//         }\n//       }\n\n//       if (curIndex === -1) {\n//         return { board, wordsActive, success: false, message: 'Failed to place all words' };\n//       }\n\n//       // Đặt từ và loại khỏi wordBank\n//       const wordToPlace = wordBank.splice(curIndex, 1)[0];\n//       if (!placeWord(wordToPlace, board, wordsActive)) {\n//         return { board, wordsActive, success: false, message: 'Failed to place word' };\n//       }\n//     }\n\n//     // Cắt bảng theo bounds để trả về kích thước tối thiểu\n//     const trimmedBoard: (string | null)[][] = [];\n//     for (let x = bounds.minX; x <= bounds.maxX; x++) {\n//       const row = board[x].slice(bounds.minY, bounds.maxY + 1);\n//       trimmedBoard.push(row);\n//     }\n\n//     return { board: trimmedBoard, wordsActive, success: true };\n//   }\n\n// //   // Ví dụ sử dụng\n// //   const wordList: string[] = ['CROSSWORD', 'PUZZLE', 'GRID', 'WORD', 'CLUE', 'GAME'];\n// //   const board: (string | null)[][] = Array.from({ length: 20 }, () => Array(20).fill(null));\n// //   const result: CrosswordResult = generateCrossword(wordList, board);\n// //   console.log('Success:', result.success);\n// //   console.log('Words Active:', result.wordsActive);\n// //   console.log('Board:');\n// //   result.board.forEach(row => console.log(row.map(c => c || '.').join(' ')));\n\n// // function AddWordToBoard(){\n\n// //     var i, len, curIndex, curWord, curChar, curMatch, testWord, testChar,\n// //         minMatchDiff = 9999, curMatchDiff;\n\n// //     if(wordsActive.length < 1){\n// //       curIndex = 0;\n// //       for(i = 0, len = wordBank.length; i < len; i++){\n// //         if (wordBank[i].totalMatches < wordBank[curIndex].totalMatches){\n// //           curIndex = i;\n// //         }\n// //       }\n// //       wordBank[curIndex].successfulMatches = [{x:12,y:12,dir:0}];\n// //     }\n// //     else{\n// //       curIndex = -1;\n\n// //       for(i = 0, len = wordBank.length; i < len; i++){\n// //         curWord = wordBank[i];\n// //         curWord.effectiveMatches = 0;\n// //         curWord.successfulMatches = [];\n// //         for(var j = 0, lenJ = curWord.char.length; j < lenJ; j++){\n// //           if(j == 1) continue; // skip pos\n// //           curChar = curWord.char[j];\n// //           for (var k = 0, lenK = wordsActive.length; k < lenK; k++){\n// //             testWord = wordsActive[k];\n// //             for (var l = 0, lenL = testWord.char.length; l < lenL; l++){\n// //               if(l == 1) continue; // skip pos\n// //               testChar = testWord.char[l];\n// //               if (curChar === testChar){\n// //                 curWord.effectiveMatches++;\n\n// //                 var curCross = {x:testWord.x,y:testWord.y,dir:0};\n// //                 if(testWord.dir === 0){\n// //                   curCross.dir = 1;\n// //                   curCross.x += l;\n// //                   curCross.y -= j;\n// //                 }\n// //                 else{\n// //                   curCross.dir = 0;\n// //                   curCross.y += l;\n// //                   curCross.x -= j;\n// //                 }\n\n// //                 var isMatch = true;\n\n// //                 for(var m = -1, lenM = curWord.char.length + 1; m < lenM; m++){\n// //                   var crossVal = [];\n// //                   if (m !== j){\n// //                     if (curCross.dir === 0){\n// //                       var xIndex = curCross.x + m;\n\n// //                       if (xIndex < 0 || xIndex > board.length){\n// //                         isMatch = false;\n// //                         break;\n// //                       }\n\n// //                       crossVal.push(board[xIndex][curCross.y]);\n// //                       crossVal.push(board[xIndex][curCross.y + 1]);\n// //                       crossVal.push(board[xIndex][curCross.y - 1]);\n// //                     }\n// //                     else{\n// //                       var yIndex = curCross.y + m;\n\n// //                       if (yIndex < 0 || yIndex > board[curCross.x].length){\n// //                         isMatch = false;\n// //                         break;\n// //                       }\n\n// //                       crossVal.push(board[curCross.x][yIndex]);\n// //                       crossVal.push(board[curCross.x + 1][yIndex]);\n// //                       crossVal.push(board[curCross.x - 1][yIndex]);\n// //                     }\n\n// //                     if(m > -1 && m < lenM-1){\n// //                       if (crossVal[0] !== curWord.char[m]){\n// //                         if (crossVal[0] !== null){\n// //                           isMatch = false;\n// //                           break;\n// //                         }\n// //                         else if (crossVal[1] !== null){\n// //                           isMatch = false;\n// //                           break;\n// //                         }\n// //                         else if (crossVal[2] !== null){\n// //                           isMatch = false;\n// //                           break;\n// //                         }\n// //                       }\n// //                     }\n// //                     else if (crossVal[0] !== null){\n// //                       isMatch = false;\n// //                       break;\n// //                     }\n// //                   }\n// //                 }\n\n// //                 if (isMatch === true){\n// //                   curWord.successfulMatches.push(curCross);\n// //                 }\n// //               }\n// //             }\n// //           }\n// //         }\n\n// //         curMatchDiff = curWord.totalMatches - curWord.effectiveMatches;\n\n// //         if (curMatchDiff<minMatchDiff && curWord.successfulMatches.length>0){\n// //           curMatchDiff = minMatchDiff;\n// //           curIndex = i;\n// //         }\n// //         else if (curMatchDiff <= 0){\n// //           return false;\n// //         }\n// //       }\n// //     }\n\n// //     if (curIndex === -1){\n// //       return false;\n// //     }\n\n// //     var spliced = wordBank.splice(curIndex, 1);\n// //     wordsActive.push(spliced[0]);\n\n// //     var pushIndex = wordsActive.length - 1,\n// //         rand = Math.random(),\n// //         matchArr = wordsActive[pushIndex].successfulMatches,\n// //         matchIndex = Math.floor(rand * matchArr.length),\n// //         matchData = matchArr[matchIndex];\n\n// //     wordsActive[pushIndex].x = matchData.x;\n// //     wordsActive[pushIndex].y = matchData.y;\n// //     wordsActive[pushIndex].dir = matchData.dir;\n\n// //     let actualIndex = findWordIdx(wordsActive[pushIndex].string);\n// //     console.log(wordsActive[pushIndex].string, \" ~~~ \", actualIndex);\n// //     for(i = 0, len = wordsActive[pushIndex].char.length; i < len; i++){\n// //       var xIndex = matchData.x,\n// //           yIndex = matchData.y;\n\n// //       if (matchData.dir === 0){\n// //         xIndex += i;\n// //       }\n// //       else{\n// //         yIndex += i;\n// //       }\n// //       board[xIndex][yIndex] = wordsActive[pushIndex].char[i];\n// //       isPos[xIndex][yIndex] = (i == 1);\n// //       classesOfBoard[xIndex][yIndex].push(actualIndex);\n// //       console.log(xIndex, yIndex, classesOfBoard[xIndex][yIndex]);\n\n// //       Bounds.Update(xIndex,yIndex);\n// //     }\n\n// //     return true;\n// //   }","map":{"version":3,"names":[],"sources":["C:/Users/ASUS/Documents/htm_fe/src/layouts/RoundBase/utils.ts"],"sourcesContent":["// // Tạo từ khóa gợi ý với vị trí và hướng random\r\n\r\n// interface HintWord {\r\n//     word: string;\r\n//     x: number;\r\n//     y: number;\r\n//     direction: \"horizontal\" | \"vertical\";\r\n// }\r\n\r\n// interface ObstacleQuestionBoxProps {\r\n//     obstacleWord: string;\r\n// }\r\n\r\n// type PlacedWord = {\r\n//     word: string;\r\n//     x: number;\r\n//     y: number;\r\n//     direction: \"horizontal\" | \"vertical\";\r\n// };\r\n\r\n\r\n// export const findCommonLetterIndexes = (word1: string, word2: string) => {\r\n//     const result = []\r\n//     for (let i=0;i<word1.length;i++) {\r\n//         for(let j =0;j<word2.length;j++) {\r\n//             if(word1[i] === word2[j]) {\r\n//                 result.push({\r\n//                     [word1] : i,\r\n//                     [word2] : j\r\n//                 })\r\n//             }\r\n//         }\r\n//     }\r\n\r\n//     return result\r\n// }\r\n\r\n// const canPlaceWord = (word: string, x:number, y:number, grid:string[][], direction:\"horizontal\"|\"vertical\") => {\r\n//     if(direction == \"horizontal\") {\r\n//         for (let i=0;i<word.length;i++) {\r\n//             if (grid[x][y+i] !== \"\" || grid[x][y+i] == undefined) return false\r\n//         }\r\n//     }\r\n\r\n//     if(direction ==\"vertical\") {\r\n//         for (let i=0;i<word.length;i++) {\r\n//             if (grid[x+i][y] !== \"\") return false\r\n//         }\r\n//     }\r\n\r\n//     return true\r\n// }\r\n\r\n// export const findCommonLetterPairs = (wordList: string[], gridSize: number, grid: string[][]) => {\r\n//     const REQUIRE_PAIRS = Math.floor(Math.random()*2) + 1\r\n//     console.log(\"REQUIRE_PAIRS\",REQUIRE_PAIRS);\r\n    \r\n//     const tempWordList = [...wordList]\r\n//     const commonPairs = [\r\n//     ]\r\n//     const placedWords = new Set()\r\n//     const wordsCoordinate: PlacedWord[] = []\r\n\r\n//     let found = false\r\n//     let pairs = 0\r\n//     let direction = \"horizontal\"\r\n//     let nextPosition:{x:number, y:number} = {\r\n//         x: 0,\r\n//         y: 0\r\n//     }\r\n\r\n    \r\n//     if(REQUIRE_PAIRS == 2) {\r\n//         while (pairs <REQUIRE_PAIRS && !found) {\r\n        \r\n//             for (let i =0;i<tempWordList.length;i++) {\r\n//                 if(pairs==REQUIRE_PAIRS || found == true) break\r\n    \r\n//                 const word1 = tempWordList[i]\r\n//                 if(placedWords.has(word1)) continue\r\n    \r\n//                 for (let j =0;j<tempWordList.length;j++) {\r\n//                     if (tempWordList[j] === word1) continue\r\n    \r\n//                     if(placedWords.has(tempWordList[j])) continue\r\n    \r\n//                     const result = findCommonLetterIndexes(word1,tempWordList[j])\r\n    \r\n//                     if(result.length >0) {\r\n//                         console.log(\"result\",result);\r\n//                         const index = Math.floor(Math.random() * result.length)\r\n//                         console.log(\"index\",index);\r\n                        \r\n//                         commonPairs.push(result[index])\r\n//                         console.log(\"pairs\",pairs);\r\n//                         placedWords.add(word1)\r\n//                         placedWords.add(tempWordList[j])\r\n//                         pairs = pairs + 1\r\n//                         break\r\n//                     }\r\n    \r\n//                     if(i==tempWordList.length-1 && j==tempWordList.length-1) {\r\n//                         found = true\r\n//                         break\r\n//                     }\r\n    \r\n//                 }\r\n//             }\r\n//         }\r\n//     }\r\n\r\n//     if(REQUIRE_PAIRS == 1) {\r\n//         const sortedTempWordList = [...tempWordList].sort((a, b) => b.length - a.length);\r\n//         let index = -1\r\n//         while (!found) {\r\n        \r\n//             for (let i =0;i<sortedTempWordList.length;i++) {\r\n//                 if(found == true) break\r\n    \r\n//                 const word1 = sortedTempWordList[i]\r\n//                 if(placedWords.has(word1)) continue\r\n    \r\n//                 for (let j =0;j<sortedTempWordList.length;j++) {\r\n//                     if (sortedTempWordList[j] === word1) continue\r\n    \r\n//                     const result = findCommonLetterIndexes(word1,sortedTempWordList[j])\r\n    \r\n//                     if(result.length >0) {\r\n//                         console.log(\"result\",result);\r\n//                         const index = Math.floor(Math.random() * result.length)\r\n//                         console.log(\"index\",index);\r\n                        \r\n//                         commonPairs.push(result[index])\r\n//                         console.log(\"pairs\",pairs);\r\n//                         placedWords.add(word1)\r\n//                         placedWords.add(sortedTempWordList[j])\r\n\r\n                        \r\n//                     }\r\n\r\n//                     if(commonPairs.length ==2) {\r\n//                         found = true\r\n//                         break\r\n//                     }\r\n    \r\n//                     if(i==tempWordList.length-1 && j==tempWordList.length-1) {\r\n//                         found = true\r\n//                         break\r\n//                     }\r\n    \r\n//                 }\r\n//             }\r\n//         }\r\n//     }\r\n\r\n//     //loop until 2 pairs are found or go through all the array\r\n    \r\n\r\n//     for (let pairs of commonPairs){\r\n//         const keys = Object.keys(pairs);\r\n//         const x = Math.floor(Math.random() * gridSize)\r\n//         const y = Math.floor(Math.random() * (gridSize-keys[0].length))\r\n//         const word1Coordinate: PlacedWord = {\r\n//             word: keys[0],\r\n//             x: x,\r\n//             y: y,\r\n//             direction: \"horizontal\"\r\n//         }\r\n\r\n//         const word2Coordinate: PlacedWord = {\r\n//             word: keys[1],\r\n//             x: 1,\r\n//             y: pairs[keys[0]] + 1,\r\n//             direction: \"vertical\"\r\n//         }\r\n\r\n//         placedWords.add(word1Coordinate)\r\n//         placedWords.add(word2Coordinate)\r\n\r\n//     }\r\n\r\n//     return commonPairs\r\n    \r\n// }\r\n\r\n\r\n\r\n// export const generateHintWords = (words: string[], gridSize: number, obstacleWord: string): HintWord[] => {\r\n//     const grid: string[][] = Array(gridSize)\r\n//         .fill(null)\r\n//         .map(() => Array(gridSize).fill(\"\")); // Mảng kiểm tra vị trí\r\n\r\n//     const findCommonLetterPairs = (words: string[]): { word1: string; word2: string; commonLetters: string[] }[] => {\r\n//         let results: { word1: string; word2: string; commonLetters: string[] }[] = [];\r\n//         let usedWords = new Set<string>(); // Lưu lại các từ đã dùng\r\n\r\n//         let remainingPairs: { word1: string; word2: string; commonLetters: string[] }[] = [];\r\n\r\n//         for (let i = 0; i < words.length; i++) {\r\n//             for (let j = i + 1; j < words.length; j++) {\r\n//                 const word1 = words[i];\r\n//                 const word2 = words[j];\r\n\r\n//                 // Tìm ký tự chung giữa 2 từ\r\n//                 const commonLetters = [...new Set(word1)].filter((letter) => word2.includes(letter));\r\n\r\n//                 if (commonLetters.length >= 2) {\r\n//                     // Tính điểm ưu tiên (chữ gần trung tâm hơn)\r\n//                     const scoredLetters = commonLetters.map((letter) => {\r\n//                         const index1 = word1.indexOf(letter);\r\n//                         const index2 = word2.indexOf(letter);\r\n//                         const center1 = word1.length / 2;\r\n//                         const center2 = word2.length / 2;\r\n//                         const score = Math.abs(index1 - center1) + Math.abs(index2 - center2);\r\n//                         return { letter, score };\r\n//                     });\r\n\r\n//                     // Sắp xếp theo điểm ưu tiên\r\n//                     scoredLetters.sort((a, b) => a.score - b.score);\r\n//                     const prioritizedLetters = scoredLetters.map((item) => item.letter);\r\n\r\n//                     remainingPairs.push({ word1, word2, commonLetters: prioritizedLetters });\r\n//                 }\r\n//             }\r\n//         }\r\n\r\n//         // Bước 2: Chọn tối đa 2 cặp theo quy tắc\r\n//         for (const pair of remainingPairs) {\r\n//             if (results.length >= 2) break; // Đủ 2 cặp thì dừng\r\n//             if (!usedWords.has(pair.word1) && !usedWords.has(pair.word2)) {\r\n//                 results.push(pair);\r\n//                 usedWords.add(pair.word1);\r\n//                 usedWords.add(pair.word2);\r\n//             }\r\n//         }\r\n\r\n//         // Nếu vẫn chưa đủ 2 cặp, chọn tiếp từ các cặp có từ đã dùng\r\n//         for (const pair of remainingPairs) {\r\n//             if (results.length >= 2) break;\r\n//             if (!usedWords.has(pair.word1) || !usedWords.has(pair.word2)) {\r\n//                 results.push(pair);\r\n//                 usedWords.add(pair.word1);\r\n//                 usedWords.add(pair.word2);\r\n//             }\r\n//         }\r\n\r\n//         return results;\r\n//     };\r\n\r\n//     // 🛠 Test\r\n//     //const testwords = [\"BƯUCHÍNH\", \"5G\", \"BQP\", \"TẬPĐOÀN\", \"HÀNỘI\", \"RED\"];\r\n\r\n//     const shuffledWords = [...words].sort(() => Math.random() - 0.5);\r\n//     const placeWordsOnGrid = (words: string[], gridSize: number): PlacedWord[] => {\r\n//         while (true) {\r\n//             let placedWords: PlacedWord[] = [];\r\n//             let occupiedPositions = new Set<string>();\r\n//             let placedSet = new Set<string>(); // Set để theo dõi từ đã đặt\r\n//             let allPlaced = true; // Cờ kiểm tra xem tất cả từ có được đặt hay không\r\n\r\n//             const getKey = (x: number, y: number) => `${x},${y}`;\r\n\r\n//             const canPlaceWord = (word: string, x: number, y: number, direction: \"horizontal\" | \"vertical\", index: number) => {\r\n//                 for (let i = 0; i < word.length; i++) {\r\n//                     if (i === x + index) continue;\r\n//                     let newX = direction === \"horizontal\" ? x + i : x;\r\n//                     let newY = direction === \"horizontal\" ? y : y + i;\r\n//                     if (newX < 0 || newY < 0 || newX >= gridSize || newY >= gridSize || occupiedPositions.has(getKey(newX, newY))) {\r\n//                         return false;\r\n//                     }\r\n//                 }\r\n//                 return true;\r\n//             };\r\n\r\n//             const commonLetterPairs = findCommonLetterPairs(words);\r\n//             console.log(commonLetterPairs);\r\n\r\n//             for (const { word1, word2, commonLetters } of commonLetterPairs) {\r\n//                 if (placedSet.has(word1) || placedSet.has(word2)) continue; // Kiểm tra nếu đã đặt thì bỏ qua\r\n\r\n//                 const commonLetter = commonLetters[0];\r\n//                 const index1 = word1.indexOf(commonLetter);\r\n//                 const index2 = word2.indexOf(commonLetter);\r\n\r\n//                 let placed = false;\r\n//                 for (let attempt = 0; attempt < 100; attempt++) {\r\n//                     let x = Math.floor(Math.random() * (gridSize - word1.length)) + 1;\r\n//                     let y = Math.floor(Math.random() * (gridSize - index2) + index2) + 1;\r\n\r\n//                     if (canPlaceWord(word1, x, y, \"horizontal\", index1)) {\r\n//                         placedWords.push({ word: word1, x, y, direction: \"horizontal\" });\r\n//                         placedSet.add(word1);\r\n\r\n//                         let intersecrX = x + index1;\r\n//                         let intersectY = y;\r\n\r\n//                         if (canPlaceWord(word2, intersecrX, intersectY - index2, \"vertical\", index2)) {\r\n//                             for (let i = 0; i < word1.length; i++) occupiedPositions.add(getKey(x + i, y));\r\n//                             placedWords.push({ word: word2, x: intersecrX, y: intersectY - index2, direction: \"vertical\" });\r\n//                             placedSet.add(word2);\r\n\r\n//                             for (let i = 0; i < word2.length; i++) occupiedPositions.add(getKey(intersecrX, intersectY - index2 + i));\r\n\r\n//                             placed = true;\r\n//                             break;\r\n//                         } else {\r\n//                             placedWords.pop();\r\n//                         }\r\n//                     }\r\n//                 }\r\n\r\n//                 if (!placed) {\r\n//                     console.warn(`Không thể đặt cặp từ: ${word1} - ${word2}`);\r\n//                     allPlaced = false;\r\n//                     break;\r\n//                 }\r\n//             }\r\n\r\n\r\n\r\n//             for (const word of words) {\r\n//                 if (placedSet.has(word)) continue;\r\n\r\n//                 let placed = false;\r\n//                 let found = false;\r\n\r\n//                 for (let j = placedWords.length - 1; j >= 0; j--) {\r\n//                     for (let attempt = 0; attempt < 10; attempt++) {\r\n//                         let direction: \"horizontal\" | \"vertical\" = placedWords[j].direction === \"horizontal\" ? \"vertical\" : \"horizontal\";\r\n//                         const shift = Math.random() < 0.5 ? 1 : -1;\r\n//                         let x = placedWords[j].direction === \"horizontal\" ? placedWords[j].word.length + placedWords[j].x : placedWords[j].x + 1;\r\n//                         let y = placedWords[j].direction === \"horizontal\" ? placedWords[j].y + 2 : placedWords[j].word.length + placedWords[j].y;\r\n\r\n//                         if (canPlaceWord(word, x, y, direction, 0)) {\r\n//                             placedWords.push({ word, x, y, direction });\r\n//                             placedSet.add(word);\r\n\r\n//                             for (let i = 0; i < word.length; i++) {\r\n//                                 let newX = direction === \"horizontal\" ? x + i : x;\r\n//                                 let newY = direction === \"horizontal\" ? y : y + i;\r\n//                                 occupiedPositions.add(getKey(newX, newY));\r\n//                             }\r\n\r\n//                             placed = true;\r\n//                             found = true;\r\n//                             break;\r\n//                         }\r\n//                     }\r\n\r\n//                     if (found) break;\r\n//                 }\r\n\r\n//                 if (!placed) {\r\n//                     console.warn(`Không thể đặt từ: ${word}`);\r\n//                     allPlaced = false;\r\n//                     break;\r\n//                 }\r\n//             }\r\n//             if (!allPlaced) continue; // Nếu có từ không đặt được, restart vòng lặp\r\n\r\n//             if (allPlaced) return placedWords; // Nếu tất cả từ đều được đặt, thoát khỏi vòng lặp và trả về kết quả\r\n//         }\r\n//     };\r\n\r\n//     const placedWords = placeWordsOnGrid(shuffledWords, gridSize);\r\n//     console.log(placedWords);\r\n\r\n//     return placedWords;\r\n// };\r\n\r\n\r\n// export const renderGrid = (wordList: string[], mainKeyword:string, GRID_SIZE:number) => {\r\n//     console.log(\"wordList on render\", wordList);\r\n    \r\n//     const maxAttempts = 100;\r\n\r\n//     const generateEmptyGrid = () => {\r\n//         return Array(GRID_SIZE).fill(null).map(() => Array(GRID_SIZE).fill(\"\"));\r\n//     };\r\n\r\n//     const getKey = (x: number, y: number) => `${x},${y}`;\r\n\r\n//     const canPlaceNumber = (x: number, y: number) => {\r\n//         if (x < 0 || y < 0 || x >= GRID_SIZE || y >= GRID_SIZE) return false;\r\n//         return !occupiedPositions.has(getKey(x, y));\r\n//     };\r\n\r\n//     const hasCommonLetter = (word1: string, word2: string) => {\r\n//         return [...new Set(word1)].some((letter) => word2.includes(letter));\r\n//     };\r\n\r\n//     // Try to place words and numbers until a valid configuration is found\r\n//     let attempts = 0;\r\n//     let randomHintWords: HintWord[] = [];\r\n//     let newGrid = generateEmptyGrid();\r\n//     let occupiedPositions = new Set<string>();\r\n//     let occupiedRows = new Set<number>();\r\n//     let occupiedCols = new Set<number>();\r\n\r\n\r\n//     while (attempts < maxAttempts) {\r\n//         randomHintWords = generateHintWords(wordList, GRID_SIZE, mainKeyword);\r\n//         newGrid = generateEmptyGrid();\r\n//         occupiedPositions.clear();\r\n//         occupiedRows.clear();\r\n//         occupiedCols.clear();\r\n\r\n//         let canPlaceAll = true;\r\n\r\n//         // First pass: Place words and mark their positions\r\n//         for (const { word, x, y, direction } of randomHintWords) {\r\n//             if (direction === \"horizontal\") {\r\n//                 occupiedRows.add(y);\r\n//                 // Check for adjacent rows\r\n//                 for (const other of randomHintWords) {\r\n//                     if (other.word === word || other.direction !== \"horizontal\") continue; // Fixed comparison\r\n//                     if (Math.abs(other.y - y) === 1 && !hasCommonLetter(word, other.word)) {\r\n//                         canPlaceAll = false;\r\n//                         break;\r\n//                     }\r\n//                 }\r\n//             } else {\r\n//                 occupiedCols.add(x);\r\n//                 // Check for adjacent columns\r\n//                 for (const other of randomHintWords) {\r\n//                     if (other.word === word || other.direction !== \"vertical\") continue; // Fixed comparison\r\n//                     if (Math.abs(other.x - x) === 1 && !hasCommonLetter(word, other.word)) {\r\n//                         canPlaceAll = false;\r\n//                         break;\r\n//                     }\r\n//                 }\r\n//             }\r\n\r\n//             if (!canPlaceAll) break;\r\n\r\n//             for (let i = 0; i < word.length; i++) {\r\n//                 let newX = direction === \"horizontal\" ? x + i : x;\r\n//                 let newY = direction === \"horizontal\" ? y : y + i;\r\n//                 newGrid[newY][newX] = word[i];\r\n//                 occupiedPositions.add(getKey(newX, newY));\r\n//             }\r\n//         }\r\n\r\n//         if (!canPlaceAll) {\r\n//             attempts++;\r\n//             continue;\r\n//         }\r\n\r\n//         // Second pass: Check if numbers can be placed without overlap\r\n\r\n//         for (const { word, x, y, direction } of randomHintWords) {\r\n//             const wordNumber = wordList.includes(word) ? wordList.indexOf(word) + 1 : -1; // Kiểm tra trước khi lấy số\r\n\r\n//             if (wordNumber === -1) {\r\n//                 console.error(`Không tìm thấy từ ${word} trong wordList`);\r\n//                 continue; // Nếu không tìm thấy, tiếp tục vòng lặp\r\n//             }\r\n\r\n//             if (direction === \"horizontal\" && x > 0) {\r\n//                 if (!canPlaceNumber(x - 1, y)) {\r\n//                     canPlaceAll = false;\r\n//                     break;\r\n//                 }\r\n//             } else if (direction === \"vertical\" && y > 0) {\r\n//                 if (!canPlaceNumber(x, y - 1)) {\r\n//                     canPlaceAll = false;\r\n//                     break;\r\n//                 }\r\n//             }\r\n//         }\r\n\r\n\r\n//         if (canPlaceAll) {\r\n//             // Place numbers if all checks pass\r\n//             randomHintWords.forEach(({ word, x, y, direction }) => {\r\n//                 const wordNumber = wordList.indexOf(word) + 1;\r\n//                 console.log(\"wordList\",wordList)\r\n//                 console.log(\"word\",word);\r\n                \r\n//                 console.log(\"wordNumber\",wordNumber)\r\n//                 let newY = y; // Tạo biến mới để lưu trữ vị trí x đã điều chỉnh\r\n\r\n//                 // Kiểm tra nếu ô bên trái đã bị chiếm, thì dịch sang phải\r\n//                 if (newGrid[x][y-1] !== '') {\r\n//                     newY = y + 1; // Dịch sang phải 1 đơn vị\r\n                    \r\n//                     // Nếu là horizontal, cần kiểm tra toàn bộ các ô của word và dịch chúng\r\n//                     if (direction === \"horizontal\") {\r\n//                         // Kiểm tra xem sau khi dịch có đủ không gian không\r\n//                         if (newY + word.length > newGrid[0].length) {\r\n//                             // Có thể cần xử lý trường hợp vượt quá kích thước grid\r\n//                             console.error(\"Không dịch được sang phải\")\r\n//                             return;\r\n//                         }\r\n//                         // Cập nhật các ô của word ở vị trí mới\r\n//                         for (let i = 0; i < word.length; i++) {\r\n//                             newGrid[x][newY+i] = word[i];\r\n//                             occupiedPositions.add(getKey(x, newY+i));\r\n//                         }\r\n\r\n//                         occupiedPositions.delete(getKey(x,y))\r\n//                         newGrid[x][y] = \"\"\r\n//                     }\r\n//                 }\r\n//                 if (direction === \"horizontal\" && x > 0) {\r\n//                     newGrid[y][x - 1] = `number${wordNumber.toString()}`;\r\n//                     occupiedPositions.add(getKey(x - 1, y));\r\n//                 } else if (direction === \"vertical\" && y > 0) {\r\n//                     newGrid[y - 1][x] = `number${wordNumber.toString()}`;\r\n//                     occupiedPositions.add(getKey(x, y - 1));\r\n//                 }\r\n//             });\r\n\r\n\r\n//             break; // Valid configuration found, exit loop\r\n//         }\r\n\r\n//         attempts++;\r\n//     }\r\n\r\n//     if (attempts >= maxAttempts) {\r\n//         console.warn(\"Could not find a valid grid configuration without overlapping numbers or adjacent non-shared words after max attempts.\");\r\n//     }\r\n\r\n//     return {randomHintWords, newGrid}\r\n// }\r\n\r\n// interface Word {\r\n//     string: string;\r\n//     char: string[];\r\n//     index: number;\r\n//     successfulMatches: Match[];\r\n//     totalMatches: number;\r\n//     effectiveMatches: number;\r\n//     x?: number;\r\n//     y?: number;\r\n//     dir?: number;\r\n//   }\r\n  \r\n//   interface Match {\r\n//     x: number;\r\n//     y: number;\r\n//     dir: number;\r\n//   }\r\n  \r\n//   interface Bounds {\r\n//     minX: number;\r\n//     maxX: number;\r\n//     minY: number;\r\n//     maxY: number;\r\n//     update: (x: number, y: number) => void;\r\n//   }\r\n  \r\n//   interface CrosswordResult {\r\n//     board: (string | null)[][];\r\n//     wordsActive: Word[];\r\n//     success: boolean;\r\n//     message?: string;\r\n//   }\r\n  \r\n//   export function generateCrossword(wordList: string[], board: (string | null)[][]): CrosswordResult {\r\n//     // Kiểm tra đầu vào\r\n//     if (!Array.isArray(wordList) || wordList.length !== 6 || !wordList.every(w => typeof w === 'string')) {\r\n//       return { board: [], wordsActive: [], success: false, message: 'wordList must be an array of 6 strings' };\r\n//     }\r\n//     if (!Array.isArray(board) || board.length === 0 || board[0].length !== 20) {\r\n//       board = Array.from({ length: 20 }, () => Array(20).fill(null)) as (string | null)[][];\r\n//     }\r\n  \r\n//     // Khởi tạo cấu trúc dữ liệu\r\n//     const wordsActive: Word[] = [];\r\n//     const wordBank: Word[] = wordList.map((word, idx) => ({\r\n//       string: word.toUpperCase(),\r\n//       char: word.toUpperCase().split(''),\r\n//       index: idx,\r\n//       successfulMatches: [],\r\n//       totalMatches: 0,\r\n//       effectiveMatches: 0\r\n//     }));\r\n//     const bounds: Bounds = {\r\n//       minX: 0,\r\n//       maxX: 0,\r\n//       minY: 0,\r\n//       maxY: 0,\r\n//       update: function(x: number, y: number) {\r\n//         this.minX = Math.min(this.minX, x);\r\n//         this.maxX = Math.max(this.maxX, x);\r\n//         this.minY = Math.min(this.minY, y);\r\n//         this.maxY = Math.max(this.maxY, y);\r\n//       }\r\n//     };\r\n  \r\n//     // Hàm kiểm tra xem ô có hợp lệ để đặt ký tự không\r\n//     function isValidPosition(x: number, y: number, char: string, board: (string | null)[][], dir: number, word: Word, i: number): boolean {\r\n//       if (x < 0 || x >= board.length || y < 0 || y >= board[0].length) return false;\r\n//       if (board[x][y] === null) return true;\r\n//       if (board[x][y] === char) {\r\n//         // Kiểm tra xung đột với từ khác tại giao điểm\r\n//         const crossDir = dir === 0 ? 1 : 0;\r\n//         const crossVal = [\r\n//           crossDir === 0 ? (x > 0 ? board[x-1][y] : null) : (y > 0 ? board[x][y-1] : null),\r\n//           board[x][y],\r\n//           crossDir === 0 ? (x < board.length-1 ? board[x+1][y] : null) : (y < board[0].length-1 ? board[x][y+1] : null)\r\n//         ];\r\n//         return crossVal[0] === null && crossVal[2] === null && board[x][y] === char;\r\n//       }\r\n//       return false;\r\n//     }\r\n  \r\n//     // Hàm mở rộng bảng nếu cần\r\n//     function expandBoard(board: (string | null)[][], x: number, y: number): void {\r\n//       while (x >= board.length) {\r\n//         board.push(Array(board[0].length).fill(null));\r\n//       }\r\n//       while (y >= board[0].length) {\r\n//         for (let i = 0; i < board.length; i++) {\r\n//           board[i].push(null);\r\n//         }\r\n//       }\r\n//     }\r\n  \r\n//     // Hàm tìm các vị trí giao nhau hợp lệ cho một từ\r\n//     function findMatches(word: Word, board: (string | null)[][], wordsActive: Word[]): void {\r\n//       word.successfulMatches = [];\r\n//       word.totalMatches = 0;\r\n//       word.effectiveMatches = 0;\r\n  \r\n//       if (wordsActive.length === 0) {\r\n//         // Nếu bảng rỗng, đặt từ đầu tiên ở giữa\r\n//         const x = Math.floor(board.length / 2);\r\n//         const y = Math.floor(board[0].length / 2);\r\n//         const dir = Math.random() < 0.5 ? 0 : 1;\r\n//         word.successfulMatches.push({ x, y, dir });\r\n//         word.totalMatches = 1;\r\n//         word.effectiveMatches = 1;\r\n//         return;\r\n//       }\r\n  \r\n//       for (const placedWord of wordsActive) {\r\n//         for (let i = 0; i < word.char.length; i++) {\r\n//           for (let k = 0; k < placedWord.char.length; k++) {\r\n//             if (word.char[i] === placedWord.char[k]) {\r\n//               word.totalMatches++;\r\n//               // Thử đặt từ theo hướng ngang (dir=0) và dọc (dir=1)\r\n//               for (let dir = 0; dir <= 1; dir++) {\r\n//                 const x = dir === 0 ? placedWord.x! + k - i : placedWord.x! + k;\r\n//                 const y = dir === 0 ? placedWord.y! : placedWord.y! - i;\r\n//                 let isValid = true;\r\n//                 // Kiểm tra toàn bộ từ có thể đặt được không\r\n//                 for (let m = 0; m < word.char.length; m++) {\r\n//                   const xPos = dir === 0 ? x + m : x;\r\n//                   const yPos = dir === 0 ? y : y + m;\r\n//                   expandBoard(board, xPos, yPos);\r\n//                   if (!isValidPosition(xPos, yPos, word.char[m], board, dir, word, m)) {\r\n//                     isValid = false;\r\n//                     break;\r\n//                   }\r\n//                 }\r\n//                 if (isValid) {\r\n//                   word.successfulMatches.push({ x, y, dir });\r\n//                   word.effectiveMatches++;\r\n//                 }\r\n//               }\r\n//             }\r\n//           }\r\n//         }\r\n//       }\r\n//     }\r\n  \r\n//     // Hàm đặt từ lên bảng\r\n//     function placeWord(word: Word, board: (string | null)[][], wordsActive: Word[]): boolean {\r\n//       if (word.successfulMatches.length === 0) return false;\r\n  \r\n//       // Chọn ngẫu nhiên một vị trí giao nhau hợp lệ\r\n//       const matchIndex = Math.floor(Math.random() * word.successfulMatches.length);\r\n//       const matchData = word.successfulMatches[matchIndex];\r\n  \r\n//       // Cập nhật thông tin từ\r\n//       word.x = matchData.x;\r\n//       word.y = matchData.y;\r\n//       word.dir = matchData.dir;\r\n  \r\n//       // Đặt từng ký tự lên bảng\r\n//       for (let i = 0; i < word.char.length; i++) {\r\n//         const xIndex = matchData.dir === 0 ? matchData.x + i : matchData.x;\r\n//         const yIndex = matchData.dir === 0 ? matchData.y : matchData.y + i;\r\n//         expandBoard(board, xIndex, yIndex);\r\n//         board[xIndex][yIndex] = word.char[i];\r\n//         bounds.update(xIndex, yIndex);\r\n//       }\r\n  \r\n//       wordsActive.push(word);\r\n//       return true;\r\n//     }\r\n  \r\n//     // Hàm chính để đặt tất cả từ\r\n//     while (wordBank.length > 0) {\r\n//       let minMatchDiff = Infinity;\r\n//       let curIndex = -1;\r\n  \r\n//       // Tìm từ tốt nhất để đặt\r\n//       for (let i = 0; i < wordBank.length; i++) {\r\n//         const curWord = wordBank[i];\r\n//         findMatches(curWord, board, wordsActive);\r\n//         const curMatchDiff = curWord.totalMatches - curWord.effectiveMatches;\r\n//         if (curMatchDiff < minMatchDiff && curWord.successfulMatches.length > 0) {\r\n//           minMatchDiff = curMatchDiff;\r\n//           curIndex = i;\r\n//         }\r\n//       }\r\n  \r\n//       if (curIndex === -1) {\r\n//         return { board, wordsActive, success: false, message: 'Failed to place all words' };\r\n//       }\r\n  \r\n//       // Đặt từ và loại khỏi wordBank\r\n//       const wordToPlace = wordBank.splice(curIndex, 1)[0];\r\n//       if (!placeWord(wordToPlace, board, wordsActive)) {\r\n//         return { board, wordsActive, success: false, message: 'Failed to place word' };\r\n//       }\r\n//     }\r\n  \r\n//     // Cắt bảng theo bounds để trả về kích thước tối thiểu\r\n//     const trimmedBoard: (string | null)[][] = [];\r\n//     for (let x = bounds.minX; x <= bounds.maxX; x++) {\r\n//       const row = board[x].slice(bounds.minY, bounds.maxY + 1);\r\n//       trimmedBoard.push(row);\r\n//     }\r\n  \r\n//     return { board: trimmedBoard, wordsActive, success: true };\r\n//   }\r\n  \r\n// //   // Ví dụ sử dụng\r\n// //   const wordList: string[] = ['CROSSWORD', 'PUZZLE', 'GRID', 'WORD', 'CLUE', 'GAME'];\r\n// //   const board: (string | null)[][] = Array.from({ length: 20 }, () => Array(20).fill(null));\r\n// //   const result: CrosswordResult = generateCrossword(wordList, board);\r\n// //   console.log('Success:', result.success);\r\n// //   console.log('Words Active:', result.wordsActive);\r\n// //   console.log('Board:');\r\n// //   result.board.forEach(row => console.log(row.map(c => c || '.').join(' ')));\r\n\r\n\r\n// // function AddWordToBoard(){\r\n    \r\n// //     var i, len, curIndex, curWord, curChar, curMatch, testWord, testChar,\r\n// //         minMatchDiff = 9999, curMatchDiff;\r\n\r\n// //     if(wordsActive.length < 1){\r\n// //       curIndex = 0;\r\n// //       for(i = 0, len = wordBank.length; i < len; i++){\r\n// //         if (wordBank[i].totalMatches < wordBank[curIndex].totalMatches){\r\n// //           curIndex = i;\r\n// //         }\r\n// //       }\r\n// //       wordBank[curIndex].successfulMatches = [{x:12,y:12,dir:0}];\r\n// //     }\r\n// //     else{\r\n// //       curIndex = -1;\r\n\r\n// //       for(i = 0, len = wordBank.length; i < len; i++){\r\n// //         curWord = wordBank[i];\r\n// //         curWord.effectiveMatches = 0;\r\n// //         curWord.successfulMatches = [];\r\n// //         for(var j = 0, lenJ = curWord.char.length; j < lenJ; j++){\r\n// //           if(j == 1) continue; // skip pos\r\n// //           curChar = curWord.char[j];\r\n// //           for (var k = 0, lenK = wordsActive.length; k < lenK; k++){\r\n// //             testWord = wordsActive[k];\r\n// //             for (var l = 0, lenL = testWord.char.length; l < lenL; l++){\r\n// //               if(l == 1) continue; // skip pos\r\n// //               testChar = testWord.char[l];\r\n// //               if (curChar === testChar){\r\n// //                 curWord.effectiveMatches++;\r\n\r\n// //                 var curCross = {x:testWord.x,y:testWord.y,dir:0};\r\n// //                 if(testWord.dir === 0){\r\n// //                   curCross.dir = 1;\r\n// //                   curCross.x += l;\r\n// //                   curCross.y -= j;\r\n// //                 }\r\n// //                 else{\r\n// //                   curCross.dir = 0;\r\n// //                   curCross.y += l;\r\n// //                   curCross.x -= j;\r\n// //                 }\r\n\r\n// //                 var isMatch = true;\r\n\r\n// //                 for(var m = -1, lenM = curWord.char.length + 1; m < lenM; m++){\r\n// //                   var crossVal = [];\r\n// //                   if (m !== j){\r\n// //                     if (curCross.dir === 0){\r\n// //                       var xIndex = curCross.x + m;\r\n\r\n// //                       if (xIndex < 0 || xIndex > board.length){\r\n// //                         isMatch = false;\r\n// //                         break;\r\n// //                       }\r\n\r\n// //                       crossVal.push(board[xIndex][curCross.y]);\r\n// //                       crossVal.push(board[xIndex][curCross.y + 1]);\r\n// //                       crossVal.push(board[xIndex][curCross.y - 1]);\r\n// //                     }\r\n// //                     else{\r\n// //                       var yIndex = curCross.y + m;\r\n\r\n// //                       if (yIndex < 0 || yIndex > board[curCross.x].length){\r\n// //                         isMatch = false;\r\n// //                         break;\r\n// //                       }\r\n\r\n// //                       crossVal.push(board[curCross.x][yIndex]);\r\n// //                       crossVal.push(board[curCross.x + 1][yIndex]);\r\n// //                       crossVal.push(board[curCross.x - 1][yIndex]);\r\n// //                     }\r\n\r\n// //                     if(m > -1 && m < lenM-1){\r\n// //                       if (crossVal[0] !== curWord.char[m]){\r\n// //                         if (crossVal[0] !== null){\r\n// //                           isMatch = false;\r\n// //                           break;\r\n// //                         }\r\n// //                         else if (crossVal[1] !== null){\r\n// //                           isMatch = false;\r\n// //                           break;\r\n// //                         }\r\n// //                         else if (crossVal[2] !== null){\r\n// //                           isMatch = false;\r\n// //                           break;\r\n// //                         }\r\n// //                       }\r\n// //                     }\r\n// //                     else if (crossVal[0] !== null){\r\n// //                       isMatch = false;\r\n// //                       break;\r\n// //                     }\r\n// //                   }\r\n// //                 }\r\n\r\n// //                 if (isMatch === true){\r\n// //                   curWord.successfulMatches.push(curCross);\r\n// //                 }\r\n// //               }\r\n// //             }\r\n// //           }\r\n// //         }\r\n\r\n// //         curMatchDiff = curWord.totalMatches - curWord.effectiveMatches;\r\n\r\n// //         if (curMatchDiff<minMatchDiff && curWord.successfulMatches.length>0){\r\n// //           curMatchDiff = minMatchDiff;\r\n// //           curIndex = i;\r\n// //         }\r\n// //         else if (curMatchDiff <= 0){\r\n// //           return false;\r\n// //         }\r\n// //       }\r\n// //     }\r\n\r\n// //     if (curIndex === -1){\r\n// //       return false;\r\n// //     }\r\n\r\n// //     var spliced = wordBank.splice(curIndex, 1);\r\n// //     wordsActive.push(spliced[0]);\r\n\r\n// //     var pushIndex = wordsActive.length - 1,\r\n// //         rand = Math.random(),\r\n// //         matchArr = wordsActive[pushIndex].successfulMatches,\r\n// //         matchIndex = Math.floor(rand * matchArr.length),\r\n// //         matchData = matchArr[matchIndex];\r\n\r\n// //     wordsActive[pushIndex].x = matchData.x;\r\n// //     wordsActive[pushIndex].y = matchData.y;\r\n// //     wordsActive[pushIndex].dir = matchData.dir;\r\n\r\n// //     let actualIndex = findWordIdx(wordsActive[pushIndex].string);\r\n// //     console.log(wordsActive[pushIndex].string, \" ~~~ \", actualIndex);\r\n// //     for(i = 0, len = wordsActive[pushIndex].char.length; i < len; i++){\r\n// //       var xIndex = matchData.x,\r\n// //           yIndex = matchData.y;\r\n\r\n// //       if (matchData.dir === 0){\r\n// //         xIndex += i;\r\n// //       }\r\n// //       else{\r\n// //         yIndex += i;\r\n// //       }\r\n// //       board[xIndex][yIndex] = wordsActive[pushIndex].char[i];\r\n// //       isPos[xIndex][yIndex] = (i == 1);\r\n// //       classesOfBoard[xIndex][yIndex].push(actualIndex);\r\n// //       console.log(xIndex, yIndex, classesOfBoard[xIndex][yIndex]);\r\n\r\n// //       Bounds.Update(xIndex,yIndex);\r\n// //     }\r\n\r\n// //     return true;\r\n// //   }"],"mappings":"AAAA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAGA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAIA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAIA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAGA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAGA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAGA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAGA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}