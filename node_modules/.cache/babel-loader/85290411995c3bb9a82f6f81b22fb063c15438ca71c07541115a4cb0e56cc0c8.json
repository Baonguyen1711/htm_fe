{"ast":null,"code":"var _jsxFileName = \"C:\\\\Users\\\\ASUS\\\\Documents\\\\htm_fe\\\\src\\\\pages\\\\Host\\\\Management\\\\HostRound2.tsx\";\nimport React from \"react\";\n\n// Define word object structure\nimport { jsxDEV as _jsxDEV, Fragment as _Fragment } from \"react/jsx-dev-runtime\";\nconst CrosswordGrid = ({\n  placedWords,\n  boardSize = 25\n}) => {\n  // Initialize board\n  const board = Array.from({\n    length: boardSize\n  }, () => Array(boardSize).fill(null));\n\n  // Place words\n  for (const {\n    word,\n    x,\n    y,\n    direction\n  } of placedWords) {\n    for (let i = 0; i < word.length; i++) {\n      const char = word[i];\n      const dx = direction === \"horizontal\" ? i : 0;\n      const dy = direction === \"vertical\" ? i : 0;\n      const row = y + dy;\n      const col = x + dx;\n      if (row >= 0 && row < boardSize && col >= 0 && col < boardSize) {\n        board[row][col] = char;\n      }\n    }\n  }\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    className: \"grid bg-gray-500\",\n    style: {\n      gridTemplateColumns: `repeat(${boardSize}, 1.75rem)`,\n      gridAutoRows: \"1.75rem\"\n    },\n    children: board.flatMap((row, rowIndex) => row.map((char, colIndex) => /*#__PURE__*/_jsxDEV(\"div\", {\n      className: `w-7 h-7 text-sm flex items-center justify-center font-bold border border-gray-300 ${char ? \"bg-yellow-100 text-black\" : \"bg-white\"}`,\n      children: char\n    }, `${rowIndex}-${colIndex}`, false, {\n      fileName: _jsxFileName,\n      lineNumber: 47,\n      columnNumber: 11\n    }, this)))\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 38,\n    columnNumber: 5\n  }, this);\n};\n_c = CrosswordGrid;\nexport default CrosswordGrid;\n\n// Main React Component\nconst WordBoard = () => {\n  // TypeScript version of the crossword builder with shuffled letter matches\n\n  class WordObj {\n    constructor(word) {\n      this.string = void 0;\n      this.char = void 0;\n      this.totalMatches = 0;\n      this.effectiveMatches = 0;\n      this.successfulMatches = [];\n      this.x = 0;\n      this.y = 0;\n      this.dir = 0;\n      this.string = word;\n      this.char = word.split('');\n    }\n  }\n  function shuffleArray(array) {\n    const arr = [...array];\n    for (let i = arr.length - 1; i > 0; i--) {\n      const j = Math.floor(Math.random() * (i + 1));\n      [arr[i], arr[j]] = [arr[j], arr[i]];\n    }\n    return arr;\n  }\n  function generateCrossword(words) {\n    const boardSize = 20;\n    const board = Array.from({\n      length: boardSize\n    }, () => Array(boardSize).fill(null));\n    const wordObjs = words.map((word, i) => new WordObj(` ${i + 1}${word} `));\n    const placedWords = [];\n\n    // Calculate totalMatches\n    for (let i = 0; i < wordObjs.length; i++) {\n      for (let j = 0; j < wordObjs[i].char.length; j++) {\n        for (let k = 0; k < wordObjs.length; k++) {\n          if (k === i) continue;\n          for (let l = 0; l < wordObjs[k].char.length; l++) {\n            if (wordObjs[i].char[j] === wordObjs[k].char[l]) {\n              wordObjs[i].totalMatches++;\n            }\n          }\n        }\n      }\n    }\n    function canPlaceWord(word, x, y, dir) {\n      for (let i = 0; i < word.char.length; i++) {\n        const xi = dir === 0 ? x + i : x;\n        const yi = dir === 1 ? y + i : y;\n        if (xi < 0 || xi >= boardSize || yi < 0 || yi >= boardSize) return false;\n        if (board[xi][yi] && board[xi][yi] !== word.char[i]) return false;\n      }\n      return true;\n    }\n    function placeWord(word, x, y, dir) {\n      for (let i = 0; i < word.char.length; i++) {\n        const xi = dir === 0 ? x + i : x;\n        const yi = dir === 1 ? y + i : y;\n        board[xi][yi] = word.char[i];\n      }\n      word.x = x;\n      word.y = y;\n      word.dir = dir;\n      placedWords.push(word);\n    }\n    function addWordToBoard() {\n      if (placedWords.length === 0) {\n        // Place the word with fewest totalMatches in center\n        let idx = 0;\n        for (let i = 1; i < wordObjs.length; i++) {\n          if (wordObjs[i].totalMatches < wordObjs[idx].totalMatches) idx = i;\n        }\n        const word = wordObjs.splice(idx, 1)[0];\n        placeWord(word, Math.floor(boardSize / 2), Math.floor(boardSize / 2), 0);\n        return true;\n      }\n      let selectedIdx = -1;\n      let minDiff = Infinity;\n      for (let i = 0; i < wordObjs.length; i++) {\n        const word = wordObjs[i];\n        word.effectiveMatches = 0;\n        word.successfulMatches = [];\n        for (const j of shuffleArray([...Array(word.char.length).keys()])) {\n          const curChar = word.char[j];\n          for (const existing of placedWords) {\n            for (const l of shuffleArray([...Array(existing.char.length).keys()])) {\n              const testChar = existing.char[l];\n              if (curChar === testChar) {\n                word.effectiveMatches++;\n                const cross = {\n                  x: existing.x,\n                  y: existing.y,\n                  dir: 0\n                };\n                if (existing.dir === 0) {\n                  cross.dir = 1;\n                  cross.x += l;\n                  cross.y -= j;\n                } else {\n                  cross.dir = 0;\n                  cross.y += l;\n                  cross.x -= j;\n                }\n                if (canPlaceWord(word, cross.x, cross.y, cross.dir)) {\n                  word.successfulMatches.push(cross);\n                }\n              }\n            }\n          }\n        }\n        const diff = word.totalMatches - word.effectiveMatches;\n        if (diff < minDiff && word.successfulMatches.length > 0) {\n          minDiff = diff;\n          selectedIdx = i;\n        }\n      }\n      if (selectedIdx === -1) return false;\n      const selectedWord = wordObjs.splice(selectedIdx, 1)[0];\n      const shuffledMatches = shuffleArray(selectedWord.successfulMatches);\n      const chosen = shuffledMatches[0];\n      placeWord(selectedWord, chosen.x, chosen.y, chosen.dir);\n      return true;\n    }\n    while (wordObjs.length > 0 && addWordToBoard());\n    return placedWords.map(w => ({\n      word: w.string.trim().substring(w.string.indexOf(w.char[1])),\n      x: w.x,\n      y: w.y,\n      direction: w.dir === 0 ? 'horizontal' : 'vertical'\n    }));\n  }\n\n  // Example usage:\n  const result = generateCrossword(['GIÓ', 'HẠT GIỐNG', 'DREAM', 'THUỐC', 'CÚC', 'CHÂU KIỆT LUÂN']);\n  console.log(result);\n  return /*#__PURE__*/_jsxDEV(_Fragment, {}, void 0, false);\n};\n_c2 = WordBoard;\nexport default WordBoard;\nvar _c, _c2;\n$RefreshReg$(_c, \"CrosswordGrid\");\n$RefreshReg$(_c2, \"WordBoard\");","map":{"version":3,"names":["React","jsxDEV","_jsxDEV","Fragment","_Fragment","CrosswordGrid","placedWords","boardSize","board","Array","from","length","fill","word","x","y","direction","i","char","dx","dy","row","col","className","style","gridTemplateColumns","gridAutoRows","children","flatMap","rowIndex","map","colIndex","fileName","_jsxFileName","lineNumber","columnNumber","_c","WordBoard","WordObj","constructor","string","totalMatches","effectiveMatches","successfulMatches","dir","split","shuffleArray","array","arr","j","Math","floor","random","generateCrossword","words","wordObjs","k","l","canPlaceWord","xi","yi","placeWord","push","addWordToBoard","idx","splice","selectedIdx","minDiff","Infinity","keys","curChar","existing","testChar","cross","diff","selectedWord","shuffledMatches","chosen","w","trim","substring","indexOf","result","console","log","_c2","$RefreshReg$"],"sources":["C:/Users/ASUS/Documents/htm_fe/src/pages/Host/Management/HostRound2.tsx"],"sourcesContent":["import React, { useState, useEffect } from \"react\";\r\n\r\n// Define word object structure\r\n\r\ntype WordPlacement = {\r\n  word: string;\r\n  x: number;\r\n  y: number;\r\n  direction: \"horizontal\" | \"vertical\";\r\n};\r\n\r\ninterface CrosswordGridProps {\r\n  placedWords: WordPlacement[];\r\n  boardSize?: number;\r\n}\r\n\r\nconst CrosswordGrid: React.FC<CrosswordGridProps> = ({ placedWords, boardSize = 25 }) => {\r\n  // Initialize board\r\n  const board: (string | null)[][] = Array.from({ length: boardSize }, () =>\r\n    Array(boardSize).fill(null)\r\n  );\r\n\r\n  // Place words\r\n  for (const { word, x, y, direction } of placedWords) {\r\n    for (let i = 0; i < word.length; i++) {\r\n      const char = word[i];\r\n      const dx = direction === \"horizontal\" ? i : 0;\r\n      const dy = direction === \"vertical\" ? i : 0;\r\n      const row = y + dy;\r\n      const col = x + dx;\r\n      if (row >= 0 && row < boardSize && col >= 0 && col < boardSize) {\r\n        board[row][col] = char;\r\n      }\r\n    }\r\n  }\r\n\r\n  return (\r\n    <div\r\n      className=\"grid bg-gray-500\"\r\n      style={{\r\n        gridTemplateColumns: `repeat(${boardSize}, 1.75rem)`,\r\n        gridAutoRows: \"1.75rem\",\r\n      }}\r\n    >\r\n      {board.flatMap((row, rowIndex) =>\r\n        row.map((char, colIndex) => (\r\n          <div\r\n            key={`${rowIndex}-${colIndex}`}\r\n            className={`w-7 h-7 text-sm flex items-center justify-center font-bold border border-gray-300 ${\r\n              char ? \"bg-yellow-100 text-black\" : \"bg-white\"\r\n            }`}\r\n          >\r\n            {char}\r\n          </div>\r\n        ))\r\n      )}\r\n    </div>\r\n  );\r\n};\r\n\r\nexport default CrosswordGrid;\r\n\r\n\r\n// Main React Component\r\nconst WordBoard: React.FC = () => {\r\n  // TypeScript version of the crossword builder with shuffled letter matches\r\n\r\n  type Direction = 'horizontal' | 'vertical';\r\n\r\n  interface PlacedWord {\r\n    word: string;\r\n    x: number;\r\n    y: number;\r\n    direction: Direction;\r\n  }\r\n\r\n  class WordObj {\r\n    string: string;\r\n    char: string[];\r\n    totalMatches: number = 0;\r\n    effectiveMatches: number = 0;\r\n    successfulMatches: { x: number; y: number; dir: number }[] = [];\r\n    x: number = 0;\r\n    y: number = 0;\r\n    dir: number = 0;\r\n\r\n    constructor(word: string) {\r\n      this.string = word;\r\n      this.char = word.split('');\r\n    }\r\n  }\r\n\r\n  function shuffleArray<T>(array: T[]): T[] {\r\n    const arr = [...array];\r\n    for (let i = arr.length - 1; i > 0; i--) {\r\n      const j = Math.floor(Math.random() * (i + 1));\r\n      [arr[i], arr[j]] = [arr[j], arr[i]];\r\n    }\r\n    return arr;\r\n  }\r\n\r\n  function generateCrossword(words: string[]): PlacedWord[] {\r\n    const boardSize = 20;\r\n    const board: (string | null)[][] = Array.from({ length: boardSize }, () => Array(boardSize).fill(null));\r\n    const wordObjs: WordObj[] = words.map((word, i) => new WordObj(` ${i + 1}${word} `));\r\n    const placedWords: WordObj[] = [];\r\n\r\n    // Calculate totalMatches\r\n    for (let i = 0; i < wordObjs.length; i++) {\r\n      for (let j = 0; j < wordObjs[i].char.length; j++) {\r\n        for (let k = 0; k < wordObjs.length; k++) {\r\n          if (k === i) continue;\r\n          for (let l = 0; l < wordObjs[k].char.length; l++) {\r\n            if (wordObjs[i].char[j] === wordObjs[k].char[l]) {\r\n              wordObjs[i].totalMatches++;\r\n            }\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    function canPlaceWord(word: WordObj, x: number, y: number, dir: number): boolean {\r\n      for (let i = 0; i < word.char.length; i++) {\r\n        const xi = dir === 0 ? x + i : x;\r\n        const yi = dir === 1 ? y + i : y;\r\n\r\n        if (xi < 0 || xi >= boardSize || yi < 0 || yi >= boardSize) return false;\r\n        if (board[xi][yi] && board[xi][yi] !== word.char[i]) return false;\r\n      }\r\n      return true;\r\n    }\r\n\r\n    function placeWord(word: WordObj, x: number, y: number, dir: number) {\r\n      for (let i = 0; i < word.char.length; i++) {\r\n        const xi = dir === 0 ? x + i : x;\r\n        const yi = dir === 1 ? y + i : y;\r\n        board[xi][yi] = word.char[i];\r\n      }\r\n      word.x = x;\r\n      word.y = y;\r\n      word.dir = dir;\r\n      placedWords.push(word);\r\n    }\r\n\r\n    function addWordToBoard(): boolean {\r\n      if (placedWords.length === 0) {\r\n        // Place the word with fewest totalMatches in center\r\n        let idx = 0;\r\n        for (let i = 1; i < wordObjs.length; i++) {\r\n          if (wordObjs[i].totalMatches < wordObjs[idx].totalMatches) idx = i;\r\n        }\r\n        const word = wordObjs.splice(idx, 1)[0];\r\n        placeWord(word, Math.floor(boardSize / 2), Math.floor(boardSize / 2), 0);\r\n        return true;\r\n      }\r\n\r\n      let selectedIdx = -1;\r\n      let minDiff = Infinity;\r\n\r\n      for (let i = 0; i < wordObjs.length; i++) {\r\n        const word = wordObjs[i];\r\n        word.effectiveMatches = 0;\r\n        word.successfulMatches = [];\r\n\r\n        for (const j of shuffleArray([...Array(word.char.length).keys()])) {\r\n          const curChar = word.char[j];\r\n          for (const existing of placedWords) {\r\n            for (const l of shuffleArray([...Array(existing.char.length).keys()])) {\r\n              const testChar = existing.char[l];\r\n              if (curChar === testChar) {\r\n                word.effectiveMatches++;\r\n\r\n                const cross = { x: existing.x, y: existing.y, dir: 0 };\r\n                if (existing.dir === 0) {\r\n                  cross.dir = 1;\r\n                  cross.x += l;\r\n                  cross.y -= j;\r\n                } else {\r\n                  cross.dir = 0;\r\n                  cross.y += l;\r\n                  cross.x -= j;\r\n                }\r\n\r\n                if (canPlaceWord(word, cross.x, cross.y, cross.dir)) {\r\n                  word.successfulMatches.push(cross);\r\n                }\r\n              }\r\n            }\r\n          }\r\n        }\r\n\r\n        const diff = word.totalMatches - word.effectiveMatches;\r\n        if (diff < minDiff && word.successfulMatches.length > 0) {\r\n          minDiff = diff;\r\n          selectedIdx = i;\r\n        }\r\n      }\r\n\r\n      if (selectedIdx === -1) return false;\r\n\r\n      const selectedWord = wordObjs.splice(selectedIdx, 1)[0];\r\n      const shuffledMatches = shuffleArray(selectedWord.successfulMatches);\r\n      const chosen = shuffledMatches[0];\r\n      placeWord(selectedWord, chosen.x, chosen.y, chosen.dir);\r\n      return true;\r\n    }\r\n\r\n    while (wordObjs.length > 0 && addWordToBoard());\r\n\r\n    return placedWords.map(w => ({\r\n      word: w.string.trim().substring(w.string.indexOf(w.char[1])),\r\n      x: w.x,\r\n      y: w.y,\r\n      direction: w.dir === 0 ? 'horizontal' : 'vertical'\r\n    }));\r\n  }\r\n\r\n\r\n  // Example usage:\r\n  const result = generateCrossword([\r\n    'GIÓ',\r\n    'HẠT GIỐNG',\r\n    'DREAM',\r\n    'THUỐC',\r\n    'CÚC',\r\n    'CHÂU KIỆT LUÂN',\r\n  ]);\r\n  console.log(result);\r\n\r\n  return (\r\n    <>\r\n    </>\r\n  );\r\n};\r\n\r\nexport default WordBoard;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}