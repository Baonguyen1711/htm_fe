{"ast":null,"code":"import React from \"react\";\n\n// Define word object structure\n\n// Main React Component\nimport { Fragment as _Fragment, jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst WordBoard = () => {\n  // TypeScript version of the crossword builder with shuffled letter matches\n\n  class WordObj {\n    constructor(word) {\n      this.string = void 0;\n      this.char = void 0;\n      this.totalMatches = 0;\n      this.effectiveMatches = 0;\n      this.successfulMatches = [];\n      this.x = 0;\n      this.y = 0;\n      this.dir = 0;\n      this.string = word;\n      this.char = word.split('');\n    }\n  }\n  function shuffleArray(array) {\n    const arr = [...array];\n    for (let i = arr.length - 1; i > 0; i--) {\n      const j = Math.floor(Math.random() * (i + 1));\n      [arr[i], arr[j]] = [arr[j], arr[i]];\n    }\n    return arr;\n  }\n  function generateCrossword(words) {\n    const boardSize = 20;\n    const board = Array.from({\n      length: boardSize\n    }, () => Array(boardSize).fill(null));\n    const wordObjs = words.map((word, i) => new WordObj(` ${i + 1}${word} `));\n    const placedWords = [];\n\n    // Calculate totalMatches\n    for (let i = 0; i < wordObjs.length; i++) {\n      for (let j = 0; j < wordObjs[i].char.length; j++) {\n        for (let k = 0; k < wordObjs.length; k++) {\n          if (k === i) continue;\n          for (let l = 0; l < wordObjs[k].char.length; l++) {\n            if (wordObjs[i].char[j] === wordObjs[k].char[l]) {\n              wordObjs[i].totalMatches++;\n            }\n          }\n        }\n      }\n    }\n    function canPlaceWord(word, x, y, dir) {\n      for (let i = 0; i < word.char.length; i++) {\n        const xi = dir === 0 ? x + i : x;\n        const yi = dir === 1 ? y + i : y;\n        if (xi < 0 || xi >= boardSize || yi < 0 || yi >= boardSize) return false;\n        if (board[xi][yi] && board[xi][yi] !== word.char[i]) return false;\n      }\n      return true;\n    }\n    function placeWord(word, x, y, dir) {\n      for (let i = 0; i < word.char.length; i++) {\n        const xi = dir === 0 ? x + i : x;\n        const yi = dir === 1 ? y + i : y;\n        board[xi][yi] = word.char[i];\n      }\n      word.x = x;\n      word.y = y;\n      word.dir = dir;\n      placedWords.push(word);\n    }\n    function addWordToBoard() {\n      if (placedWords.length === 0) {\n        // Place the word with fewest totalMatches in center\n        let idx = 0;\n        for (let i = 1; i < wordObjs.length; i++) {\n          if (wordObjs[i].totalMatches < wordObjs[idx].totalMatches) idx = i;\n        }\n        const word = wordObjs.splice(idx, 1)[0];\n        placeWord(word, Math.floor(boardSize / 2), Math.floor(boardSize / 2), 0);\n        return true;\n      }\n      let selectedIdx = -1;\n      let minDiff = Infinity;\n      for (let i = 0; i < wordObjs.length; i++) {\n        const word = wordObjs[i];\n        word.effectiveMatches = 0;\n        word.successfulMatches = [];\n        for (const j of shuffleArray([...Array(word.char.length).keys()])) {\n          const curChar = word.char[j];\n          for (const existing of placedWords) {\n            for (const l of shuffleArray([...Array(existing.char.length).keys()])) {\n              const testChar = existing.char[l];\n              if (curChar === testChar) {\n                word.effectiveMatches++;\n                const cross = {\n                  x: existing.x,\n                  y: existing.y,\n                  dir: 0\n                };\n                if (existing.dir === 0) {\n                  cross.dir = 1;\n                  cross.x += l;\n                  cross.y -= j;\n                } else {\n                  cross.dir = 0;\n                  cross.y += l;\n                  cross.x -= j;\n                }\n                if (canPlaceWord(word, cross.x, cross.y, cross.dir)) {\n                  word.successfulMatches.push(cross);\n                }\n              }\n            }\n          }\n        }\n        const diff = word.totalMatches - word.effectiveMatches;\n        if (diff < minDiff && word.successfulMatches.length > 0) {\n          minDiff = diff;\n          selectedIdx = i;\n        }\n      }\n      if (selectedIdx === -1) return false;\n      const selectedWord = wordObjs.splice(selectedIdx, 1)[0];\n      const shuffledMatches = shuffleArray(selectedWord.successfulMatches);\n      const chosen = shuffledMatches[0];\n      placeWord(selectedWord, chosen.x, chosen.y, chosen.dir);\n      return true;\n    }\n    while (wordObjs.length > 0 && addWordToBoard());\n    return placedWords.map(w => ({\n      word: w.string.trim().substring(w.string.indexOf(w.char[1])),\n      x: w.x,\n      y: w.y,\n      direction: w.dir === 0 ? 'horizontal' : 'vertical'\n    }));\n  }\n\n  // Example usage:\n  const result = generateCrossword(['GIÓ', 'HẠT GIỐNG', 'DREAM', 'THUỐC', 'CÚC', 'CHÂU KIỆT LUÂN']);\n  console.log(result);\n  return /*#__PURE__*/_jsxDEV(_Fragment, {}, void 0, false);\n};\n_c = WordBoard;\nexport default WordBoard;\nvar _c;\n$RefreshReg$(_c, \"WordBoard\");","map":{"version":3,"names":["React","Fragment","_Fragment","jsxDEV","_jsxDEV","WordBoard","WordObj","constructor","word","string","char","totalMatches","effectiveMatches","successfulMatches","x","y","dir","split","shuffleArray","array","arr","i","length","j","Math","floor","random","generateCrossword","words","boardSize","board","Array","from","fill","wordObjs","map","placedWords","k","l","canPlaceWord","xi","yi","placeWord","push","addWordToBoard","idx","splice","selectedIdx","minDiff","Infinity","keys","curChar","existing","testChar","cross","diff","selectedWord","shuffledMatches","chosen","w","trim","substring","indexOf","direction","result","console","log","_c","$RefreshReg$"],"sources":["C:/Users/ASUS/Documents/htm_fe/src/pages/Host/Management/HostRound2.tsx"],"sourcesContent":["import React, { useState, useEffect } from \"react\";\r\n\r\n// Define word object structure\r\n\r\n\r\n\r\n// Main React Component\r\nconst WordBoard: React.FC = () => {\r\n  // TypeScript version of the crossword builder with shuffled letter matches\r\n\r\n  type Direction = 'horizontal' | 'vertical';\r\n\r\n  interface PlacedWord {\r\n    word: string;\r\n    x: number;\r\n    y: number;\r\n    direction: Direction;\r\n  }\r\n\r\n  class WordObj {\r\n    string: string;\r\n    char: string[];\r\n    totalMatches: number = 0;\r\n    effectiveMatches: number = 0;\r\n    successfulMatches: { x: number; y: number; dir: number }[] = [];\r\n    x: number = 0;\r\n    y: number = 0;\r\n    dir: number = 0;\r\n\r\n    constructor(word: string) {\r\n      this.string = word;\r\n      this.char = word.split('');\r\n    }\r\n  }\r\n\r\n  function shuffleArray<T>(array: T[]): T[] {\r\n    const arr = [...array];\r\n    for (let i = arr.length - 1; i > 0; i--) {\r\n      const j = Math.floor(Math.random() * (i + 1));\r\n      [arr[i], arr[j]] = [arr[j], arr[i]];\r\n    }\r\n    return arr;\r\n  }\r\n\r\n  function generateCrossword(words: string[]): PlacedWord[] {\r\n    const boardSize = 20;\r\n    const board: (string | null)[][] = Array.from({ length: boardSize }, () => Array(boardSize).fill(null));\r\n    const wordObjs: WordObj[] = words.map((word, i) => new WordObj(` ${i + 1}${word} `));\r\n    const placedWords: WordObj[] = [];\r\n\r\n    // Calculate totalMatches\r\n    for (let i = 0; i < wordObjs.length; i++) {\r\n      for (let j = 0; j < wordObjs[i].char.length; j++) {\r\n        for (let k = 0; k < wordObjs.length; k++) {\r\n          if (k === i) continue;\r\n          for (let l = 0; l < wordObjs[k].char.length; l++) {\r\n            if (wordObjs[i].char[j] === wordObjs[k].char[l]) {\r\n              wordObjs[i].totalMatches++;\r\n            }\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    function canPlaceWord(word: WordObj, x: number, y: number, dir: number): boolean {\r\n      for (let i = 0; i < word.char.length; i++) {\r\n        const xi = dir === 0 ? x + i : x;\r\n        const yi = dir === 1 ? y + i : y;\r\n\r\n        if (xi < 0 || xi >= boardSize || yi < 0 || yi >= boardSize) return false;\r\n        if (board[xi][yi] && board[xi][yi] !== word.char[i]) return false;\r\n      }\r\n      return true;\r\n    }\r\n\r\n    function placeWord(word: WordObj, x: number, y: number, dir: number) {\r\n      for (let i = 0; i < word.char.length; i++) {\r\n        const xi = dir === 0 ? x + i : x;\r\n        const yi = dir === 1 ? y + i : y;\r\n        board[xi][yi] = word.char[i];\r\n      }\r\n      word.x = x;\r\n      word.y = y;\r\n      word.dir = dir;\r\n      placedWords.push(word);\r\n    }\r\n\r\n    function addWordToBoard(): boolean {\r\n      if (placedWords.length === 0) {\r\n        // Place the word with fewest totalMatches in center\r\n        let idx = 0;\r\n        for (let i = 1; i < wordObjs.length; i++) {\r\n          if (wordObjs[i].totalMatches < wordObjs[idx].totalMatches) idx = i;\r\n        }\r\n        const word = wordObjs.splice(idx, 1)[0];\r\n        placeWord(word, Math.floor(boardSize / 2), Math.floor(boardSize / 2), 0);\r\n        return true;\r\n      }\r\n\r\n      let selectedIdx = -1;\r\n      let minDiff = Infinity;\r\n\r\n      for (let i = 0; i < wordObjs.length; i++) {\r\n        const word = wordObjs[i];\r\n        word.effectiveMatches = 0;\r\n        word.successfulMatches = [];\r\n\r\n        for (const j of shuffleArray([...Array(word.char.length).keys()])) {\r\n          const curChar = word.char[j];\r\n          for (const existing of placedWords) {\r\n            for (const l of shuffleArray([...Array(existing.char.length).keys()])) {\r\n              const testChar = existing.char[l];\r\n              if (curChar === testChar) {\r\n                word.effectiveMatches++;\r\n\r\n                const cross = { x: existing.x, y: existing.y, dir: 0 };\r\n                if (existing.dir === 0) {\r\n                  cross.dir = 1;\r\n                  cross.x += l;\r\n                  cross.y -= j;\r\n                } else {\r\n                  cross.dir = 0;\r\n                  cross.y += l;\r\n                  cross.x -= j;\r\n                }\r\n\r\n                if (canPlaceWord(word, cross.x, cross.y, cross.dir)) {\r\n                  word.successfulMatches.push(cross);\r\n                }\r\n              }\r\n            }\r\n          }\r\n        }\r\n\r\n        const diff = word.totalMatches - word.effectiveMatches;\r\n        if (diff < minDiff && word.successfulMatches.length > 0) {\r\n          minDiff = diff;\r\n          selectedIdx = i;\r\n        }\r\n      }\r\n\r\n      if (selectedIdx === -1) return false;\r\n\r\n      const selectedWord = wordObjs.splice(selectedIdx, 1)[0];\r\n      const shuffledMatches = shuffleArray(selectedWord.successfulMatches);\r\n      const chosen = shuffledMatches[0];\r\n      placeWord(selectedWord, chosen.x, chosen.y, chosen.dir);\r\n      return true;\r\n    }\r\n\r\n    while (wordObjs.length > 0 && addWordToBoard());\r\n\r\n    return placedWords.map(w => ({\r\n      word: w.string.trim().substring(w.string.indexOf(w.char[1])),\r\n      x: w.x,\r\n      y: w.y,\r\n      direction: w.dir === 0 ? 'horizontal' : 'vertical'\r\n    }));\r\n  }\r\n\r\n\r\n  // Example usage:\r\n  const result = generateCrossword([\r\n    'GIÓ',\r\n    'HẠT GIỐNG',\r\n    'DREAM',\r\n    'THUỐC',\r\n    'CÚC',\r\n    'CHÂU KIỆT LUÂN',\r\n  ]);\r\n  console.log(result);\r\n\r\n  return (\r\n    <>\r\n    </>\r\n  );\r\n};\r\n\r\nexport default WordBoard;"],"mappings":"AAAA,OAAOA,KAAK,MAA+B,OAAO;;AAElD;;AAIA;AAAA,SAAAC,QAAA,IAAAC,SAAA,EAAAC,MAAA,IAAAC,OAAA;AACA,MAAMC,SAAmB,GAAGA,CAAA,KAAM;EAChC;;EAWA,MAAMC,OAAO,CAAC;IAUZC,WAAWA,CAACC,IAAY,EAAE;MAAA,KAT1BC,MAAM;MAAA,KACNC,IAAI;MAAA,KACJC,YAAY,GAAW,CAAC;MAAA,KACxBC,gBAAgB,GAAW,CAAC;MAAA,KAC5BC,iBAAiB,GAA4C,EAAE;MAAA,KAC/DC,CAAC,GAAW,CAAC;MAAA,KACbC,CAAC,GAAW,CAAC;MAAA,KACbC,GAAG,GAAW,CAAC;MAGb,IAAI,CAACP,MAAM,GAAGD,IAAI;MAClB,IAAI,CAACE,IAAI,GAAGF,IAAI,CAACS,KAAK,CAAC,EAAE,CAAC;IAC5B;EACF;EAEA,SAASC,YAAYA,CAAIC,KAAU,EAAO;IACxC,MAAMC,GAAG,GAAG,CAAC,GAAGD,KAAK,CAAC;IACtB,KAAK,IAAIE,CAAC,GAAGD,GAAG,CAACE,MAAM,GAAG,CAAC,EAAED,CAAC,GAAG,CAAC,EAAEA,CAAC,EAAE,EAAE;MACvC,MAAME,CAAC,GAAGC,IAAI,CAACC,KAAK,CAACD,IAAI,CAACE,MAAM,CAAC,CAAC,IAAIL,CAAC,GAAG,CAAC,CAAC,CAAC;MAC7C,CAACD,GAAG,CAACC,CAAC,CAAC,EAAED,GAAG,CAACG,CAAC,CAAC,CAAC,GAAG,CAACH,GAAG,CAACG,CAAC,CAAC,EAAEH,GAAG,CAACC,CAAC,CAAC,CAAC;IACrC;IACA,OAAOD,GAAG;EACZ;EAEA,SAASO,iBAAiBA,CAACC,KAAe,EAAgB;IACxD,MAAMC,SAAS,GAAG,EAAE;IACpB,MAAMC,KAA0B,GAAGC,KAAK,CAACC,IAAI,CAAC;MAAEV,MAAM,EAAEO;IAAU,CAAC,EAAE,MAAME,KAAK,CAACF,SAAS,CAAC,CAACI,IAAI,CAAC,IAAI,CAAC,CAAC;IACvG,MAAMC,QAAmB,GAAGN,KAAK,CAACO,GAAG,CAAC,CAAC3B,IAAI,EAAEa,CAAC,KAAK,IAAIf,OAAO,CAAC,IAAIe,CAAC,GAAG,CAAC,GAAGb,IAAI,GAAG,CAAC,CAAC;IACpF,MAAM4B,WAAsB,GAAG,EAAE;;IAEjC;IACA,KAAK,IAAIf,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGa,QAAQ,CAACZ,MAAM,EAAED,CAAC,EAAE,EAAE;MACxC,KAAK,IAAIE,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGW,QAAQ,CAACb,CAAC,CAAC,CAACX,IAAI,CAACY,MAAM,EAAEC,CAAC,EAAE,EAAE;QAChD,KAAK,IAAIc,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGH,QAAQ,CAACZ,MAAM,EAAEe,CAAC,EAAE,EAAE;UACxC,IAAIA,CAAC,KAAKhB,CAAC,EAAE;UACb,KAAK,IAAIiB,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGJ,QAAQ,CAACG,CAAC,CAAC,CAAC3B,IAAI,CAACY,MAAM,EAAEgB,CAAC,EAAE,EAAE;YAChD,IAAIJ,QAAQ,CAACb,CAAC,CAAC,CAACX,IAAI,CAACa,CAAC,CAAC,KAAKW,QAAQ,CAACG,CAAC,CAAC,CAAC3B,IAAI,CAAC4B,CAAC,CAAC,EAAE;cAC/CJ,QAAQ,CAACb,CAAC,CAAC,CAACV,YAAY,EAAE;YAC5B;UACF;QACF;MACF;IACF;IAEA,SAAS4B,YAAYA,CAAC/B,IAAa,EAAEM,CAAS,EAAEC,CAAS,EAAEC,GAAW,EAAW;MAC/E,KAAK,IAAIK,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGb,IAAI,CAACE,IAAI,CAACY,MAAM,EAAED,CAAC,EAAE,EAAE;QACzC,MAAMmB,EAAE,GAAGxB,GAAG,KAAK,CAAC,GAAGF,CAAC,GAAGO,CAAC,GAAGP,CAAC;QAChC,MAAM2B,EAAE,GAAGzB,GAAG,KAAK,CAAC,GAAGD,CAAC,GAAGM,CAAC,GAAGN,CAAC;QAEhC,IAAIyB,EAAE,GAAG,CAAC,IAAIA,EAAE,IAAIX,SAAS,IAAIY,EAAE,GAAG,CAAC,IAAIA,EAAE,IAAIZ,SAAS,EAAE,OAAO,KAAK;QACxE,IAAIC,KAAK,CAACU,EAAE,CAAC,CAACC,EAAE,CAAC,IAAIX,KAAK,CAACU,EAAE,CAAC,CAACC,EAAE,CAAC,KAAKjC,IAAI,CAACE,IAAI,CAACW,CAAC,CAAC,EAAE,OAAO,KAAK;MACnE;MACA,OAAO,IAAI;IACb;IAEA,SAASqB,SAASA,CAAClC,IAAa,EAAEM,CAAS,EAAEC,CAAS,EAAEC,GAAW,EAAE;MACnE,KAAK,IAAIK,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGb,IAAI,CAACE,IAAI,CAACY,MAAM,EAAED,CAAC,EAAE,EAAE;QACzC,MAAMmB,EAAE,GAAGxB,GAAG,KAAK,CAAC,GAAGF,CAAC,GAAGO,CAAC,GAAGP,CAAC;QAChC,MAAM2B,EAAE,GAAGzB,GAAG,KAAK,CAAC,GAAGD,CAAC,GAAGM,CAAC,GAAGN,CAAC;QAChCe,KAAK,CAACU,EAAE,CAAC,CAACC,EAAE,CAAC,GAAGjC,IAAI,CAACE,IAAI,CAACW,CAAC,CAAC;MAC9B;MACAb,IAAI,CAACM,CAAC,GAAGA,CAAC;MACVN,IAAI,CAACO,CAAC,GAAGA,CAAC;MACVP,IAAI,CAACQ,GAAG,GAAGA,GAAG;MACdoB,WAAW,CAACO,IAAI,CAACnC,IAAI,CAAC;IACxB;IAEA,SAASoC,cAAcA,CAAA,EAAY;MACjC,IAAIR,WAAW,CAACd,MAAM,KAAK,CAAC,EAAE;QAC5B;QACA,IAAIuB,GAAG,GAAG,CAAC;QACX,KAAK,IAAIxB,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGa,QAAQ,CAACZ,MAAM,EAAED,CAAC,EAAE,EAAE;UACxC,IAAIa,QAAQ,CAACb,CAAC,CAAC,CAACV,YAAY,GAAGuB,QAAQ,CAACW,GAAG,CAAC,CAAClC,YAAY,EAAEkC,GAAG,GAAGxB,CAAC;QACpE;QACA,MAAMb,IAAI,GAAG0B,QAAQ,CAACY,MAAM,CAACD,GAAG,EAAE,CAAC,CAAC,CAAC,CAAC,CAAC;QACvCH,SAAS,CAAClC,IAAI,EAAEgB,IAAI,CAACC,KAAK,CAACI,SAAS,GAAG,CAAC,CAAC,EAAEL,IAAI,CAACC,KAAK,CAACI,SAAS,GAAG,CAAC,CAAC,EAAE,CAAC,CAAC;QACxE,OAAO,IAAI;MACb;MAEA,IAAIkB,WAAW,GAAG,CAAC,CAAC;MACpB,IAAIC,OAAO,GAAGC,QAAQ;MAEtB,KAAK,IAAI5B,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGa,QAAQ,CAACZ,MAAM,EAAED,CAAC,EAAE,EAAE;QACxC,MAAMb,IAAI,GAAG0B,QAAQ,CAACb,CAAC,CAAC;QACxBb,IAAI,CAACI,gBAAgB,GAAG,CAAC;QACzBJ,IAAI,CAACK,iBAAiB,GAAG,EAAE;QAE3B,KAAK,MAAMU,CAAC,IAAIL,YAAY,CAAC,CAAC,GAAGa,KAAK,CAACvB,IAAI,CAACE,IAAI,CAACY,MAAM,CAAC,CAAC4B,IAAI,CAAC,CAAC,CAAC,CAAC,EAAE;UACjE,MAAMC,OAAO,GAAG3C,IAAI,CAACE,IAAI,CAACa,CAAC,CAAC;UAC5B,KAAK,MAAM6B,QAAQ,IAAIhB,WAAW,EAAE;YAClC,KAAK,MAAME,CAAC,IAAIpB,YAAY,CAAC,CAAC,GAAGa,KAAK,CAACqB,QAAQ,CAAC1C,IAAI,CAACY,MAAM,CAAC,CAAC4B,IAAI,CAAC,CAAC,CAAC,CAAC,EAAE;cACrE,MAAMG,QAAQ,GAAGD,QAAQ,CAAC1C,IAAI,CAAC4B,CAAC,CAAC;cACjC,IAAIa,OAAO,KAAKE,QAAQ,EAAE;gBACxB7C,IAAI,CAACI,gBAAgB,EAAE;gBAEvB,MAAM0C,KAAK,GAAG;kBAAExC,CAAC,EAAEsC,QAAQ,CAACtC,CAAC;kBAAEC,CAAC,EAAEqC,QAAQ,CAACrC,CAAC;kBAAEC,GAAG,EAAE;gBAAE,CAAC;gBACtD,IAAIoC,QAAQ,CAACpC,GAAG,KAAK,CAAC,EAAE;kBACtBsC,KAAK,CAACtC,GAAG,GAAG,CAAC;kBACbsC,KAAK,CAACxC,CAAC,IAAIwB,CAAC;kBACZgB,KAAK,CAACvC,CAAC,IAAIQ,CAAC;gBACd,CAAC,MAAM;kBACL+B,KAAK,CAACtC,GAAG,GAAG,CAAC;kBACbsC,KAAK,CAACvC,CAAC,IAAIuB,CAAC;kBACZgB,KAAK,CAACxC,CAAC,IAAIS,CAAC;gBACd;gBAEA,IAAIgB,YAAY,CAAC/B,IAAI,EAAE8C,KAAK,CAACxC,CAAC,EAAEwC,KAAK,CAACvC,CAAC,EAAEuC,KAAK,CAACtC,GAAG,CAAC,EAAE;kBACnDR,IAAI,CAACK,iBAAiB,CAAC8B,IAAI,CAACW,KAAK,CAAC;gBACpC;cACF;YACF;UACF;QACF;QAEA,MAAMC,IAAI,GAAG/C,IAAI,CAACG,YAAY,GAAGH,IAAI,CAACI,gBAAgB;QACtD,IAAI2C,IAAI,GAAGP,OAAO,IAAIxC,IAAI,CAACK,iBAAiB,CAACS,MAAM,GAAG,CAAC,EAAE;UACvD0B,OAAO,GAAGO,IAAI;UACdR,WAAW,GAAG1B,CAAC;QACjB;MACF;MAEA,IAAI0B,WAAW,KAAK,CAAC,CAAC,EAAE,OAAO,KAAK;MAEpC,MAAMS,YAAY,GAAGtB,QAAQ,CAACY,MAAM,CAACC,WAAW,EAAE,CAAC,CAAC,CAAC,CAAC,CAAC;MACvD,MAAMU,eAAe,GAAGvC,YAAY,CAACsC,YAAY,CAAC3C,iBAAiB,CAAC;MACpE,MAAM6C,MAAM,GAAGD,eAAe,CAAC,CAAC,CAAC;MACjCf,SAAS,CAACc,YAAY,EAAEE,MAAM,CAAC5C,CAAC,EAAE4C,MAAM,CAAC3C,CAAC,EAAE2C,MAAM,CAAC1C,GAAG,CAAC;MACvD,OAAO,IAAI;IACb;IAEA,OAAOkB,QAAQ,CAACZ,MAAM,GAAG,CAAC,IAAIsB,cAAc,CAAC,CAAC,CAAC;IAE/C,OAAOR,WAAW,CAACD,GAAG,CAACwB,CAAC,KAAK;MAC3BnD,IAAI,EAAEmD,CAAC,CAAClD,MAAM,CAACmD,IAAI,CAAC,CAAC,CAACC,SAAS,CAACF,CAAC,CAAClD,MAAM,CAACqD,OAAO,CAACH,CAAC,CAACjD,IAAI,CAAC,CAAC,CAAC,CAAC,CAAC;MAC5DI,CAAC,EAAE6C,CAAC,CAAC7C,CAAC;MACNC,CAAC,EAAE4C,CAAC,CAAC5C,CAAC;MACNgD,SAAS,EAAEJ,CAAC,CAAC3C,GAAG,KAAK,CAAC,GAAG,YAAY,GAAG;IAC1C,CAAC,CAAC,CAAC;EACL;;EAGA;EACA,MAAMgD,MAAM,GAAGrC,iBAAiB,CAAC,CAC/B,KAAK,EACL,WAAW,EACX,OAAO,EACP,OAAO,EACP,KAAK,EACL,gBAAgB,CACjB,CAAC;EACFsC,OAAO,CAACC,GAAG,CAACF,MAAM,CAAC;EAEnB,oBACE5D,OAAA,CAAAF,SAAA,mBACE,CAAC;AAEP,CAAC;AAACiE,EAAA,GAzKI9D,SAAmB;AA2KzB,eAAeA,SAAS;AAAC,IAAA8D,EAAA;AAAAC,YAAA,CAAAD,EAAA","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}