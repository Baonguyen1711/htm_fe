{"ast":null,"code":"var _jsxFileName = \"C:\\\\Users\\\\ASUS\\\\Documents\\\\htm_fe\\\\src\\\\pages\\\\Host\\\\Management\\\\HostRound2.tsx\",\n  _s = $RefreshSig$();\nimport React, { useState, useEffect } from \"react\";\n\n// Define word object structure\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nfunction generateBoardPlacement(wordArr) {\n  const boardSize = 50;\n  const center = Math.floor(boardSize / 2);\n  const board = Array.from({\n    length: boardSize\n  }, () => Array(boardSize).fill(null));\n  const isPos = Array.from({\n    length: boardSize\n  }, () => Array(boardSize).fill(false));\n  const classesOfBoard = Array.from({\n    length: boardSize\n  }, () => Array.from({\n    length: boardSize\n  }, () => []));\n  const directions = [\"horizontal\", \"vertical\"];\n  const Bounds = {\n    top: center,\n    bottom: center,\n    left: center,\n    right: center,\n    Update(x, y) {\n      this.top = Math.min(this.top, y);\n      this.bottom = Math.max(this.bottom, y);\n      this.left = Math.min(this.left, x);\n      this.right = Math.max(this.right, x);\n    }\n  };\n  class WordObj {\n    constructor(str) {\n      this.string = str;\n      this.char = [...str];\n      this.totalMatches = 0;\n      this.effectiveMatches = 0;\n      this.successfulMatches = [];\n      this.x = null;\n      this.y = null;\n      this.dir = null;\n    }\n  }\n  const wordBank = wordArr.map((w, i) => new WordObj(' ' + (i + 1).toString() + w + ' '));\n  const wordsActive = [];\n  for (let i = 0; i < wordBank.length; i++) {\n    const wA = wordBank[i];\n    for (let j = 0; j < wA.char.length; j++) {\n      for (let k = 0; k < wordBank.length; k++) {\n        if (k === i) continue;\n        const wB = wordBank[k];\n        for (let l = 0; l < wB.char.length; l++) {\n          wA.totalMatches += wA.char[j] === wB.char[l] ? 1 : 0;\n        }\n      }\n    }\n  }\n  function placeWord() {\n    let curIndex = -1;\n    if (wordsActive.length === 0) {\n      curIndex = wordBank.reduce((minIdx, word, idx) => word.totalMatches < wordBank[minIdx].totalMatches ? idx : minIdx, 0);\n      wordBank[curIndex].successfulMatches = [{\n        x: center,\n        y: center,\n        dir: 0\n      }];\n    } else {\n      let minDiff = Infinity;\n      for (let i = 0; i < wordBank.length; i++) {\n        const curWord = wordBank[i];\n        curWord.effectiveMatches = 0;\n        curWord.successfulMatches = [];\n        for (let j = 0; j < curWord.char.length; j++) {\n          if (j === 1) continue;\n          const curChar = curWord.char[j];\n          for (const testWord of wordsActive) {\n            for (let l = 0; l < testWord.char.length; l++) {\n              if (l === 1) continue;\n              if (curChar === testWord.char[l]) {\n                curWord.effectiveMatches++;\n                let cross = {\n                  x: testWord.x,\n                  y: testWord.y,\n                  dir: testWord.dir === 0 ? 1 : 0\n                };\n                if (testWord.dir === 0) {\n                  cross.x += l;\n                  cross.y -= j;\n                } else {\n                  cross.y += l;\n                  cross.x -= j;\n                }\n                let isMatch = true;\n                for (let m = 0; m < curWord.char.length; m++) {\n                  if (curWord.char[m] === ' ') continue;\n                  let x = cross.x,\n                    y = cross.y;\n                  if (cross.dir === 0) x += m;else y += m;\n                  if (x < 0 || y < 0 || x >= boardSize || y >= boardSize) {\n                    isMatch = false;\n                    break;\n                  }\n                  if (board[x][y] && board[x][y] !== curWord.char[m]) {\n                    isMatch = false;\n                    break;\n                  }\n                }\n                if (isMatch) curWord.successfulMatches.push(cross);\n              }\n            }\n          }\n        }\n        let diff = curWord.totalMatches - curWord.effectiveMatches;\n        if (curWord.successfulMatches.length && diff < minDiff) {\n          minDiff = diff;\n          curIndex = i;\n        }\n      }\n      if (curIndex === -1) return false;\n    }\n    const word = wordBank.splice(curIndex, 1)[0];\n    wordsActive.push(word);\n    const match = word.successfulMatches[Math.floor(Math.random() * word.successfulMatches.length)];\n    word.x = match.x;\n    word.y = match.y;\n    word.dir = match.dir;\n    for (let i = 0; i < word.char.length; i++) {\n      let x = match.x;\n      let y = match.y;\n      if (match.dir === 0) x += i;else y += i;\n      board[x][y] = word.char[i];\n      isPos[x][y] = i === 1;\n      classesOfBoard[x][y].push(wordsActive.length);\n      Bounds.Update(x, y);\n    }\n    return true;\n  }\n  while (wordBank.length > 0) {\n    const success = placeWord();\n    if (!success) break;\n  }\n  return wordsActive.map(w => ({\n    word: w.string.trim().replace(/^\\d+/, \"\"),\n    x: w.x,\n    y: w.y,\n    direction: w.dir === 0 ? \"horizontal\" : \"vertical\"\n  }));\n}\n\n// Main React Component\nconst WordBoard = () => {\n  _s();\n  const [board, setBoard] = useState(generateBoard(boardSize));\n  const [wordsPlaced, setWordsPlaced] = useState([]);\n  useEffect(() => {\n    const wordBank = prepareWordBank();\n    const wordsActive = populateBoard(wordBank, board);\n    setWordsPlaced(wordsActive);\n    setBoard([...board]); // Fix: Ensures state updates correctly\n  }, []);\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    children: [/*#__PURE__*/_jsxDEV(\"h2\", {\n      children: \"Word Puzzle Board\"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 166,\n      columnNumber: 7\n    }, this), BoardToHtml(board)]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 165,\n    columnNumber: 5\n  }, this);\n};\n_s(WordBoard, \"IgTgE/kJ3tA/zzd42ADjn4pu410=\");\n_c = WordBoard;\nexport default WordBoard;\nvar _c;\n$RefreshReg$(_c, \"WordBoard\");","map":{"version":3,"names":["React","useState","useEffect","jsxDEV","_jsxDEV","generateBoardPlacement","wordArr","boardSize","center","Math","floor","board","Array","from","length","fill","isPos","classesOfBoard","directions","Bounds","top","bottom","left","right","Update","x","y","min","max","WordObj","constructor","str","string","char","totalMatches","effectiveMatches","successfulMatches","dir","wordBank","map","w","i","toString","wordsActive","wA","j","k","wB","l","placeWord","curIndex","reduce","minIdx","word","idx","minDiff","Infinity","curWord","curChar","testWord","cross","isMatch","m","push","diff","splice","match","random","success","trim","replace","direction","WordBoard","_s","setBoard","generateBoard","wordsPlaced","setWordsPlaced","prepareWordBank","populateBoard","children","fileName","_jsxFileName","lineNumber","columnNumber","BoardToHtml","_c","$RefreshReg$"],"sources":["C:/Users/ASUS/Documents/htm_fe/src/pages/Host/Management/HostRound2.tsx"],"sourcesContent":["import React, { useState, useEffect } from \"react\";\r\n\r\n// Define word object structure\r\nfunction generateBoardPlacement(wordArr: string) {\r\n  const boardSize = 50;\r\n  const center = Math.floor(boardSize / 2);\r\n  const board = Array.from({ length: boardSize }, () => Array(boardSize).fill(null));\r\n  const isPos = Array.from({ length: boardSize }, () => Array(boardSize).fill(false));\r\n  const classesOfBoard = Array.from({ length: boardSize }, () => Array.from({ length: boardSize }, () => []));\r\n  const directions = [\"horizontal\", \"vertical\"];\r\n  const Bounds = {\r\n    top: center, bottom: center, left: center, right: center,\r\n    Update(x, y) {\r\n      this.top = Math.min(this.top, y);\r\n      this.bottom = Math.max(this.bottom, y);\r\n      this.left = Math.min(this.left, x);\r\n      this.right = Math.max(this.right, x);\r\n    }\r\n  };\r\n\r\n  class WordObj {\r\n    constructor(str) {\r\n      this.string = str;\r\n      this.char = [...str];\r\n      this.totalMatches = 0;\r\n      this.effectiveMatches = 0;\r\n      this.successfulMatches = [];\r\n      this.x = null;\r\n      this.y = null;\r\n      this.dir = null;\r\n    }\r\n  }\r\n\r\n  const wordBank = wordArr.map((w, i) => new WordObj(' ' + (i + 1).toString() + w + ' '));\r\n  const wordsActive = [];\r\n\r\n  for (let i = 0; i < wordBank.length; i++) {\r\n    const wA = wordBank[i];\r\n    for (let j = 0; j < wA.char.length; j++) {\r\n      for (let k = 0; k < wordBank.length; k++) {\r\n        if (k === i) continue;\r\n        const wB = wordBank[k];\r\n        for (let l = 0; l < wB.char.length; l++) {\r\n          wA.totalMatches += wA.char[j] === wB.char[l] ? 1 : 0;\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  function placeWord() {\r\n    let curIndex = -1;\r\n    if (wordsActive.length === 0) {\r\n      curIndex = wordBank.reduce((minIdx, word, idx) =>\r\n        word.totalMatches < wordBank[minIdx].totalMatches ? idx : minIdx, 0);\r\n      wordBank[curIndex].successfulMatches = [{ x: center, y: center, dir: 0 }];\r\n    } else {\r\n      let minDiff = Infinity;\r\n      for (let i = 0; i < wordBank.length; i++) {\r\n        const curWord = wordBank[i];\r\n        curWord.effectiveMatches = 0;\r\n        curWord.successfulMatches = [];\r\n\r\n        for (let j = 0; j < curWord.char.length; j++) {\r\n          if (j === 1) continue;\r\n          const curChar = curWord.char[j];\r\n          for (const testWord of wordsActive) {\r\n            for (let l = 0; l < testWord.char.length; l++) {\r\n              if (l === 1) continue;\r\n              if (curChar === testWord.char[l]) {\r\n                curWord.effectiveMatches++;\r\n                let cross = {\r\n                  x: testWord.x,\r\n                  y: testWord.y,\r\n                  dir: testWord.dir === 0 ? 1 : 0\r\n                };\r\n\r\n                if (testWord.dir === 0) {\r\n                  cross.x += l;\r\n                  cross.y -= j;\r\n                } else {\r\n                  cross.y += l;\r\n                  cross.x -= j;\r\n                }\r\n\r\n                let isMatch = true;\r\n                for (let m = 0; m < curWord.char.length; m++) {\r\n                  if (curWord.char[m] === ' ') continue;\r\n                  let x = cross.x, y = cross.y;\r\n                  if (cross.dir === 0) x += m;\r\n                  else y += m;\r\n                  if (x < 0 || y < 0 || x >= boardSize || y >= boardSize) {\r\n                    isMatch = false;\r\n                    break;\r\n                  }\r\n                  if (board[x][y] && board[x][y] !== curWord.char[m]) {\r\n                    isMatch = false;\r\n                    break;\r\n                  }\r\n                }\r\n\r\n                if (isMatch) curWord.successfulMatches.push(cross);\r\n              }\r\n            }\r\n          }\r\n        }\r\n\r\n        let diff = curWord.totalMatches - curWord.effectiveMatches;\r\n        if (curWord.successfulMatches.length && diff < minDiff) {\r\n          minDiff = diff;\r\n          curIndex = i;\r\n        }\r\n      }\r\n\r\n      if (curIndex === -1) return false;\r\n    }\r\n\r\n    const word = wordBank.splice(curIndex, 1)[0];\r\n    wordsActive.push(word);\r\n    const match = word.successfulMatches[Math.floor(Math.random() * word.successfulMatches.length)];\r\n    word.x = match.x;\r\n    word.y = match.y;\r\n    word.dir = match.dir;\r\n\r\n    for (let i = 0; i < word.char.length; i++) {\r\n      let x = match.x;\r\n      let y = match.y;\r\n      if (match.dir === 0) x += i;\r\n      else y += i;\r\n      board[x][y] = word.char[i];\r\n      isPos[x][y] = (i === 1);\r\n      classesOfBoard[x][y].push(wordsActive.length);\r\n      Bounds.Update(x, y);\r\n    }\r\n\r\n    return true;\r\n  }\r\n\r\n  while (wordBank.length > 0) {\r\n    const success = placeWord();\r\n    if (!success) break;\r\n  }\r\n\r\n  return wordsActive.map(w => ({\r\n    word: w.string.trim().replace(/^\\d+/, \"\"),\r\n    x: w.x,\r\n    y: w.y,\r\n    direction: w.dir === 0 ? \"horizontal\" : \"vertical\"\r\n  }));\r\n}\r\n\r\n\r\n// Main React Component\r\nconst WordBoard: React.FC = () => {\r\n  const [board, setBoard] = useState<string[][]>(generateBoard(boardSize));\r\n  const [wordsPlaced, setWordsPlaced] = useState<WordObj[]>([]);\r\n\r\n  useEffect(() => {\r\n    const wordBank = prepareWordBank();\r\n    const wordsActive = populateBoard(wordBank, board);\r\n    setWordsPlaced(wordsActive);\r\n    setBoard([...board]); // Fix: Ensures state updates correctly\r\n  }, []);\r\n\r\n  return (\r\n    <div>\r\n      <h2>Word Puzzle Board</h2>\r\n      {BoardToHtml(board)}\r\n    </div>\r\n  );\r\n};\r\n\r\nexport default WordBoard;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}