{"ast":null,"code":"const wordArr = ['GIÓ', 'HẠTGIỐNG', 'DREAM', 'THUỐC', 'CÚC', 'CHÂUKIỆTLUÂN'];\n\n// const wordArr = ['gió', 'hạtgiống', 'dream', 'thuốc', 'cúc', 'châukiệtluân']\n\nexport const generateGrid = async (wordArr, cellWidth) => {\n  var board = [[]],\n    wordBank = [],\n    wordsActive = [],\n    mode;\n  var isPos = [[]];\n  var classesOfBoard = [[[]]];\n  class WordObj {\n    constructor(str) {\n      this.string = void 0;\n      this.char = void 0;\n      this.totalMatches = 0;\n      this.effectiveMatches = 0;\n      this.successfulMatches = [];\n      this.x = 0;\n      this.y = 0;\n      this.dir = 0;\n      this.string = str;\n      this.char = str.split('');\n    }\n  }\n  const Bounds = {\n    top: 0,\n    right: 0,\n    bottom: 0,\n    left: 0,\n    Update: function (x, y) {\n      this.top = Math.min(y, this.top);\n      this.right = Math.max(x, this.right);\n      this.bottom = Math.max(y, this.bottom);\n      this.left = Math.min(x, this.left);\n    },\n    Clean: function () {\n      this.top = 999;\n      this.right = 0;\n      this.bottom = 0;\n      this.left = 999;\n    }\n  };\n  Bounds.Clean();\n  for (let i = 0; i < 100; i++) {\n    board.push([]);\n    isPos.push([]);\n    classesOfBoard.push([]);\n    for (let j = 0; j < 100; j++) {\n      board[i].push(\"\");\n      isPos[i].push(false);\n      classesOfBoard[i].push([]);\n    }\n  }\n  function CleanVars() {\n    Bounds.Clean();\n    wordBank = [];\n    wordsActive = [];\n    board = [];\n    isPos = [];\n    classesOfBoard = [];\n    for (let i = 0; i < 100; i++) {\n      board.push([]);\n      isPos.push([]);\n      classesOfBoard.push([]);\n      for (let j = 0; j < 100; j++) {\n        board[i].push(\"\");\n        isPos[i].push(false);\n        classesOfBoard[i].push([]);\n      }\n    }\n  }\n  function PopulateBoard() {\n    PrepareBoard();\n    for (var i = 0, isOk = true, len = wordBank.length; i < len && isOk; i++) {\n      isOk = AddWordToBoard();\n    }\n    return isOk;\n  }\n  function PrepareBoard() {\n    wordBank = [];\n    for (let i = 0; i < wordArr.length; i++) {\n      const actualPos = i + 1;\n      wordBank.push(new WordObj(' ' + actualPos.toString() + wordArr[i] + ' '));\n    }\n    for (let i = 0; i < wordBank.length; i++) {\n      const wA = wordBank[i];\n      for (let j = 0; j < wA.char.length; j++) {\n        const cA = wA.char[j];\n        for (let k = 0; k < wordBank.length; k++) {\n          const wB = wordBank[k];\n          if (i !== k) {\n            for (let l = 0; l < wB.char.length; l++) {\n              wA.totalMatches += cA === wB.char[l] ? 1 : 0;\n            }\n          }\n        }\n      }\n    }\n  }\n  function findWordIdx(givenWord) {\n    givenWord = givenWord.substring(2, givenWord.length - 1);\n    for (let i = 0; i < wordArr.length; i++) {\n      if (givenWord === wordArr[i]) return i + 1;\n    }\n    return undefined;\n  }\n  function AddWordToBoard() {\n    var i,\n      len,\n      curIndex,\n      curWord,\n      curChar,\n      curMatch,\n      testWord,\n      testChar,\n      minMatchDiff = 9999,\n      curMatchDiff;\n    if (wordsActive.length < 1) {\n      curIndex = 0;\n      for (i = 0, len = wordBank.length; i < len; i++) {\n        if (wordBank[i].totalMatches < wordBank[curIndex].totalMatches) {\n          curIndex = i;\n        }\n      }\n      wordBank[curIndex].successfulMatches = [{\n        x: 12,\n        y: 12,\n        dir: 0\n      }];\n    } else {\n      curIndex = -1;\n      for (i = 0, len = wordBank.length; i < len; i++) {\n        curWord = wordBank[i];\n        curWord.effectiveMatches = 0;\n        curWord.successfulMatches = [];\n        for (var j = 0, lenJ = curWord.char.length; j < lenJ; j++) {\n          if (j == 1) continue; // skip pos\n          curChar = curWord.char[j];\n          for (var k = 0, lenK = wordsActive.length; k < lenK; k++) {\n            testWord = wordsActive[k];\n            for (var l = 0, lenL = testWord.char.length; l < lenL; l++) {\n              if (l == 1) continue; // skip pos\n              testChar = testWord.char[l];\n              if (curChar === testChar) {\n                curWord.effectiveMatches++;\n                var curCross = {\n                  x: testWord.x,\n                  y: testWord.y,\n                  dir: 0\n                };\n                if (testWord.dir === 0) {\n                  curCross.dir = 1;\n                  curCross.x += l;\n                  curCross.y -= j;\n                } else {\n                  curCross.dir = 0;\n                  curCross.y += l;\n                  curCross.x -= j;\n                }\n                var isMatch = true;\n                for (var m = -1, lenM = curWord.char.length + 1; m < lenM; m++) {\n                  var crossVal = [];\n                  if (m !== j) {\n                    if (curCross.dir === 0) {\n                      var xIndex = curCross.x + m;\n                      if (xIndex < 0 || xIndex > board.length) {\n                        isMatch = false;\n                        break;\n                      }\n                      crossVal.push(board[xIndex][curCross.y]);\n                      crossVal.push(board[xIndex][curCross.y + 1]);\n                      crossVal.push(board[xIndex][curCross.y - 1]);\n                    } else {\n                      var yIndex = curCross.y + m;\n                      if (yIndex < 0 || yIndex > board[curCross.x].length) {\n                        isMatch = false;\n                        break;\n                      }\n                      crossVal.push(board[curCross.x][yIndex]);\n                      crossVal.push(board[curCross.x + 1][yIndex]);\n                      crossVal.push(board[curCross.x - 1][yIndex]);\n                    }\n                    if (m > -1 && m < lenM - 1) {\n                      if (crossVal[0] !== curWord.char[m]) {\n                        if (crossVal[0] !== \"\") {\n                          isMatch = false;\n                          break;\n                        } else if (crossVal[1] !== null) {\n                          isMatch = false;\n                          break;\n                        } else if (crossVal[2] !== null) {\n                          isMatch = false;\n                          break;\n                        }\n                      }\n                    } else if (crossVal[0] !== null) {\n                      isMatch = false;\n                      break;\n                    }\n                  }\n                }\n                if (isMatch === true) {\n                  curWord.successfulMatches.push(curCross);\n                }\n              }\n            }\n          }\n        }\n        curMatchDiff = curWord.totalMatches - curWord.effectiveMatches;\n        if (curMatchDiff < minMatchDiff && curWord.successfulMatches.length > 0) {\n          curMatchDiff = minMatchDiff;\n          curIndex = i;\n        } else if (curMatchDiff <= 0) {\n          return false;\n        }\n      }\n    }\n    if (curIndex === -1) {\n      return false;\n    }\n    var spliced = wordBank.splice(curIndex, 1);\n    wordsActive.push(spliced[0]);\n    var pushIndex = wordsActive.length - 1,\n      rand = Math.random(),\n      matchArr = wordsActive[pushIndex].successfulMatches,\n      matchIndex = Math.floor(rand * matchArr.length),\n      matchData = matchArr[matchIndex];\n    wordsActive[pushIndex].x = matchData.x;\n    wordsActive[pushIndex].y = matchData.y;\n    wordsActive[pushIndex].dir = matchData.dir;\n    let actualIndex = findWordIdx(wordsActive[pushIndex].string);\n    console.log(wordsActive[pushIndex].string, \" ~~~ \", actualIndex);\n    for (i = 0, len = wordsActive[pushIndex].char.length; i < len; i++) {\n      var xIndex = matchData.x,\n        yIndex = matchData.y;\n      if (matchData.dir === 0) {\n        xIndex += i;\n      } else {\n        yIndex += i;\n      }\n      board[xIndex][yIndex] = wordsActive[pushIndex].char[i];\n      isPos[xIndex][yIndex] = i == 1;\n      if (actualIndex != undefined) classesOfBoard[xIndex][yIndex].push(actualIndex);\n      console.log(xIndex, yIndex, classesOfBoard[xIndex][yIndex]);\n      Bounds.Update(xIndex, yIndex);\n    }\n    return true;\n  }\n  PopulateBoard();\n  const top = Bounds.top;\n  const bottom = Bounds.right;\n  const left = Bounds.left;\n  const right = Bounds.bottom;\n  console.log(\"top\", top);\n  console.log(\"bottom\", bottom);\n  console.log(\"left\", left);\n  console.log(\"right\", right);\n  const wordHeight = bottom - top + 1;\n  const wordWidth = right - left + 1;\n  let startRow = top;\n  let startCol = left;\n  if (wordHeight < cellWidth) {\n    // Center vertically\n    const padding = Math.floor((cellWidth - wordHeight) / 2);\n    startRow = Math.max(0, top - padding);\n  }\n  if (wordWidth < cellWidth) {\n    // Center horizontally\n    const padding = Math.floor((cellWidth - wordWidth) / 2);\n    startCol = Math.max(0, left - padding);\n  }\n\n  // Ensure we don't go out of bounds\n  startRow = Math.min(startRow, 100 - cellWidth);\n  startCol = Math.min(startCol, 100 - cellWidth);\n\n  // --- Slice the square region ---\n  const slicedBoard = board.slice(startRow, startRow + cellWidth).map(row => row.slice(startCol, startCol + cellWidth));\n  return board;\n};","map":{"version":3,"names":["wordArr","generateGrid","cellWidth","board","wordBank","wordsActive","mode","isPos","classesOfBoard","WordObj","constructor","str","string","char","totalMatches","effectiveMatches","successfulMatches","x","y","dir","split","Bounds","top","right","bottom","left","Update","Math","min","max","Clean","i","push","j","CleanVars","PopulateBoard","PrepareBoard","isOk","len","length","AddWordToBoard","actualPos","toString","wA","cA","k","wB","l","findWordIdx","givenWord","substring","undefined","curIndex","curWord","curChar","curMatch","testWord","testChar","minMatchDiff","curMatchDiff","lenJ","lenK","lenL","curCross","isMatch","m","lenM","crossVal","xIndex","yIndex","spliced","splice","pushIndex","rand","random","matchArr","matchIndex","floor","matchData","actualIndex","console","log","wordHeight","wordWidth","startRow","startCol","padding","slicedBoard","slice","map","row"],"sources":["C:/Users/ASUS/Documents/htm_fe/src/pages/User/Round2/utils.ts"],"sourcesContent":["const wordArr = [\r\n    'GIÓ',\r\n    'HẠTGIỐNG',\r\n    'DREAM',\r\n    'THUỐC',\r\n    'CÚC',\r\n    'CHÂUKIỆTLUÂN',\r\n]\r\n\r\n// const wordArr = ['gió', 'hạtgiống', 'dream', 'thuốc', 'cúc', 'châukiệtluân']\r\n\r\nexport const generateGrid = async (wordArr: string[], cellWidth: number) => {\r\n    var board: (string)[][] = [[]], wordBank: WordObj[] = [], wordsActive: WordObj[] = [], mode: number;\r\n\r\n\r\n\r\n    interface MatchPosition {\r\n        x: number;\r\n        y: number;\r\n        dir: number; // 0 = horizontal, 1 = vertical\r\n    }\r\n\r\n    interface Question {\r\n        answer: string;\r\n    }\r\n\r\n    var isPos: boolean[][] = [[]];\r\n    var classesOfBoard: number[][][] = [[[]]];\r\n\r\n    class WordObj {\r\n        string: string;\r\n        char: string[];\r\n        totalMatches: number = 0;\r\n        effectiveMatches: number = 0;\r\n        successfulMatches: MatchPosition[] = [];\r\n        x: number = 0;\r\n        y: number = 0;\r\n        dir: number = 0;\r\n\r\n        constructor(str: string) {\r\n            this.string = str;\r\n            this.char = str.split('');\r\n        }\r\n    }\r\n\r\n    const Bounds = {\r\n        top: 0,\r\n        right: 0,\r\n        bottom: 0,\r\n        left: 0,\r\n\r\n        Update: function (x: number, y: number) {\r\n            this.top = Math.min(y, this.top);\r\n            this.right = Math.max(x, this.right);\r\n            this.bottom = Math.max(y, this.bottom);\r\n            this.left = Math.min(x, this.left);\r\n        },\r\n\r\n        Clean: function () {\r\n            this.top = 999;\r\n            this.right = 0;\r\n            this.bottom = 0;\r\n            this.left = 999;\r\n        }\r\n    };\r\n\r\n\r\n\r\n\r\n\r\n    Bounds.Clean();\r\n\r\n    for (let i = 0; i < 100; i++) {\r\n        board.push([]);\r\n        isPos.push([]);\r\n        classesOfBoard.push([]);\r\n        for (let j = 0; j < 100; j++) {\r\n            board[i].push(\"\");\r\n            isPos[i].push(false);\r\n            classesOfBoard[i].push([]);\r\n        }\r\n    }\r\n\r\n    function CleanVars(): void {\r\n        Bounds.Clean();\r\n        wordBank = [];\r\n        wordsActive = [];\r\n        board = [];\r\n        isPos = [];\r\n        classesOfBoard = [];\r\n\r\n        for (let i = 0; i < 100; i++) {\r\n            board.push([]);\r\n            isPos.push([]);\r\n            classesOfBoard.push([]);\r\n            for (let j = 0; j < 100; j++) {\r\n                board[i].push(\"\");\r\n                isPos[i].push(false);\r\n                classesOfBoard[i].push([]);\r\n            }\r\n        }\r\n    }\r\n\r\n    function PopulateBoard() {\r\n        PrepareBoard();\r\n\r\n        for (var i = 0, isOk = true, len = wordBank.length; i < len && isOk; i++) {\r\n            isOk = AddWordToBoard();\r\n        }\r\n        return isOk;\r\n    }\r\n\r\n    function PrepareBoard(): void {\r\n        wordBank = [];\r\n\r\n        for (let i = 0; i < wordArr.length; i++) {\r\n            const actualPos = i + 1;\r\n            wordBank.push(new WordObj(' ' + actualPos.toString() + wordArr[i] + ' '));\r\n        }\r\n\r\n        for (let i = 0; i < wordBank.length; i++) {\r\n            const wA = wordBank[i];\r\n            for (let j = 0; j < wA.char.length; j++) {\r\n                const cA = wA.char[j];\r\n                for (let k = 0; k < wordBank.length; k++) {\r\n                    const wB = wordBank[k];\r\n                    if (i !== k) {\r\n                        for (let l = 0; l < wB.char.length; l++) {\r\n                            wA.totalMatches += (cA === wB.char[l]) ? 1 : 0;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    function findWordIdx(givenWord: string): number | undefined {\r\n        givenWord = givenWord.substring(2, givenWord.length - 1);\r\n        for (let i = 0; i < wordArr.length; i++) {\r\n            if (givenWord === wordArr[i]) return i + 1;\r\n        }\r\n        return undefined;\r\n    }\r\n\r\n    function AddWordToBoard(): boolean {\r\n        var i, len, curIndex, curWord, curChar, curMatch, testWord, testChar,\r\n            minMatchDiff = 9999, curMatchDiff;\r\n\r\n        if (wordsActive.length < 1) {\r\n            curIndex = 0;\r\n            for (i = 0, len = wordBank.length; i < len; i++) {\r\n                if (wordBank[i].totalMatches < wordBank[curIndex].totalMatches) {\r\n                    curIndex = i;\r\n                }\r\n            }\r\n            wordBank[curIndex].successfulMatches = [{ x: 12, y: 12, dir: 0 }];\r\n        }\r\n        else {\r\n            curIndex = -1;\r\n\r\n            for (i = 0, len = wordBank.length; i < len; i++) {\r\n                curWord = wordBank[i];\r\n                curWord.effectiveMatches = 0;\r\n                curWord.successfulMatches = [];\r\n                for (var j = 0, lenJ = curWord.char.length; j < lenJ; j++) {\r\n                    if (j == 1) continue; // skip pos\r\n                    curChar = curWord.char[j];\r\n                    for (var k = 0, lenK = wordsActive.length; k < lenK; k++) {\r\n                        testWord = wordsActive[k];\r\n                        for (var l = 0, lenL = testWord.char.length; l < lenL; l++) {\r\n                            if (l == 1) continue; // skip pos\r\n                            testChar = testWord.char[l];\r\n                            if (curChar === testChar) {\r\n                                curWord.effectiveMatches++;\r\n\r\n                                var curCross = { x: testWord.x, y: testWord.y, dir: 0 };\r\n                                if (testWord.dir === 0) {\r\n                                    curCross.dir = 1;\r\n                                    curCross.x += l;\r\n                                    curCross.y -= j;\r\n                                }\r\n                                else {\r\n                                    curCross.dir = 0;\r\n                                    curCross.y += l;\r\n                                    curCross.x -= j;\r\n                                }\r\n\r\n                                var isMatch = true;\r\n\r\n                                for (var m = -1, lenM = curWord.char.length + 1; m < lenM; m++) {\r\n                                    var crossVal = [];\r\n                                    if (m !== j) {\r\n                                        if (curCross.dir === 0) {\r\n                                            var xIndex = curCross.x + m;\r\n\r\n                                            if (xIndex < 0 || xIndex > board.length) {\r\n                                                isMatch = false;\r\n                                                break;\r\n                                            }\r\n\r\n                                            crossVal.push(board[xIndex][curCross.y]);\r\n                                            crossVal.push(board[xIndex][curCross.y + 1]);\r\n                                            crossVal.push(board[xIndex][curCross.y - 1]);\r\n                                        }\r\n                                        else {\r\n                                            var yIndex = curCross.y + m;\r\n\r\n                                            if (yIndex < 0 || yIndex > board[curCross.x].length) {\r\n                                                isMatch = false;\r\n                                                break;\r\n                                            }\r\n\r\n                                            crossVal.push(board[curCross.x][yIndex]);\r\n                                            crossVal.push(board[curCross.x + 1][yIndex]);\r\n                                            crossVal.push(board[curCross.x - 1][yIndex]);\r\n                                        }\r\n\r\n                                        if (m > -1 && m < lenM - 1) {\r\n                                            if (crossVal[0] !== curWord.char[m]) {\r\n                                                if (crossVal[0] !== \"\") {\r\n                                                    isMatch = false;\r\n                                                    break;\r\n                                                }\r\n                                                else if (crossVal[1] !== null) {\r\n                                                    isMatch = false;\r\n                                                    break;\r\n                                                }\r\n                                                else if (crossVal[2] !== null) {\r\n                                                    isMatch = false;\r\n                                                    break;\r\n                                                }\r\n                                            }\r\n                                        }\r\n                                        else if (crossVal[0] !== null) {\r\n                                            isMatch = false;\r\n                                            break;\r\n                                        }\r\n                                    }\r\n                                }\r\n\r\n                                if (isMatch === true) {\r\n                                    curWord.successfulMatches.push(curCross);\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n\r\n                curMatchDiff = curWord.totalMatches - curWord.effectiveMatches;\r\n\r\n                if (curMatchDiff < minMatchDiff && curWord.successfulMatches.length > 0) {\r\n                    curMatchDiff = minMatchDiff;\r\n                    curIndex = i;\r\n                }\r\n                else if (curMatchDiff <= 0) {\r\n                    return false;\r\n                }\r\n            }\r\n        }\r\n\r\n        if (curIndex === -1) {\r\n            return false;\r\n        }\r\n\r\n        var spliced = wordBank.splice(curIndex, 1);\r\n        wordsActive.push(spliced[0]);\r\n\r\n        var pushIndex = wordsActive.length - 1,\r\n            rand = Math.random(),\r\n            matchArr = wordsActive[pushIndex].successfulMatches,\r\n            matchIndex = Math.floor(rand * matchArr.length),\r\n            matchData = matchArr[matchIndex];\r\n\r\n        wordsActive[pushIndex].x = matchData.x;\r\n        wordsActive[pushIndex].y = matchData.y;\r\n        wordsActive[pushIndex].dir = matchData.dir;\r\n\r\n        let actualIndex = findWordIdx(wordsActive[pushIndex].string);\r\n        console.log(wordsActive[pushIndex].string, \" ~~~ \", actualIndex);\r\n        for (i = 0, len = wordsActive[pushIndex].char.length; i < len; i++) {\r\n            var xIndex = matchData.x,\r\n                yIndex = matchData.y;\r\n\r\n            if (matchData.dir === 0) {\r\n                xIndex += i;\r\n            }\r\n            else {\r\n                yIndex += i;\r\n            }\r\n            board[xIndex][yIndex] = wordsActive[pushIndex].char[i];\r\n            isPos[xIndex][yIndex] = (i == 1);\r\n            if (actualIndex != undefined)\r\n                classesOfBoard[xIndex][yIndex].push(actualIndex);\r\n            console.log(xIndex, yIndex, classesOfBoard[xIndex][yIndex]);\r\n\r\n            Bounds.Update(xIndex, yIndex);\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    PopulateBoard()\r\n\r\n    const top = Bounds.top;\r\n    const bottom = Bounds.right;\r\n    const left = Bounds.left;\r\n    const right = Bounds.bottom;\r\n\r\n    console.log(\"top\", top);\r\n    console.log(\"bottom\", bottom);\r\n    console.log(\"left\", left);\r\n    console.log(\"right\", right);\r\n\r\n\r\n    const wordHeight = bottom - top + 1;\r\n    const wordWidth = right - left + 1;\r\n\r\n    let startRow = top;\r\n    let startCol = left;\r\n\r\n    if (wordHeight < cellWidth) {\r\n        // Center vertically\r\n        const padding = Math.floor((cellWidth - wordHeight) / 2);\r\n        startRow = Math.max(0, top - padding);\r\n    }\r\n\r\n    if (wordWidth < cellWidth) {\r\n        // Center horizontally\r\n        const padding = Math.floor((cellWidth - wordWidth) / 2);\r\n        startCol = Math.max(0, left - padding);\r\n    }\r\n\r\n    // Ensure we don't go out of bounds\r\n    startRow = Math.min(startRow, 100 - cellWidth);\r\n    startCol = Math.min(startCol, 100 - cellWidth);\r\n\r\n    // --- Slice the square region ---\r\n    const slicedBoard = board.slice(startRow, startRow + cellWidth).map(row =>\r\n        row.slice(startCol, startCol + cellWidth)\r\n    );\r\n\r\n    return board;\r\n\r\n}\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}