{"ast":null,"code":"import React from \"react\";\n\n// Define word object structure\nimport { Fragment as _Fragment, jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst CrosswordGrid = ({\n  placedWords,\n  boardSize = 20\n}) => {\n  // 0: horizontal, 1: vertical\n\n  const GRID_SIZE = 18;\n  const EMPTY_CELL = ' ';\n  function createEmptyGrid(size) {\n    return Array.from({\n      length: size\n    }, () => Array(size).fill(EMPTY_CELL));\n  }\n  var classesOfBoard = [];\n  var isPos = [];\n  var Bounds = {\n    top: 0,\n    right: 0,\n    bottom: 0,\n    left: 0,\n    Update: function (x, y) {\n      this.top = Math.min(y, this.top);\n      this.right = Math.max(x, this.right);\n      this.bottom = Math.max(y, this.bottom);\n      this.left = Math.min(x, this.left);\n    },\n    Clean: function () {\n      this.top = 999;\n      this.right = 0;\n      this.bottom = 0;\n      this.left = 999;\n    }\n  };\n  const board = createEmptyGrid(GRID_SIZE);\n  let wordsActive = [];\n  let wordBank = [];\n  const wordArr = ['GIÓ', 'HẠTGIỐNG', 'DREAM', 'THUỐC', 'CÚC', 'CHÂUKIỆTLUÂN'];\n  // function PopulateBoard(){\n  //     PrepareBoard();\n\n  //     for(var i=0,isOk=true,len=wordBank.length; i<len && isOk; i++){\n  //       isOk = AddWordToBoard();\n  //     }\n  //     return isOk;\n  //   }\n\n  // function PrepareBoard(){\n  //   wordBank=[];\n\n  //   for(var i = 0, len = wordArr.length; i < len; i++){\n  //     let actualPos = i+1;\n  //     wordBank.push(new WordObj(' '+actualPos.toString()+wordArr[i]+' '));\n  //   }\n\n  //   for(i = 0; i < wordBank.length; i++){\n  //     for(var j = 0, wA=wordBank[i]; j<wA.char.length; j++){\n  //       for(var k = 0, cA=wA.char[j]; k<wordBank.length; k++){\n  //         for(var l = 0,wB=wordBank[k]; k!==i && l<wB.char.length; l++){\n  //           wA.totalMatches += (cA === wB.char[l])?1:0;\n  //         }\n  //       }\n  //     }\n  //   }\n  // }\n\n  function findWordIdx(givenWord) {\n    givenWord = givenWord.substring(2, givenWord.length - 1);\n    for (var i = 0, len = wordArr.length; i < len; i++) {\n      if (givenWord == wordArr[i]) return i + 1;\n    }\n  }\n\n  // TODO: Clean this guy up\n  function AddWordToBoard() {\n    var i,\n      len,\n      curIndex,\n      curWord,\n      curChar,\n      curMatch,\n      testWord,\n      testChar,\n      minMatchDiff = 9999,\n      curMatchDiff;\n    if (wordsActive.length < 1) {\n      curIndex = 0;\n      for (i = 0, len = wordBank.length; i < len; i++) {\n        if (wordBank[i].totalMatches < wordBank[curIndex].totalMatches) {\n          curIndex = i;\n        }\n      }\n      wordBank[curIndex].successfulMatches = [{\n        x: 12,\n        y: 12,\n        dir: 0\n      }];\n    } else {\n      curIndex = -1;\n      for (i = 0, len = wordBank.length; i < len; i++) {\n        curWord = wordBank[i];\n        curWord.effectiveMatches = 0;\n        curWord.successfulMatches = [];\n        for (var j = 0, lenJ = curWord.char.length; j < lenJ; j++) {\n          if (j == 1) continue; // skip pos\n          curChar = curWord.char[j];\n          for (var k = 0, lenK = wordsActive.length; k < lenK; k++) {\n            testWord = wordsActive[k];\n            for (var l = 0, lenL = testWord.char.length; l < lenL; l++) {\n              if (l == 1) continue; // skip pos\n              testChar = testWord.char[l];\n              if (curChar === testChar) {\n                curWord.effectiveMatches++;\n                var curCross = {\n                  x: testWord.x,\n                  y: testWord.y,\n                  dir: 0\n                };\n                if (testWord.dir === 0) {\n                  curCross.dir = 1;\n                  curCross.x += l;\n                  curCross.y -= j;\n                } else {\n                  curCross.dir = 0;\n                  curCross.y += l;\n                  curCross.x -= j;\n                }\n                var isMatch = true;\n                for (var m = -1, lenM = curWord.char.length + 1; m < lenM; m++) {\n                  var crossVal = [];\n                  if (m !== j) {\n                    if (curCross.dir === 0) {\n                      var xIndex = curCross.x + m;\n                      if (xIndex < 0 || xIndex > board.length) {\n                        isMatch = false;\n                        break;\n                      }\n                      crossVal.push(board[xIndex][curCross.y]);\n                      crossVal.push(board[xIndex][curCross.y + 1]);\n                      crossVal.push(board[xIndex][curCross.y - 1]);\n                    } else {\n                      var yIndex = curCross.y + m;\n                      if (yIndex < 0 || yIndex > board[curCross.x].length) {\n                        isMatch = false;\n                        break;\n                      }\n                      crossVal.push(board[curCross.x][yIndex]);\n                      crossVal.push(board[curCross.x + 1][yIndex]);\n                      crossVal.push(board[curCross.x - 1][yIndex]);\n                    }\n                    if (m > -1 && m < lenM - 1) {\n                      if (crossVal[0] !== curWord.char[m]) {\n                        if (crossVal[0] !== null) {\n                          isMatch = false;\n                          break;\n                        } else if (crossVal[1] !== null) {\n                          isMatch = false;\n                          break;\n                        } else if (crossVal[2] !== null) {\n                          isMatch = false;\n                          break;\n                        }\n                      }\n                    } else if (crossVal[0] !== null) {\n                      isMatch = false;\n                      break;\n                    }\n                  }\n                }\n                if (isMatch === true) {\n                  curWord.successfulMatches.push(curCross);\n                }\n              }\n            }\n          }\n        }\n        curMatchDiff = curWord.totalMatches - curWord.effectiveMatches;\n        if (curMatchDiff < minMatchDiff && curWord.successfulMatches.length > 0) {\n          curMatchDiff = minMatchDiff;\n          curIndex = i;\n        } else if (curMatchDiff <= 0) {\n          return false;\n        }\n      }\n    }\n    if (curIndex === -1) {\n      return false;\n    }\n    var spliced = wordBank.splice(curIndex, 1);\n    wordsActive.push(spliced[0]);\n    var pushIndex = wordsActive.length - 1,\n      rand = Math.random(),\n      matchArr = wordsActive[pushIndex].successfulMatches,\n      matchIndex = Math.floor(rand * matchArr.length),\n      matchData = matchArr[matchIndex];\n    wordsActive[pushIndex].x = matchData.x;\n    wordsActive[pushIndex].y = matchData.y;\n    wordsActive[pushIndex].dir = matchData.dir;\n    let actualIndex = findWordIdx(wordsActive[pushIndex].string);\n    console.log(wordsActive[pushIndex].string, \" ~~~ \", actualIndex);\n    for (i = 0, len = wordsActive[pushIndex].char.length; i < len; i++) {\n      var xIndex = matchData.x,\n        yIndex = matchData.y;\n      if (matchData.dir === 0) {\n        xIndex += i;\n      } else {\n        yIndex += i;\n      }\n      board[xIndex][yIndex] = wordsActive[pushIndex].char[i];\n      isPos[xIndex][yIndex] = i == 1;\n      classesOfBoard[xIndex][yIndex].push(actualIndex);\n      console.log(xIndex, yIndex, classesOfBoard[xIndex][yIndex]);\n      Bounds.Update(xIndex, yIndex);\n    }\n    return true;\n  }\n  AddWordToBoard();\n  console.log(board);\n  return /*#__PURE__*/_jsxDEV(_Fragment, {}, void 0, false);\n};\n_c = CrosswordGrid;\nexport default CrosswordGrid;\nvar _c;\n$RefreshReg$(_c, \"CrosswordGrid\");","map":{"version":3,"names":["React","Fragment","_Fragment","jsxDEV","_jsxDEV","CrosswordGrid","placedWords","boardSize","GRID_SIZE","EMPTY_CELL","createEmptyGrid","size","Array","from","length","fill","classesOfBoard","isPos","Bounds","top","right","bottom","left","Update","x","y","Math","min","max","Clean","board","wordsActive","wordBank","wordArr","findWordIdx","givenWord","substring","i","len","AddWordToBoard","curIndex","curWord","curChar","curMatch","testWord","testChar","minMatchDiff","curMatchDiff","totalMatches","successfulMatches","dir","effectiveMatches","j","lenJ","char","k","lenK","l","lenL","curCross","isMatch","m","lenM","crossVal","xIndex","push","yIndex","spliced","splice","pushIndex","rand","random","matchArr","matchIndex","floor","matchData","actualIndex","string","console","log","_c","$RefreshReg$"],"sources":["C:/Users/ASUS/Documents/htm_fe/src/pages/Host/Management/HostRound2.tsx"],"sourcesContent":["import React, { useState, useEffect } from \"react\";\r\n\r\n// Define word object structure\r\n\r\ntype WordPlacement = {\r\n  x: number;\r\n  y: number;\r\n  dir: 0 | 1;\r\n};\r\n\r\ninterface CrosswordGridProps {\r\n  placedWords?: WordPlacement[];\r\n  boardSize?: number;\r\n}\r\n\r\n\r\n\r\nconst CrosswordGrid: React.FC<CrosswordGridProps> = ({ placedWords, boardSize = 20 }) => {\r\n\r\n  type Direction = 0 | 1; // 0: horizontal, 1: vertical\r\n\r\n  interface Match {\r\n    x: number,\r\n    y: number,\r\n    dir: 0 | 1\r\n  }\r\n\r\n  interface WordPlacement {\r\n    word: string;\r\n    x: number;\r\n    y: number;\r\n    dir: Direction;\r\n    successfulMatches: Match[];\r\n    totalMatches: number;\r\n    effectiveMatches: number;\r\n    char: string[];\r\n    string: string;\r\n  }\r\n\r\n  const GRID_SIZE = 18;\r\n  const EMPTY_CELL = ' ';\r\n\r\n  function createEmptyGrid(size: number): string[][] {\r\n    return Array.from({ length: size }, () => Array(size).fill(EMPTY_CELL));\r\n  }\r\n  var classesOfBoard: any[] = []\r\n  var isPos: any[] = []\r\n  var Bounds = {\r\n    top: 0, right: 0, bottom: 0, left: 0,\r\n\r\n    Update: function (x: number, y: number) {\r\n      this.top = Math.min(y, this.top);\r\n      this.right = Math.max(x, this.right);\r\n      this.bottom = Math.max(y, this.bottom);\r\n      this.left = Math.min(x, this.left);\r\n    },\r\n\r\n    Clean: function () {\r\n      this.top = 999;\r\n      this.right = 0;\r\n      this.bottom = 0;\r\n      this.left = 999;\r\n    }\r\n  };\r\n\r\n  const board = createEmptyGrid(GRID_SIZE)\r\n  let wordsActive: WordPlacement[] = []\r\n  let wordBank: WordPlacement[] = []\r\n  const wordArr = [\r\n    'GIÓ',\r\n    'HẠTGIỐNG',\r\n    'DREAM',\r\n    'THUỐC',\r\n    'CÚC',\r\n    'CHÂUKIỆTLUÂN',\r\n  ]\r\n  // function PopulateBoard(){\r\n  //     PrepareBoard();\r\n\r\n  //     for(var i=0,isOk=true,len=wordBank.length; i<len && isOk; i++){\r\n  //       isOk = AddWordToBoard();\r\n  //     }\r\n  //     return isOk;\r\n  //   }\r\n\r\n\r\n  // function PrepareBoard(){\r\n  //   wordBank=[];\r\n\r\n  //   for(var i = 0, len = wordArr.length; i < len; i++){\r\n  //     let actualPos = i+1;\r\n  //     wordBank.push(new WordObj(' '+actualPos.toString()+wordArr[i]+' '));\r\n  //   }\r\n\r\n  //   for(i = 0; i < wordBank.length; i++){\r\n  //     for(var j = 0, wA=wordBank[i]; j<wA.char.length; j++){\r\n  //       for(var k = 0, cA=wA.char[j]; k<wordBank.length; k++){\r\n  //         for(var l = 0,wB=wordBank[k]; k!==i && l<wB.char.length; l++){\r\n  //           wA.totalMatches += (cA === wB.char[l])?1:0;\r\n  //         }\r\n  //       }\r\n  //     }\r\n  //   }\r\n  // }\r\n\r\n  function findWordIdx(givenWord: string) {\r\n    givenWord = givenWord.substring(2, givenWord.length - 1);\r\n    for (var i = 0, len = wordArr.length; i < len; i++) {\r\n      if (givenWord == wordArr[i]) return i + 1;\r\n    }\r\n  }\r\n\r\n  // TODO: Clean this guy up\r\n  function AddWordToBoard() {\r\n    var i, len, curIndex, curWord, curChar, curMatch, testWord, testChar,\r\n      minMatchDiff = 9999, curMatchDiff;\r\n\r\n    if (wordsActive.length < 1) {\r\n      curIndex = 0;\r\n      for (i = 0, len = wordBank.length; i < len; i++) {\r\n        if (wordBank[i].totalMatches < wordBank[curIndex].totalMatches) {\r\n          curIndex = i;\r\n        }\r\n      }\r\n      wordBank[curIndex].successfulMatches = [{ x: 12, y: 12, dir: 0 }];\r\n    }\r\n    else {\r\n      curIndex = -1;\r\n\r\n      for (i = 0, len = wordBank.length; i < len; i++) {\r\n        curWord = wordBank[i];\r\n        curWord.effectiveMatches = 0;\r\n        curWord.successfulMatches = [];\r\n        for (var j = 0, lenJ = curWord.char.length; j < lenJ; j++) {\r\n          if (j == 1) continue; // skip pos\r\n          curChar = curWord.char[j];\r\n          for (var k = 0, lenK = wordsActive.length; k < lenK; k++) {\r\n            testWord = wordsActive[k];\r\n            for (var l = 0, lenL = testWord.char.length; l < lenL; l++) {\r\n              if (l == 1) continue; // skip pos\r\n              testChar = testWord.char[l];\r\n              if (curChar === testChar) {\r\n                curWord.effectiveMatches++;\r\n\r\n                var curCross: Match = { x: testWord.x, y: testWord.y, dir: 0 };\r\n                if (testWord.dir === 0) {\r\n                  curCross.dir = 1;\r\n                  curCross.x += l;\r\n                  curCross.y -= j;\r\n                }\r\n                else {\r\n                  curCross.dir = 0;\r\n                  curCross.y += l;\r\n                  curCross.x -= j;\r\n                }\r\n\r\n                var isMatch = true;\r\n\r\n                for (var m = -1, lenM = curWord.char.length + 1; m < lenM; m++) {\r\n                  var crossVal = [];\r\n                  if (m !== j) {\r\n                    if (curCross.dir === 0) {\r\n                      var xIndex = curCross.x + m;\r\n\r\n                      if (xIndex < 0 || xIndex > board.length) {\r\n                        isMatch = false;\r\n                        break;\r\n                      }\r\n\r\n                      crossVal.push(board[xIndex][curCross.y]);\r\n                      crossVal.push(board[xIndex][curCross.y + 1]);\r\n                      crossVal.push(board[xIndex][curCross.y - 1]);\r\n                    }\r\n                    else {\r\n                      var yIndex = curCross.y + m;\r\n\r\n                      if (yIndex < 0 || yIndex > board[curCross.x].length) {\r\n                        isMatch = false;\r\n                        break;\r\n                      }\r\n\r\n                      crossVal.push(board[curCross.x][yIndex]);\r\n                      crossVal.push(board[curCross.x + 1][yIndex]);\r\n                      crossVal.push(board[curCross.x - 1][yIndex]);\r\n                    }\r\n\r\n                    if (m > -1 && m < lenM - 1) {\r\n                      if (crossVal[0] !== curWord.char[m]) {\r\n                        if (crossVal[0] !== null) {\r\n                          isMatch = false;\r\n                          break;\r\n                        }\r\n                        else if (crossVal[1] !== null) {\r\n                          isMatch = false;\r\n                          break;\r\n                        }\r\n                        else if (crossVal[2] !== null) {\r\n                          isMatch = false;\r\n                          break;\r\n                        }\r\n                      }\r\n                    }\r\n                    else if (crossVal[0] !== null) {\r\n                      isMatch = false;\r\n                      break;\r\n                    }\r\n                  }\r\n                }\r\n\r\n                if (isMatch === true) {\r\n                  curWord.successfulMatches.push(curCross);\r\n                }\r\n              }\r\n            }\r\n          }\r\n        }\r\n\r\n        curMatchDiff = curWord.totalMatches - curWord.effectiveMatches;\r\n\r\n        if (curMatchDiff < minMatchDiff && curWord.successfulMatches.length > 0) {\r\n          curMatchDiff = minMatchDiff;\r\n          curIndex = i;\r\n        }\r\n        else if (curMatchDiff <= 0) {\r\n          return false;\r\n        }\r\n      }\r\n    }\r\n\r\n    if (curIndex === -1) {\r\n      return false;\r\n    }\r\n\r\n    var spliced = wordBank.splice(curIndex, 1);\r\n    wordsActive.push(spliced[0]);\r\n\r\n    var pushIndex = wordsActive.length - 1,\r\n      rand = Math.random(),\r\n      matchArr = wordsActive[pushIndex].successfulMatches,\r\n      matchIndex = Math.floor(rand * matchArr.length),\r\n      matchData = matchArr[matchIndex];\r\n\r\n    wordsActive[pushIndex].x = matchData.x;\r\n    wordsActive[pushIndex].y = matchData.y;\r\n    wordsActive[pushIndex].dir = matchData.dir;\r\n\r\n    let actualIndex = findWordIdx(wordsActive[pushIndex].string);\r\n    console.log(wordsActive[pushIndex].string, \" ~~~ \", actualIndex);\r\n    for (i = 0, len = wordsActive[pushIndex].char.length; i < len; i++) {\r\n      var xIndex = matchData.x,\r\n        yIndex = matchData.y;\r\n\r\n      if (matchData.dir === 0) {\r\n        xIndex += i;\r\n      }\r\n      else {\r\n        yIndex += i;\r\n      }\r\n      board[xIndex][yIndex] = wordsActive[pushIndex].char[i];\r\n      isPos[xIndex][yIndex] = (i == 1);\r\n      classesOfBoard[xIndex][yIndex].push(actualIndex);\r\n      console.log(xIndex, yIndex, classesOfBoard[xIndex][yIndex]);\r\n\r\n      Bounds.Update(xIndex, yIndex);\r\n    }\r\n\r\n    return true;\r\n  }\r\n\r\n  AddWordToBoard()\r\n  console.log(board);\r\n  \r\n\r\n  return (\r\n    <>\r\n    </>\r\n  );\r\n};\r\n\r\nexport default CrosswordGrid;\r\n\r\n\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}