{"ast":null,"code":"import React from \"react\";\n\n// Define word object structure\nimport { Fragment as _Fragment, jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst CrosswordGrid = ({\n  placedWords,\n  boardSize = 20\n}) => {\n  // 1. Create initial grid\n  function createEmptyGrid(width, height) {\n    return Array.from({\n      length: height\n    }, () => Array.from({\n      length: width\n    }, () => null));\n  }\n\n  // 2. Convert word to WordObj\n  function wordToObj(word, index) {\n    return {\n      string: `${index + 1}${word}`,\n      char: ` ${index + 1}${word} `.split(''),\n      dir: 0,\n      x: -1,\n      y: -1,\n      totalMatches: 0,\n      effectiveMatches: 0,\n      successfulMatches: []\n    };\n  }\n\n  // 3. Check if a word can be placed\n  function canPlaceWord(grid, word, x, y, dir) {\n    const {\n      char\n    } = word;\n    for (let i = 0; i < char.length; i++) {\n      const xi = dir === 0 ? x + i : x;\n      const yi = dir === 1 ? y + i : y;\n      if (yi >= grid.length || xi >= grid[0].length) return false;\n      const cell = grid[yi][xi];\n      if (cell && cell.char !== char[i]) return false;\n    }\n    return true;\n  }\n\n  // 4. Place word on grid\n  function placeWord(grid, word, x, y, dir, index) {\n    word.x = x;\n    word.y = y;\n    word.dir = dir;\n    for (let i = 0; i < word.char.length; i++) {\n      const xi = dir === 0 ? x + i : x;\n      const yi = dir === 1 ? y + i : y;\n      grid[yi][xi] = {\n        char: word.char[i],\n        wordIndex: index\n      };\n    }\n  }\n\n  // 5. Try placing word with maximum overlap\n  function tryPlaceWithOverlap(grid, words, word, index) {\n    let bestPlacement = null;\n    let maxMatches = 0;\n    for (let placedWord of words) {\n      for (let i = 0; i < placedWord.char.length; i++) {\n        for (let j = 0; j < word.char.length; j++) {\n          if (placedWord.char[i] !== word.char[j]) continue;\n          const dir = placedWord.dir === 0 ? 1 : 0;\n          const x = placedWord.x + (placedWord.dir === 0 ? i : 0) - (dir === 0 ? j : 0);\n          const y = placedWord.y + (placedWord.dir === 1 ? i : 0) - (dir === 1 ? j : 0);\n          if (canPlaceWord(grid, word, x, y, dir)) {\n            const matches = countEffectiveMatches(grid, word, x, y, dir);\n            if (matches > maxMatches) {\n              maxMatches = matches;\n              bestPlacement = {\n                x,\n                y,\n                dir\n              };\n            }\n          }\n        }\n      }\n    }\n    if (bestPlacement) {\n      placeWord(grid, word, bestPlacement.x, bestPlacement.y, bestPlacement.dir, index);\n      word.effectiveMatches = maxMatches;\n      return true;\n    }\n    return false;\n  }\n\n  // 6. Count effective matches at a given position\n  function countEffectiveMatches(grid, word, x, y, dir) {\n    let count = 0;\n    for (let i = 0; i < word.char.length; i++) {\n      var _grid$yi;\n      const xi = dir === 0 ? x + i : x;\n      const yi = dir === 1 ? y + i : y;\n      const cell = (_grid$yi = grid[yi]) === null || _grid$yi === void 0 ? void 0 : _grid$yi[xi];\n      if (cell && cell.char === word.char[i]) count++;\n    }\n    return count;\n  }\n\n  // 7. Main logic to place all words\n  function placeWords(wordList) {\n    const grid = createEmptyGrid(50, 50);\n    const words = wordList.map(wordToObj);\n    placeWord(grid, words[0], 12, 12, 0, 0);\n    for (let i = 1; i < words.length; i++) {\n      if (!tryPlaceWithOverlap(grid, words.slice(0, i), words[i], i)) {\n        // fallback: just place it further down if overlap fails\n        placeWord(grid, words[i], 2, 2 + i * 5, 0, i);\n      }\n    }\n    return words;\n  }\n  return /*#__PURE__*/_jsxDEV(_Fragment, {}, void 0, false);\n};\n_c = CrosswordGrid;\nexport default CrosswordGrid;\n\n// Main React Component\nconst WordBoard = () => {\n  // TypeScript version of the crossword builder with shuffled letter matches\n\n  return /*#__PURE__*/_jsxDEV(_Fragment, {}, void 0, false);\n};\n_c2 = WordBoard;\nvar _c, _c2;\n$RefreshReg$(_c, \"CrosswordGrid\");\n$RefreshReg$(_c2, \"WordBoard\");","map":{"version":3,"names":["React","Fragment","_Fragment","jsxDEV","_jsxDEV","CrosswordGrid","placedWords","boardSize","createEmptyGrid","width","height","Array","from","length","wordToObj","word","index","string","char","split","dir","x","y","totalMatches","effectiveMatches","successfulMatches","canPlaceWord","grid","i","xi","yi","cell","placeWord","wordIndex","tryPlaceWithOverlap","words","bestPlacement","maxMatches","placedWord","j","matches","countEffectiveMatches","count","_grid$yi","placeWords","wordList","map","slice","_c","WordBoard","_c2","$RefreshReg$"],"sources":["C:/Users/ASUS/Documents/htm_fe/src/pages/Host/Management/HostRound2.tsx"],"sourcesContent":["import React, { useState, useEffect } from \"react\";\r\n\r\n// Define word object structure\r\n\r\ntype WordPlacement = {\r\n  word: string;\r\n  x: number;\r\n  y: number;\r\n  direction: \"horizontal\" | \"vertical\";\r\n};\r\n\r\ninterface CrosswordGridProps {\r\n  placedWords?: WordPlacement[];\r\n  boardSize?: number;\r\n}\r\n\r\nconst CrosswordGrid: React.FC<CrosswordGridProps> = ({ placedWords, boardSize = 20 }) => {\r\n\r\n  interface WordObj {\r\n  string: string;\r\n  char: string[];\r\n  dir: 0 | 1; // 0 = horizontal, 1 = vertical\r\n  x: number;\r\n  y: number;\r\n  totalMatches: number;\r\n  effectiveMatches: number;\r\n  successfulMatches: { x: number; y: number }[];\r\n}\r\n\r\ninterface GridCell {\r\n  char: string;\r\n  wordIndex: number;\r\n}\r\n\r\ntype Grid = (GridCell | null)[][];\r\n\r\n// 1. Create initial grid\r\nfunction createEmptyGrid(width: number, height: number): Grid {\r\n  return Array.from({ length: height }, () => Array.from({ length: width }, () => null));\r\n}\r\n\r\n// 2. Convert word to WordObj\r\nfunction wordToObj(word: string, index: number): WordObj {\r\n  return {\r\n    string: `${index + 1}${word}`,\r\n    char: (` ${index + 1}${word} `).split(''),\r\n    dir: 0,\r\n    x: -1,\r\n    y: -1,\r\n    totalMatches: 0,\r\n    effectiveMatches: 0,\r\n    successfulMatches: [],\r\n  };\r\n}\r\n\r\n// 3. Check if a word can be placed\r\nfunction canPlaceWord(grid: Grid, word: WordObj, x: number, y: number, dir: 0 | 1): boolean {\r\n  const { char } = word;\r\n  for (let i = 0; i < char.length; i++) {\r\n    const xi = dir === 0 ? x + i : x;\r\n    const yi = dir === 1 ? y + i : y;\r\n    if (yi >= grid.length || xi >= grid[0].length) return false;\r\n\r\n    const cell = grid[yi][xi];\r\n    if (cell && cell.char !== char[i]) return false;\r\n  }\r\n  return true;\r\n}\r\n\r\n// 4. Place word on grid\r\nfunction placeWord(grid: Grid, word: WordObj, x: number, y: number, dir: 0 | 1, index: number): void {\r\n  word.x = x;\r\n  word.y = y;\r\n  word.dir = dir;\r\n  for (let i = 0; i < word.char.length; i++) {\r\n    const xi = dir === 0 ? x + i : x;\r\n    const yi = dir === 1 ? y + i : y;\r\n    grid[yi][xi] = { char: word.char[i], wordIndex: index };\r\n  }\r\n}\r\n\r\n// 5. Try placing word with maximum overlap\r\nfunction tryPlaceWithOverlap(grid: Grid, words: WordObj[], word: WordObj, index: number): boolean {\r\n  let bestPlacement = null;\r\n  let maxMatches = 0;\r\n\r\n  for (let placedWord of words) {\r\n    for (let i = 0; i < placedWord.char.length; i++) {\r\n      for (let j = 0; j < word.char.length; j++) {\r\n        if (placedWord.char[i] !== word.char[j]) continue;\r\n\r\n        const dir = placedWord.dir === 0 ? 1 : 0;\r\n        const x = placedWord.x + (placedWord.dir === 0 ? i : 0) - (dir === 0 ? j : 0);\r\n        const y = placedWord.y + (placedWord.dir === 1 ? i : 0) - (dir === 1 ? j : 0);\r\n\r\n        if (canPlaceWord(grid, word, x, y, dir)) {\r\n          const matches = countEffectiveMatches(grid, word, x, y, dir);\r\n          if (matches > maxMatches) {\r\n            maxMatches = matches;\r\n            bestPlacement = { x, y, dir };\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  if (bestPlacement) {\r\n    placeWord(grid, word, bestPlacement.x, bestPlacement.y, bestPlacement.dir as 0|1, index);\r\n    word.effectiveMatches = maxMatches;\r\n    return true;\r\n  }\r\n\r\n  return false;\r\n}\r\n\r\n// 6. Count effective matches at a given position\r\nfunction countEffectiveMatches(grid: Grid, word: WordObj, x: number, y: number, dir: 0 | 1): number {\r\n  let count = 0;\r\n  for (let i = 0; i < word.char.length; i++) {\r\n    const xi = dir === 0 ? x + i : x;\r\n    const yi = dir === 1 ? y + i : y;\r\n    const cell = grid[yi]?.[xi];\r\n    if (cell && cell.char === word.char[i]) count++;\r\n  }\r\n  return count;\r\n}\r\n\r\n// 7. Main logic to place all words\r\nfunction placeWords(wordList: string[]): WordObj[] {\r\n  const grid = createEmptyGrid(50, 50);\r\n  const words: WordObj[] = wordList.map(wordToObj);\r\n\r\n  placeWord(grid, words[0], 12, 12, 0, 0);\r\n\r\n  for (let i = 1; i < words.length; i++) {\r\n    if (!tryPlaceWithOverlap(grid, words.slice(0, i), words[i], i)) {\r\n      // fallback: just place it further down if overlap fails\r\n      placeWord(grid, words[i], 2, 2 + i * 5, 0, i);\r\n    }\r\n  }\r\n\r\n  return words;\r\n}\r\n\r\n  return (\r\n    <>\r\n    </>\r\n  );\r\n};\r\n\r\nexport default CrosswordGrid;\r\n\r\n\r\n// Main React Component\r\nconst WordBoard: React.FC = () => {\r\n  // TypeScript version of the crossword builder with shuffled letter matches\r\n\r\n  \r\n\r\n  return (\r\n    <>\r\n    </>\r\n  );\r\n};\r\n\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}