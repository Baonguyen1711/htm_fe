{"ast":null,"code":"function generateCrossword(wordList, board) {\n  // Kiểm tra đầu vào\n  if (!Array.isArray(wordList) || wordList.length !== 6 || !wordList.every(w => typeof w === 'string')) {\n    return {\n      board: [],\n      wordsActive: [],\n      success: false,\n      message: 'wordList must be an array of 6 strings'\n    };\n  }\n  if (!Array.isArray(board) || board.length === 0 || board[0].length !== 20) {\n    board = Array.from({\n      length: 20\n    }, () => Array(20).fill(null));\n  }\n\n  // Khởi tạo cấu trúc dữ liệu\n  const wordsActive = [];\n  const wordBank = wordList.map((word, idx) => ({\n    string: word.toUpperCase(),\n    char: word.toUpperCase().split(''),\n    index: idx,\n    successfulMatches: [],\n    totalMatches: 0,\n    effectiveMatches: 0\n  }));\n  const bounds = {\n    minX: 0,\n    maxX: 0,\n    minY: 0,\n    maxY: 0,\n    update: function (x, y) {\n      this.minX = Math.min(this.minX, x);\n      this.maxX = Math.max(this.maxX, x);\n      this.minY = Math.min(this.minY, y);\n      this.maxY = Math.max(this.maxY, y);\n    }\n  };\n\n  // Hàm kiểm tra xem ô có hợp lệ để đặt ký tự không\n  function isValidPosition(x, y, char, board, dir, word, i) {\n    if (x < 0 || x >= board.length || y < 0 || y >= board[0].length) return false;\n    if (board[x][y] === null) return true;\n    if (board[x][y] === char) {\n      // Kiểm tra xung đột với từ khác tại giao điểm\n      const crossDir = dir === 0 ? 1 : 0;\n      const crossVal = [crossDir === 0 ? x > 0 ? board[x - 1][y] : null : y > 0 ? board[x][y - 1] : null, board[x][y], crossDir === 0 ? x < board.length - 1 ? board[x + 1][y] : null : y < board[0].length - 1 ? board[x][y + 1] : null];\n      return crossVal[0] === null && crossVal[2] === null && board[x][y] === char;\n    }\n    return false;\n  }\n\n  // Hàm mở rộng bảng nếu cần\n  function expandBoard(board, x, y) {\n    while (x >= board.length) {\n      board.push(Array(board[0].length).fill(null));\n    }\n    while (y >= board[0].length) {\n      for (let i = 0; i < board.length; i++) {\n        board[i].push(null);\n      }\n    }\n  }\n\n  // Hàm tìm các vị trí giao nhau hợp lệ cho một từ\n  function findMatches(word, board, wordsActive) {\n    word.successfulMatches = [];\n    word.totalMatches = 0;\n    word.effectiveMatches = 0;\n    if (wordsActive.length === 0) {\n      // Nếu bảng rỗng, đặt từ đầu tiên ở giữa\n      const x = Math.floor(board.length / 2);\n      const y = Math.floor(board[0].length / 2);\n      const dir = Math.random() < 0.5 ? 0 : 1;\n      word.successfulMatches.push({\n        x,\n        y,\n        dir\n      });\n      word.totalMatches = 1;\n      word.effectiveMatches = 1;\n      return;\n    }\n    for (const placedWord of wordsActive) {\n      for (let i = 0; i < word.char.length; i++) {\n        for (let k = 0; k < placedWord.char.length; k++) {\n          if (word.char[i] === placedWord.char[k]) {\n            word.totalMatches++;\n            // Thử đặt từ theo hướng ngang (dir=0) và dọc (dir=1)\n            for (let dir = 0; dir <= 1; dir++) {\n              const x = dir === 0 ? placedWord.x + k - i : placedWord.x + k;\n              const y = dir === 0 ? placedWord.y : placedWord.y - i;\n              let isValid = true;\n              // Kiểm tra toàn bộ từ có thể đặt được không\n              for (let m = 0; m < word.char.length; m++) {\n                const xPos = dir === 0 ? x + m : x;\n                const yPos = dir === 0 ? y : y + m;\n                expandBoard(board, xPos, yPos);\n                if (!isValidPosition(xPos, yPos, word.char[m], board, dir, word, m)) {\n                  isValid = false;\n                  break;\n                }\n              }\n              if (isValid) {\n                word.successfulMatches.push({\n                  x,\n                  y,\n                  dir\n                });\n                word.effectiveMatches++;\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n\n  // Hàm đặt từ lên bảng\n  function placeWord(word, board, wordsActive) {\n    if (word.successfulMatches.length === 0) return false;\n\n    // Chọn ngẫu nhiên một vị trí giao nhau hợp lệ\n    const matchIndex = Math.floor(Math.random() * word.successfulMatches.length);\n    const matchData = word.successfulMatches[matchIndex];\n\n    // Cập nhật thông tin từ\n    word.x = matchData.x;\n    word.y = matchData.y;\n    word.dir = matchData.dir;\n\n    // Đặt từng ký tự lên bảng\n    for (let i = 0; i < word.char.length; i++) {\n      const xIndex = matchData.dir === 0 ? matchData.x + i : matchData.x;\n      const yIndex = matchData.dir === 0 ? matchData.y : matchData.y + i;\n      expandBoard(board, xIndex, yIndex);\n      board[xIndex][yIndex] = word.char[i];\n      bounds.update(xIndex, yIndex);\n    }\n    wordsActive.push(word);\n    return true;\n  }\n\n  // Hàm chính để đặt tất cả từ\n  while (wordBank.length > 0) {\n    let minMatchDiff = Infinity;\n    let curIndex = -1;\n\n    // Tìm từ tốt nhất để đặt\n    for (let i = 0; i < wordBank.length; i++) {\n      const curWord = wordBank[i];\n      findMatches(curWord, board, wordsActive);\n      const curMatchDiff = curWord.totalMatches - curWord.effectiveMatches;\n      if (curMatchDiff < minMatchDiff && curWord.successfulMatches.length > 0) {\n        minMatchDiff = curMatchDiff;\n        curIndex = i;\n      }\n    }\n    if (curIndex === -1) {\n      return {\n        board,\n        wordsActive,\n        success: false,\n        message: 'Failed to place all words'\n      };\n    }\n\n    // Đặt từ và loại khỏi wordBank\n    const wordToPlace = wordBank.splice(curIndex, 1)[0];\n    if (!placeWord(wordToPlace, board, wordsActive)) {\n      return {\n        board,\n        wordsActive,\n        success: false,\n        message: 'Failed to place word'\n      };\n    }\n  }\n\n  // Cắt bảng theo bounds để trả về kích thước tối thiểu\n  const trimmedBoard = [];\n  for (let x = bounds.minX; x <= bounds.maxX; x++) {\n    const row = board[x].slice(bounds.minY, bounds.maxY + 1);\n    trimmedBoard.push(row);\n  }\n  return {\n    board: trimmedBoard,\n    wordsActive,\n    success: true\n  };\n}\n\n// Ví dụ sử dụng\nconst wordList = ['CROSSWORD', 'PUZZLE', 'GRID', 'WORD', 'CLUE', 'GAME'];\nconst board = Array.from({\n  length: 20\n}, () => Array(20).fill(null));\nconst result = generateCrossword(wordList, board);\nconsole.log('Success:', result.success);\nconsole.log('Words Active:', result.wordsActive);\nconsole.log('Board:');\nresult.board.forEach(row => console.log(row.map(c => c || '.').join(' ')));","map":{"version":3,"names":["generateCrossword","wordList","board","Array","isArray","length","every","w","wordsActive","success","message","from","fill","wordBank","map","word","idx","string","toUpperCase","char","split","index","successfulMatches","totalMatches","effectiveMatches","bounds","minX","maxX","minY","maxY","update","x","y","Math","min","max","isValidPosition","dir","i","crossDir","crossVal","expandBoard","push","findMatches","floor","random","placedWord","k","isValid","m","xPos","yPos","placeWord","matchIndex","matchData","xIndex","yIndex","minMatchDiff","Infinity","curIndex","curWord","curMatchDiff","wordToPlace","splice","trimmedBoard","row","slice","result","console","log","forEach","c","join"],"sources":["C:/Users/ASUS/Documents/htm_fe/src/layouts/RoundBase/utils.ts"],"sourcesContent":["interface Word {\r\n    string: string;\r\n    char: string[];\r\n    index: number;\r\n    successfulMatches: Match[];\r\n    totalMatches: number;\r\n    effectiveMatches: number;\r\n    x?: number;\r\n    y?: number;\r\n    dir?: number;\r\n  }\r\n  \r\n  interface Match {\r\n    x: number;\r\n    y: number;\r\n    dir: number;\r\n  }\r\n  \r\n  interface Bounds {\r\n    minX: number;\r\n    maxX: number;\r\n    minY: number;\r\n    maxY: number;\r\n    update: (x: number, y: number) => void;\r\n  }\r\n  \r\n  interface CrosswordResult {\r\n    board: (string | null)[][];\r\n    wordsActive: Word[];\r\n    success: boolean;\r\n    message?: string;\r\n  }\r\n  \r\n  function generateCrossword(wordList: string[], board: (string | null)[][]): CrosswordResult {\r\n    // Kiểm tra đầu vào\r\n    if (!Array.isArray(wordList) || wordList.length !== 6 || !wordList.every(w => typeof w === 'string')) {\r\n      return { board: [], wordsActive: [], success: false, message: 'wordList must be an array of 6 strings' };\r\n    }\r\n    if (!Array.isArray(board) || board.length === 0 || board[0].length !== 20) {\r\n      board = Array.from({ length: 20 }, () => Array(20).fill(null)) as (string | null)[][];\r\n    }\r\n  \r\n    // Khởi tạo cấu trúc dữ liệu\r\n    const wordsActive: Word[] = [];\r\n    const wordBank: Word[] = wordList.map((word, idx) => ({\r\n      string: word.toUpperCase(),\r\n      char: word.toUpperCase().split(''),\r\n      index: idx,\r\n      successfulMatches: [],\r\n      totalMatches: 0,\r\n      effectiveMatches: 0\r\n    }));\r\n    const bounds: Bounds = {\r\n      minX: 0,\r\n      maxX: 0,\r\n      minY: 0,\r\n      maxY: 0,\r\n      update: function(x: number, y: number) {\r\n        this.minX = Math.min(this.minX, x);\r\n        this.maxX = Math.max(this.maxX, x);\r\n        this.minY = Math.min(this.minY, y);\r\n        this.maxY = Math.max(this.maxY, y);\r\n      }\r\n    };\r\n  \r\n    // Hàm kiểm tra xem ô có hợp lệ để đặt ký tự không\r\n    function isValidPosition(x: number, y: number, char: string, board: (string | null)[][], dir: number, word: Word, i: number): boolean {\r\n      if (x < 0 || x >= board.length || y < 0 || y >= board[0].length) return false;\r\n      if (board[x][y] === null) return true;\r\n      if (board[x][y] === char) {\r\n        // Kiểm tra xung đột với từ khác tại giao điểm\r\n        const crossDir = dir === 0 ? 1 : 0;\r\n        const crossVal = [\r\n          crossDir === 0 ? (x > 0 ? board[x-1][y] : null) : (y > 0 ? board[x][y-1] : null),\r\n          board[x][y],\r\n          crossDir === 0 ? (x < board.length-1 ? board[x+1][y] : null) : (y < board[0].length-1 ? board[x][y+1] : null)\r\n        ];\r\n        return crossVal[0] === null && crossVal[2] === null && board[x][y] === char;\r\n      }\r\n      return false;\r\n    }\r\n  \r\n    // Hàm mở rộng bảng nếu cần\r\n    function expandBoard(board: (string | null)[][], x: number, y: number): void {\r\n      while (x >= board.length) {\r\n        board.push(Array(board[0].length).fill(null));\r\n      }\r\n      while (y >= board[0].length) {\r\n        for (let i = 0; i < board.length; i++) {\r\n          board[i].push(null);\r\n        }\r\n      }\r\n    }\r\n  \r\n    // Hàm tìm các vị trí giao nhau hợp lệ cho một từ\r\n    function findMatches(word: Word, board: (string | null)[][], wordsActive: Word[]): void {\r\n      word.successfulMatches = [];\r\n      word.totalMatches = 0;\r\n      word.effectiveMatches = 0;\r\n  \r\n      if (wordsActive.length === 0) {\r\n        // Nếu bảng rỗng, đặt từ đầu tiên ở giữa\r\n        const x = Math.floor(board.length / 2);\r\n        const y = Math.floor(board[0].length / 2);\r\n        const dir = Math.random() < 0.5 ? 0 : 1;\r\n        word.successfulMatches.push({ x, y, dir });\r\n        word.totalMatches = 1;\r\n        word.effectiveMatches = 1;\r\n        return;\r\n      }\r\n  \r\n      for (const placedWord of wordsActive) {\r\n        for (let i = 0; i < word.char.length; i++) {\r\n          for (let k = 0; k < placedWord.char.length; k++) {\r\n            if (word.char[i] === placedWord.char[k]) {\r\n              word.totalMatches++;\r\n              // Thử đặt từ theo hướng ngang (dir=0) và dọc (dir=1)\r\n              for (let dir = 0; dir <= 1; dir++) {\r\n                const x = dir === 0 ? placedWord.x! + k - i : placedWord.x! + k;\r\n                const y = dir === 0 ? placedWord.y! : placedWord.y! - i;\r\n                let isValid = true;\r\n                // Kiểm tra toàn bộ từ có thể đặt được không\r\n                for (let m = 0; m < word.char.length; m++) {\r\n                  const xPos = dir === 0 ? x + m : x;\r\n                  const yPos = dir === 0 ? y : y + m;\r\n                  expandBoard(board, xPos, yPos);\r\n                  if (!isValidPosition(xPos, yPos, word.char[m], board, dir, word, m)) {\r\n                    isValid = false;\r\n                    break;\r\n                  }\r\n                }\r\n                if (isValid) {\r\n                  word.successfulMatches.push({ x, y, dir });\r\n                  word.effectiveMatches++;\r\n                }\r\n              }\r\n            }\r\n          }\r\n        }\r\n      }\r\n    }\r\n  \r\n    // Hàm đặt từ lên bảng\r\n    function placeWord(word: Word, board: (string | null)[][], wordsActive: Word[]): boolean {\r\n      if (word.successfulMatches.length === 0) return false;\r\n  \r\n      // Chọn ngẫu nhiên một vị trí giao nhau hợp lệ\r\n      const matchIndex = Math.floor(Math.random() * word.successfulMatches.length);\r\n      const matchData = word.successfulMatches[matchIndex];\r\n  \r\n      // Cập nhật thông tin từ\r\n      word.x = matchData.x;\r\n      word.y = matchData.y;\r\n      word.dir = matchData.dir;\r\n  \r\n      // Đặt từng ký tự lên bảng\r\n      for (let i = 0; i < word.char.length; i++) {\r\n        const xIndex = matchData.dir === 0 ? matchData.x + i : matchData.x;\r\n        const yIndex = matchData.dir === 0 ? matchData.y : matchData.y + i;\r\n        expandBoard(board, xIndex, yIndex);\r\n        board[xIndex][yIndex] = word.char[i];\r\n        bounds.update(xIndex, yIndex);\r\n      }\r\n  \r\n      wordsActive.push(word);\r\n      return true;\r\n    }\r\n  \r\n    // Hàm chính để đặt tất cả từ\r\n    while (wordBank.length > 0) {\r\n      let minMatchDiff = Infinity;\r\n      let curIndex = -1;\r\n  \r\n      // Tìm từ tốt nhất để đặt\r\n      for (let i = 0; i < wordBank.length; i++) {\r\n        const curWord = wordBank[i];\r\n        findMatches(curWord, board, wordsActive);\r\n        const curMatchDiff = curWord.totalMatches - curWord.effectiveMatches;\r\n        if (curMatchDiff < minMatchDiff && curWord.successfulMatches.length > 0) {\r\n          minMatchDiff = curMatchDiff;\r\n          curIndex = i;\r\n        }\r\n      }\r\n  \r\n      if (curIndex === -1) {\r\n        return { board, wordsActive, success: false, message: 'Failed to place all words' };\r\n      }\r\n  \r\n      // Đặt từ và loại khỏi wordBank\r\n      const wordToPlace = wordBank.splice(curIndex, 1)[0];\r\n      if (!placeWord(wordToPlace, board, wordsActive)) {\r\n        return { board, wordsActive, success: false, message: 'Failed to place word' };\r\n      }\r\n    }\r\n  \r\n    // Cắt bảng theo bounds để trả về kích thước tối thiểu\r\n    const trimmedBoard: (string | null)[][] = [];\r\n    for (let x = bounds.minX; x <= bounds.maxX; x++) {\r\n      const row = board[x].slice(bounds.minY, bounds.maxY + 1);\r\n      trimmedBoard.push(row);\r\n    }\r\n  \r\n    return { board: trimmedBoard, wordsActive, success: true };\r\n  }\r\n  \r\n  // Ví dụ sử dụng\r\n  const wordList: string[] = ['CROSSWORD', 'PUZZLE', 'GRID', 'WORD', 'CLUE', 'GAME'];\r\n  const board: (string | null)[][] = Array.from({ length: 20 }, () => Array(20).fill(null));\r\n  const result: CrosswordResult = generateCrossword(wordList, board);\r\n  console.log('Success:', result.success);\r\n  console.log('Words Active:', result.wordsActive);\r\n  console.log('Board:');\r\n  result.board.forEach(row => console.log(row.map(c => c || '.').join(' ')));"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}