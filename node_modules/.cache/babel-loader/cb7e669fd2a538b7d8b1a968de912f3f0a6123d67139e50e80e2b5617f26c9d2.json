{"ast":null,"code":"var _s = $RefreshSig$();\nimport React, { useEffect, useState } from 'react';\nimport { findCommonLetterPairs } from '../../../layouts/RoundBase/utils';\nimport { Fragment as _Fragment, jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst HostRound2 = () => {\n  _s();\n  const GRID_WIDTH = 20;\n  const GRID_HEIGHT = 100;\n  const [grid, setGrid] = useState([]);\n  const [wordPositions, setWordPositions] = useState([]);\n  const initializeGrid = () => {\n    return Array(GRID_HEIGHT).fill().map(() => Array(GRID_WIDTH).fill(null));\n  };\n  const canPlaceWord = (grid, word, row, col, isVertical) => {\n    if (isVertical) {\n      if (row + word.length > GRID_HEIGHTzzz) return false;\n      for (let i = 0; i < word.length; i++) {\n        const cell = grid[row + i][col];\n        if (cell !== null && cell !== word[i]) return false;\n        // Check adjacent cells to prevent unwanted letter adjacency\n        if (i === 0 && row > 0 && grid[row - 1][col] !== null) return false;\n        if (i === word.length - 1 && row + i + 1 < GRID_HEIGHT && grid[row + i + 1][col] !== null) return false;\n        if (col > 0 && grid[row + i][col - 1] !== null) return false;\n        if (col < GRID_WIDTH - 1 && grid[row + i][col + 1] !== null) return false;\n      }\n    } else {\n      if (col + word.length > GRID_WIDTH) return false;\n      for (let i = 0; i < word.length; i++) {\n        const cell = grid[row][col + i];\n        if (cell !== null && cell !== word[i]) return false;\n        // Check adjacent cells\n        if (i === 0 && col > 0 && grid[row][col - 1] !== null) return false;\n        if (i === word.length - 1 && col + i + 1 < GRID_WIDTH && grid[row][col + i + 1] !== null) return false;\n        if (row > 0 && grid[row - 1][col + i] !== null) return false;\n        if (row < GRID_HEIGHT - 1 && grid[row + 1][col + i] !== null) return false;\n      }\n    }\n    return true;\n  };\n  const placeWord = (grid, word, row, col, isVertical) => {\n    const newGrid = grid.map(row => [...row]);\n    for (let i = 0; i < word.length; i++) {\n      if (isVertical) {\n        newGrid[row + i][col] = word[i];\n      } else {\n        newGrid[row][col + i] = word[i];\n      }\n    }\n    return newGrid;\n  };\n  const findIntersections = (word1, word2, word1Dir) => {\n    const intersections = [];\n    for (let i = 0; i < word1.length; i++) {\n      for (let j = 0; j < word2.length; j++) {\n        if (word1[i] === word2[j]) {\n          if (word1Dir === 0) {\n            // word1 horizontal, word2 vertical\n            intersections.push({\n              char: word1[i],\n              hPos: i,\n              vPos: j\n            });\n          } else {\n            // word1 vertical, word2 horizontal\n            intersections.push({\n              char: word1[i],\n              vPos: i,\n              hPos: j\n            });\n          }\n        }\n      }\n    }\n    return intersections;\n  };\n  const placeWords = () => {\n    let newGrid = initializeGrid();\n    const positions = [];\n    const shuffledWords = [...words].sort(() => Math.random() - 0.5);\n    const horizontalWords = shuffledWords.slice(0, 3);\n    const verticalWords = shuffledWords.slice(3, 6);\n    const intersectionPairs = Math.random() < 0.5 ? 1 : 2;\n\n    // Place first horizontal word\n    const h1Row = Math.floor(Math.random() * 10) + 5;\n    const h1Col = Math.floor(Math.random() * (GRID_WIDTH - horizontalWords[0].length));\n    newGrid = placeWord(newGrid, horizontalWords[0], h1Row, h1Col, false);\n    positions.push({\n      word: horizontalWords[0],\n      row: h1Row,\n      col: h1Col,\n      isVertical: false\n    });\n\n    // Place first vertical word with intersection\n    let v1Placed = false;\n    const intersections1 = findIntersections(horizontalWords[0], verticalWords[0], 0);\n    if (intersections1.length > 0) {\n      const inter = intersections1[Math.floor(Math.random() * intersections1.length)];\n      const v1Col = h1Col + inter.hPos;\n      const v1Row = h1Row - inter.vPos;\n      if (canPlaceWord(newGrid, verticalWords[0], v1Row, v1Col, true)) {\n        newGrid = placeWord(newGrid, verticalWords[0], v1Row, v1Col, true);\n        positions.push({\n          word: verticalWords[0],\n          row: v1Row,\n          col: v1Col,\n          isVertical: true\n        });\n        v1Placed = true;\n      }\n    }\n    if (!v1Placed) {\n      const v1Row = Math.floor(Math.random() * (GRID_HEIGHT - verticalWords[0].length));\n      const v1Col = Math.floor(Math.random() * GRID_WIDTH);\n      if (canPlaceWord(newGrid, verticalWords[0], v1Row, v1Col, true)) {\n        newGrid = placeWord(newGrid, verticalWords[0], v1Row, v1Col, true);\n        positions.push({\n          word: verticalWords[0],\n          row: v1Row,\n          col: v1Col,\n          isVertical: true\n        });\n      }\n    }\n\n    // Place second horizontal word, possibly intersecting with first vertical\n    let h2Row, h2Col;\n    let h2Placed = false;\n    if (intersectionPairs === 2 && v1Placed) {\n      const intersections2 = findIntersections(verticalWords[0], horizontalWords[1], 1);\n      if (intersections2.length > 0) {\n        const inter = intersections2[Math.floor(Math.random() * intersections2.length)];\n        h2Row = v1Row + inter.vPos;\n        h2Col = v1Col - inter.hPos;\n        if (canPlaceWord(newGrid, horizontalWords[1], h2Row, h2Col, false)) {\n          newGrid = placeWord(newGrid, horizontalWords[1], h2Row, h2Col, false);\n          positions.push({\n            word: horizontalWords[1],\n            row: h2Row,\n            col: h2Col,\n            isVertical: false\n          });\n          h2Placed = true;\n        }\n      }\n    }\n    if (!h2Placed) {\n      h2Row = Math.floor(Math.random() * 10) + 15;\n      h2Col = Math.floor(Math.random() * (GRID_WIDTH - horizontalWords[1].length));\n      if (canPlaceWord(newGrid, horizontalWords[1], h2Row, h2Col, false)) {\n        newGrid = placeWord(newGrid, horizontalWords[1], h2Row, h2Col, false);\n        positions.push({\n          word: horizontalWords[1],\n          row: h2Row,\n          col: h2Col,\n          isVertical: false\n        });\n      }\n    }\n\n    // Place second vertical word, possibly intersecting with second horizontal\n    let v2Placed = false;\n    if (h2Placed && intersectionPairs === 2) {\n      const intersections3 = findIntersections(horizontalWords[1], verticalWords[1], 0);\n      if (intersections3.length > 0) {\n        const inter = intersections3[Math.floor(Math.random() * intersections3.length)];\n        const v2Col = h2Col + inter.hPos;\n        const v2Row = h2Row - inter.vPos;\n        if (canPlaceWord(newGrid, verticalWords[1], v2Row, v2Col, true)) {\n          newGrid = placeWord(newGrid, verticalWords[1], v2Row, v2Col, true);\n          positions.push({\n            word: verticalWords[1],\n            row: v2Row,\n            col: v2Col,\n            isVertical: true\n          });\n          v2Placed = true;\n        }\n      }\n    }\n    if (!v2Placed) {\n      const v2Row = Math.floor(Math.random() * (GRID_HEIGHT - verticalWords[1].length));\n      const v2Col = Math.floor(Math.random() * GRID_WIDTH);\n      if (canPlaceWord(newGrid, verticalWords[1], v2Row, v2Col, true)) {\n        newGrid = placeWord(newGrid, verticalWords[1], v2Row, v2Col, true);\n        positions.push({\n          word: verticalWords[1],\n          row: v2Row,\n          col: v2Col,\n          isVertical: true\n        });\n      }\n    }\n\n    // Place third horizontal word\n    const h3Row = Math.floor(Math.random() * 10) + 25;\n    const h3Col = Math.floor(Math.random() * (GRID_WIDTH - horizontalWords[2].length));\n    if (canPlaceWord(newGrid, horizontalWords[2], h3Row, h3Col, false)) {\n      newGrid = placeWord(newGrid, horizontalWords[2], h3Row, h3Col, false);\n      positions.push({\n        word: horizontalWords[2],\n        row: h3Row,\n        col: h3Col,\n        isVertical: false\n      });\n    }\n\n    // Place third vertical word\n    const v3Row = Math.floor(Math.random() * (GRID_HEIGHT - verticalWords[2].length));\n    const v3Col = Math.floor(Math.random() * GRID_WIDTH);\n    if (canPlaceWord(newGrid, verticalWords[2], v3Row, v3Col, true)) {\n      newGrid = placeWord(newGrid, verticalWords[2], v3Row, v3Col, true);\n      positions.push({\n        word: verticalWords[2],\n        row: v3Row,\n        col: v3Col,\n        isVertical: true\n      });\n    }\n    setGrid(newGrid);\n    setWordPositions(positions);\n  };\n  useEffect(() => {\n    placeWords();\n  }, []);\n  const handleShuffle = () => {\n    placeWords();\n  };\n  const getGridHeight = () => {\n    const rowsUsed = wordPositions.reduce((max, pos) => {\n      if (pos.isVertical) {\n        return Math.max(max, pos.row + pos.word.length);\n      }\n      return Math.max(max, pos.row + 1);\n    }, 0);\n    return Math.min(rowsUsed, GRID_HEIGHT);\n  };\n  useEffect(() => {\n    const board = Array.from({\n      length: 20\n    }, () => Array(20).fill(null));\n    const wordList = [\"GIÓ\", \"HẠT GIỐNG\", \"DREAM\", \"THUỐC\", \"CÚC\", \"CHÂU KIỆT LUÂN\"];\n\n    //const renderedWordList = generateCrossword(wordList,board)\n    const shuffledWordList = wordList.sort(() => Math.random() - 0.5);\n    console.log(\"shuffledWordList\", shuffledWordList);\n    const renderedWordList = findCommonLetterPairs(shuffledWordList, 20, board);\n    console.log(\"renderedWordList\", renderedWordList);\n  }, []);\n  // const [params] = useSearchParams()\n  // const roomId = params.get(\"roomId\") || \"\"\n  // const testName = params.get(\"testName\") || \"\"\n  // const [obstacleWord, setObstacleWord] = useState<string>(\"\")\n  // const [buzzedPlayer, setBuzzedPlayer] = useState<string>(\"\");\n  // const [showModal, setShowModal] = useState(false); // State for modal visibility\n  // const [hintWords, setHintWords] = useState<string[]>([])\n  // const isMounted = useRef(false)\n  // useEffect(() => {\n\n  //     const unsubscribeBuzzing = listenToBuzzing(roomId, (playerName) => {\n  //         if (playerName) {\n  //             setBuzzedPlayer(playerName);\n  //             console.log(\"playerName\", typeof playerName);\n\n  //             console.log(playerName, \"đã bấm chuông\")\n  //             setShowModal(true); \n  //         }\n  //     });\n\n  //     return () => {\n  //         unsubscribeBuzzing();\n  //     };\n  // }, [roomId]);\n\n  // useEffect(() => {\n  //     const getSecondRoundQuestion = async () => {\n  //         const result = await getQuestionByRound(testName, \"2\", roomId)\n  //         console.log(\"round 2 data\", result)\n  //         const sortedResult = [...result].sort((a, b) => a.stt - b.stt);\n  //         console.log(\"sorted result\", sortedResult);\n  //         setObstacleWord(sortedResult[6].answer.toUpperCase().replace(/\\s+/g, \"\"))\n  //         const updatedHintWords = []\n  //         for (let i = 0; i < sortedResult.length - 1; i++) {\n  //             const word = sortedResult[i].answer.toUpperCase().replace(/\\s+/g, \"\");\n  //             updatedHintWords.push(word);\n\n  //             // Old style (shows full array due to reference)\n  //             console.log(\"updatedHintWords\", updatedHintWords);\n\n  //             // Better: shows actual content at this step\n  //             console.log(\"updatedHintWords (snapshot)\", [...updatedHintWords]);\n  //         }\n  //         //const hintWords = result.slice(0, result.length - 1).map((item: any) => item.answer.toUpperCase().replace(/\\s+/g, \"\"));\n  //         console.log(\"hintWords\", [...updatedHintWords])\n  //         setHintWords([...updatedHintWords]);\n\n  //     }\n\n  //     getSecondRoundQuestion()\n\n  // }, [])\n\n  // const handleCloseModal = () => {\n  //     setShowModal(false);\n  //     // Optionally clear buzzedPlayer if you want to reset it\n  //     setBuzzedPlayer(\"\");\n  //     resetBuzz(roomId)\n  //   };\n\n  return /*#__PURE__*/_jsxDEV(_Fragment, {}, void 0, false);\n};\n_s(HostRound2, \"q422Rk65j3ubfnFcJbKVgTigq5I=\");\n_c = HostRound2;\nexport default HostRound2;\nvar _c;\n$RefreshReg$(_c, \"HostRound2\");","map":{"version":3,"names":["React","useEffect","useState","findCommonLetterPairs","Fragment","_Fragment","jsxDEV","_jsxDEV","HostRound2","_s","GRID_WIDTH","GRID_HEIGHT","grid","setGrid","wordPositions","setWordPositions","initializeGrid","Array","fill","map","canPlaceWord","word","row","col","isVertical","length","GRID_HEIGHTzzz","i","cell","placeWord","newGrid","findIntersections","word1","word2","word1Dir","intersections","j","push","char","hPos","vPos","placeWords","positions","shuffledWords","words","sort","Math","random","horizontalWords","slice","verticalWords","intersectionPairs","h1Row","floor","h1Col","v1Placed","intersections1","inter","v1Col","v1Row","h2Row","h2Col","h2Placed","intersections2","v2Placed","intersections3","v2Col","v2Row","h3Row","h3Col","v3Row","v3Col","handleShuffle","getGridHeight","rowsUsed","reduce","max","pos","min","board","from","wordList","shuffledWordList","console","log","renderedWordList","_c","$RefreshReg$"],"sources":["C:/Users/ASUS/Documents/htm_fe/src/pages/Host/Management/HostRound2.tsx"],"sourcesContent":["import Round2 from '../../../layouts/RoundBase/Round2';\r\nimport Host from '../../../layouts/Host/Host';\r\nimport QuestionBoxRound2 from '../../../layouts/RoundBase/Round2';\r\nimport { getQuestionByRound } from '../Test/service';\r\nimport React, { useEffect, useState, useRef } from 'react';\r\nimport { useSearchParams } from 'react-router-dom';\r\nimport { Question } from '../../../type';\r\nimport { listenToBuzzing } from '../../../services/firebaseServices';\r\nimport { resetBuzz } from './service';\r\nimport { findCommonLetterPairs } from '../../../layouts/RoundBase/utils';\r\nimport { generateCrossword } from '../../../layouts/RoundBase/utils';\r\n\r\n\r\nconst HostRound2: React.FC = () => {\r\n  const GRID_WIDTH = 20;\r\n            const GRID_HEIGHT = 100;\r\n            const [grid, setGrid] = useState([]);\r\n            const [wordPositions, setWordPositions] = useState([]);\r\n\r\n            const initializeGrid = () => {\r\n                return Array(GRID_HEIGHT).fill().map(() => Array(GRID_WIDTH).fill(null));\r\n            };\r\n\r\n            const canPlaceWord = (grid, word, row, col, isVertical) => {\r\n                if (isVertical) {\r\n                    if (row + word.length > GRID_HEIGHTzzz) return false;\r\n                    for (let i = 0; i < word.length; i++) {\r\n                        const cell = grid[row + i][col];\r\n                        if (cell !== null && cell !== word[i]) return false;\r\n                        // Check adjacent cells to prevent unwanted letter adjacency\r\n                        if (i === 0 && row > 0 && grid[row - 1][col] !== null) return false;\r\n                        if (i === word.length - 1 && row + i + 1 < GRID_HEIGHT && grid[row + i + 1][col] !== null) return false;\r\n                        if (col > 0 && grid[row + i][col - 1] !== null) return false;\r\n                        if (col < GRID_WIDTH - 1 && grid[row + i][col + 1] !== null) return false;\r\n                    }\r\n                } else {\r\n                    if (col + word.length > GRID_WIDTH) return false;\r\n                    for (let i = 0; i < word.length; i++) {\r\n                        const cell = grid[row][col + i];\r\n                        if (cell !== null && cell !== word[i]) return false;\r\n                        // Check adjacent cells\r\n                        if (i === 0 && col > 0 && grid[row][col - 1] !== null) return false;\r\n                        if (i === word.length - 1 && col + i + 1 < GRID_WIDTH && grid[row][col + i + 1] !== null) return false;\r\n                        if (row > 0 && grid[row - 1][col + i] !== null) return false;\r\n                        if (row < GRID_HEIGHT - 1 && grid[row + 1][col + i] !== null) return false;\r\n                    }\r\n                }\r\n                return true;\r\n            };\r\n\r\n            const placeWord = (grid, word, row, col, isVertical) => {\r\n                const newGrid = grid.map(row => [...row]);\r\n                for (let i = 0; i < word.length; i++) {\r\n                    if (isVertical) {\r\n                        newGrid[row + i][col] = word[i];\r\n                    } else {\r\n                        newGrid[row][col + i] = word[i];\r\n                    }\r\n                }\r\n                return newGrid;\r\n            };\r\n\r\n            const findIntersections = (word1, word2, word1Dir) => {\r\n                const intersections = [];\r\n                for (let i = 0; i < word1.length; i++) {\r\n                    for (let j = 0; j < word2.length; j++) {\r\n                        if (word1[i] === word2[j]) {\r\n                            if (word1Dir === 0) {\r\n                                // word1 horizontal, word2 vertical\r\n                                intersections.push({ char: word1[i], hPos: i, vPos: j });\r\n                            } else {\r\n                                // word1 vertical, word2 horizontal\r\n                                intersections.push({ char: word1[i], vPos: i, hPos: j });\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n                return intersections;\r\n            };\r\n\r\n            const placeWords = () => {\r\n                let newGrid = initializeGrid();\r\n                const positions = [];\r\n                const shuffledWords = [...words].sort(() => Math.random() - 0.5);\r\n                const horizontalWords = shuffledWords.slice(0, 3);\r\n                const verticalWords = shuffledWords.slice(3, 6);\r\n                const intersectionPairs = Math.random() < 0.5 ? 1 : 2;\r\n\r\n                // Place first horizontal word\r\n                const h1Row = Math.floor(Math.random() * 10) + 5;\r\n                const h1Col = Math.floor(Math.random() * (GRID_WIDTH - horizontalWords[0].length));\r\n                newGrid = placeWord(newGrid, horizontalWords[0], h1Row, h1Col, false);\r\n                positions.push({ word: horizontalWords[0], row: h1Row, col: h1Col, isVertical: false });\r\n\r\n                // Place first vertical word with intersection\r\n                let v1Placed = false;\r\n                const intersections1 = findIntersections(horizontalWords[0], verticalWords[0], 0);\r\n                if (intersections1.length > 0) {\r\n                    const inter = intersections1[Math.floor(Math.random() * intersections1.length)];\r\n                    const v1Col = h1Col + inter.hPos;\r\n                    const v1Row = h1Row - inter.vPos;\r\n                    if (canPlaceWord(newGrid, verticalWords[0], v1Row, v1Col, true)) {\r\n                        newGrid = placeWord(newGrid, verticalWords[0], v1Row, v1Col, true);\r\n                        positions.push({ word: verticalWords[0], row: v1Row, col: v1Col, isVertical: true });\r\n                        v1Placed = true;\r\n                    }\r\n                }\r\n                if (!v1Placed) {\r\n                    const v1Row = Math.floor(Math.random() * (GRID_HEIGHT - verticalWords[0].length));\r\n                    const v1Col = Math.floor(Math.random() * GRID_WIDTH);\r\n                    if (canPlaceWord(newGrid, verticalWords[0], v1Row, v1Col, true)) {\r\n                        newGrid = placeWord(newGrid, verticalWords[0], v1Row, v1Col, true);\r\n                        positions.push({ word: verticalWords[0], row: v1Row, col: v1Col, isVertical: true });\r\n                    }\r\n                }\r\n\r\n                // Place second horizontal word, possibly intersecting with first vertical\r\n                let h2Row, h2Col;\r\n                let h2Placed = false;\r\n                if (intersectionPairs === 2 && v1Placed) {\r\n                    const intersections2 = findIntersections(verticalWords[0], horizontalWords[1], 1);\r\n                    if (intersections2.length > 0) {\r\n                        const inter = intersections2[Math.floor(Math.random() * intersections2.length)];\r\n                        h2Row = v1Row + inter.vPos;\r\n                        h2Col = v1Col - inter.hPos;\r\n                        if (canPlaceWord(newGrid, horizontalWords[1], h2Row, h2Col, false)) {\r\n                            newGrid = placeWord(newGrid, horizontalWords[1], h2Row, h2Col, false);\r\n                            positions.push({ word: horizontalWords[1], row: h2Row, col: h2Col, isVertical: false });\r\n                            h2Placed = true;\r\n                        }\r\n                    }\r\n                }\r\n                if (!h2Placed) {\r\n                    h2Row = Math.floor(Math.random() * 10) + 15;\r\n                    h2Col = Math.floor(Math.random() * (GRID_WIDTH - horizontalWords[1].length));\r\n                    if (canPlaceWord(newGrid, horizontalWords[1], h2Row, h2Col, false)) {\r\n                        newGrid = placeWord(newGrid, horizontalWords[1], h2Row, h2Col, false);\r\n                        positions.push({ word: horizontalWords[1], row: h2Row, col: h2Col, isVertical: false });\r\n                    }\r\n                }\r\n\r\n                // Place second vertical word, possibly intersecting with second horizontal\r\n                let v2Placed = false;\r\n                if (h2Placed && intersectionPairs === 2) {\r\n                    const intersections3 = findIntersections(horizontalWords[1], verticalWords[1], 0);\r\n                    if (intersections3.length > 0) {\r\n                        const inter = intersections3[Math.floor(Math.random() * intersections3.length)];\r\n                        const v2Col = h2Col + inter.hPos;\r\n                        const v2Row = h2Row - inter.vPos;\r\n                        if (canPlaceWord(newGrid, verticalWords[1], v2Row, v2Col, true)) {\r\n                            newGrid = placeWord(newGrid, verticalWords[1], v2Row, v2Col, true);\r\n                            positions.push({ word: verticalWords[1], row: v2Row, col: v2Col, isVertical: true });\r\n                            v2Placed = true;\r\n                        }\r\n                    }\r\n                }\r\n                if (!v2Placed) {\r\n                    const v2Row = Math.floor(Math.random() * (GRID_HEIGHT - verticalWords[1].length));\r\n                    const v2Col = Math.floor(Math.random() * GRID_WIDTH);\r\n                    if (canPlaceWord(newGrid, verticalWords[1], v2Row, v2Col, true)) {\r\n                        newGrid = placeWord(newGrid, verticalWords[1], v2Row, v2Col, true);\r\n                        positions.push({ word: verticalWords[1], row: v2Row, col: v2Col, isVertical: true });\r\n                    }\r\n                }\r\n\r\n                // Place third horizontal word\r\n                const h3Row = Math.floor(Math.random() * 10) + 25;\r\n                const h3Col = Math.floor(Math.random() * (GRID_WIDTH - horizontalWords[2].length));\r\n                if (canPlaceWord(newGrid, horizontalWords[2], h3Row, h3Col, false)) {\r\n                    newGrid = placeWord(newGrid, horizontalWords[2], h3Row, h3Col, false);\r\n                    positions.push({ word: horizontalWords[2], row: h3Row, col: h3Col, isVertical: false });\r\n                }\r\n\r\n                // Place third vertical word\r\n                const v3Row = Math.floor(Math.random() * (GRID_HEIGHT - verticalWords[2].length));\r\n                const v3Col = Math.floor(Math.random() * GRID_WIDTH);\r\n                if (canPlaceWord(newGrid, verticalWords[2], v3Row, v3Col, true)) {\r\n                    newGrid = placeWord(newGrid, verticalWords[2], v3Row, v3Col, true);\r\n                    positions.push({ word: verticalWords[2], row: v3Row, col: v3Col, isVertical: true });\r\n                }\r\n\r\n                setGrid(newGrid);\r\n                setWordPositions(positions);\r\n            };\r\n\r\n            useEffect(() => {\r\n                placeWords();\r\n            }, []);\r\n\r\n            const handleShuffle = () => {\r\n                placeWords();\r\n            };\r\n\r\n            const getGridHeight = () => {\r\n                const rowsUsed = wordPositions.reduce((max, pos) => {\r\n                    if (pos.isVertical) {\r\n                        return Math.max(max, pos.row + pos.word.length);\r\n                    }\r\n                    return Math.max(max, pos.row + 1);\r\n                }, 0);\r\n                return Math.min(rowsUsed, GRID_HEIGHT);\r\n            };\r\n  useEffect(()=>{\r\n    const board: (string)[][] = Array.from({ length: 20 }, () => Array(20).fill(null));\r\n    const wordList = [\"GIÓ\", \"HẠT GIỐNG\", \"DREAM\", \"THUỐC\", \"CÚC\", \"CHÂU KIỆT LUÂN\"];\r\n    \r\n    //const renderedWordList = generateCrossword(wordList,board)\r\n    const shuffledWordList = wordList.sort(() => Math.random() - 0.5);\r\n    console.log(\"shuffledWordList\",shuffledWordList);\r\n\r\n    const renderedWordList = findCommonLetterPairs(shuffledWordList,20, board)\r\n\r\n    console.log(\"renderedWordList\",renderedWordList);\r\n    \r\n  },[])\r\n    // const [params] = useSearchParams()\r\n    // const roomId = params.get(\"roomId\") || \"\"\r\n    // const testName = params.get(\"testName\") || \"\"\r\n    // const [obstacleWord, setObstacleWord] = useState<string>(\"\")\r\n    // const [buzzedPlayer, setBuzzedPlayer] = useState<string>(\"\");\r\n    // const [showModal, setShowModal] = useState(false); // State for modal visibility\r\n    // const [hintWords, setHintWords] = useState<string[]>([])\r\n    // const isMounted = useRef(false)\r\n    // useEffect(() => {\r\n\r\n    //     const unsubscribeBuzzing = listenToBuzzing(roomId, (playerName) => {\r\n    //         if (playerName) {\r\n    //             setBuzzedPlayer(playerName);\r\n    //             console.log(\"playerName\", typeof playerName);\r\n\r\n    //             console.log(playerName, \"đã bấm chuông\")\r\n    //             setShowModal(true); \r\n    //         }\r\n    //     });\r\n\r\n    //     return () => {\r\n    //         unsubscribeBuzzing();\r\n    //     };\r\n    // }, [roomId]);\r\n\r\n\r\n    // useEffect(() => {\r\n    //     const getSecondRoundQuestion = async () => {\r\n    //         const result = await getQuestionByRound(testName, \"2\", roomId)\r\n    //         console.log(\"round 2 data\", result)\r\n    //         const sortedResult = [...result].sort((a, b) => a.stt - b.stt);\r\n    //         console.log(\"sorted result\", sortedResult);\r\n    //         setObstacleWord(sortedResult[6].answer.toUpperCase().replace(/\\s+/g, \"\"))\r\n    //         const updatedHintWords = []\r\n    //         for (let i = 0; i < sortedResult.length - 1; i++) {\r\n    //             const word = sortedResult[i].answer.toUpperCase().replace(/\\s+/g, \"\");\r\n    //             updatedHintWords.push(word);\r\n\r\n    //             // Old style (shows full array due to reference)\r\n    //             console.log(\"updatedHintWords\", updatedHintWords);\r\n\r\n    //             // Better: shows actual content at this step\r\n    //             console.log(\"updatedHintWords (snapshot)\", [...updatedHintWords]);\r\n    //         }\r\n    //         //const hintWords = result.slice(0, result.length - 1).map((item: any) => item.answer.toUpperCase().replace(/\\s+/g, \"\"));\r\n    //         console.log(\"hintWords\", [...updatedHintWords])\r\n    //         setHintWords([...updatedHintWords]);\r\n\r\n    //     }\r\n\r\n    //     getSecondRoundQuestion()\r\n\r\n    // }, [])\r\n\r\n    // const handleCloseModal = () => {\r\n    //     setShowModal(false);\r\n    //     // Optionally clear buzzedPlayer if you want to reset it\r\n    //     setBuzzedPlayer(\"\");\r\n    //     resetBuzz(roomId)\r\n    //   };\r\n    \r\n    return (\r\n        <>\r\n        {/* <Host\r\n            QuestionComponent={<QuestionBoxRound2 obstacleWord={obstacleWord} hintWordArray={hintWords} isHost={true} />}\r\n        />\r\n        {showModal && (\r\n        <div className=\"fixed inset-0 z-50 flex items-center justify-center bg-black bg-opacity-50\">\r\n          <div className=\"bg-white rounded-lg p-6 w-80 shadow-lg\">\r\n            <h2 className=\"text-lg font-semibold text-gray-800 mb-4 text-center\">\r\n              {`${buzzedPlayer} đã nhấn chuông trả lời`} \r\n            </h2>\r\n            <div className=\"flex justify-center\">\r\n              <button\r\n                onClick={handleCloseModal}\r\n                className=\"px-4 py-2 bg-blue-500 text-white rounded hover:bg-blue-600 focus:outline-none focus:ring-2 focus:ring-blue-400\"\r\n              >\r\n                Đóng\r\n              </button>\r\n            </div>\r\n          </div>\r\n        </div>\r\n      )} */}\r\n        </>\r\n\r\n    )\r\n};\r\n\r\nexport default HostRound2;\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}