{"ast":null,"code":"function placeWords(words, gridSize = {\n  width: 20,\n  height: 100\n}) {\n  var _gridSize$width, _gridSize$height;\n  const WIDTH = (_gridSize$width = gridSize.width) !== null && _gridSize$width !== void 0 ? _gridSize$width : 20;\n  const HEIGHT = (_gridSize$height = gridSize.height) !== null && _gridSize$height !== void 0 ? _gridSize$height : 100;\n\n  // Initialize grid\n  const grid = Array(HEIGHT).fill(null).map(() => Array(WIDTH).fill(null));\n  const hintWords = [];\n\n  // Validation\n  if (words.length !== 6) {\n    throw new Error('Exactly 6 words are required');\n  }\n\n  // Helper: Check if a word can be placed\n  const canPlaceWord = (word, row, col, isVertical) => {\n    if (isVertical) {\n      if (row + word.length > HEIGHT) return false;\n      for (let i = 0; i < word.length; i++) {\n        const cell = grid[row + i][col];\n        if (cell !== null && cell !== word[i]) return false;\n        // Check adjacent cells to prevent unwanted adjacency\n        if (i === 0 && row > 0 && grid[row - 1][col] !== null) return false;\n        if (i === word.length - 1 && row + i + 1 < HEIGHT && grid[row + i + 1][col] !== null) return false;\n        if (col > 0 && grid[row + i][col - 1] !== null) return false;\n        if (col < WIDTH - 1 && grid[row + i][col + 1] !== null) return false;\n      }\n    } else {\n      if (col + word.length > WIDTH) return false;\n      for (let i = 0; i < word.length; i++) {\n        const cell = grid[row][col + i];\n        if (cell !== null && cell !== word[i]) return false;\n        // Check adjacent cells\n        if (i === 0 && col > 0 && grid[row][col - 1] !== null) return false;\n        if (i === word.length - 1 && col + i + 1 < WIDTH && grid[row][col + i + 1] !== null) return false;\n        if (row > 0 && grid[row - 1][col + i] !== null) return false;\n        if (row < HEIGHT - 1 && grid[row + 1][col + i] !== null) return false;\n      }\n    }\n    return true;\n  };\n\n  // Helper: Place a word on the grid\n  const placeWord = (word, row, col, isVertical) => {\n    for (let i = 0; i < word.length; i++) {\n      if (isVertical) {\n        grid[row + i][col] = word[i];\n      } else {\n        grid[row][col + i] = word[i];\n      }\n    }\n    hintWords.push({\n      word,\n      x: col,\n      y: row,\n      direction: isVertical ? 'vertical' : 'horizontal'\n    });\n  };\n\n  // Helper: Find intersections between two words\n  const findIntersections = (word1, word2, word1Dir) => {\n    const intersections = [];\n    for (let i = 0; i < word1.length; i++) {\n      for (let j = 0; j < word2.length; j++) {\n        if (word1[i] === word2[j]) {\n          if (word1Dir === 0) {\n            intersections.push({\n              char: word1[i],\n              hPos: i,\n              vPos: j\n            });\n          } else {\n            intersections.push({\n              char: word1[i],\n              vPos: i,\n              hPos: j\n            });\n          }\n        }\n      }\n    }\n    return intersections;\n  };\n\n  // Shuffle words and split into horizontal and vertical\n  const shuffledWords = [...words].sort(() => Math.random() - 0.5);\n  const horizontalWords = shuffledWords.slice(0, 3);\n  const verticalWords = shuffledWords.slice(3, 6);\n  const intersectionPairs = Math.random() < 0.5 ? 1 : 2;\n\n  // Place first horizontal word\n  const h1Row = Math.floor(Math.random() * 10) + 5;\n  const h1Col = Math.floor(Math.random() * (WIDTH - horizontalWords[0].length));\n  placeWord(horizontalWords[0], h1Row, h1Col, false);\n\n  // Place first vertical word with intersection\n  let v1Placed = false;\n  let v1Row, v1Col;\n  const intersections1 = findIntersections(horizontalWords[0], verticalWords[0], 0);\n  if (intersections1.length > 0) {\n    const inter = intersections1[Math.floor(Math.random() * intersections1.length)];\n    v1Col = h1Col + inter.hPos;\n    v1Row = h1Row - inter.vPos;\n    if (canPlaceWord(verticalWords[0], v1Row, v1Col, true)) {\n      placeWord(verticalWords[0], v1Row, v1Col, true);\n      v1Placed = true;\n    }\n  }\n  if (!v1Placed) {\n    v1Row = Math.floor(Math.random() * (HEIGHT - verticalWords[0].length));\n    v1Col = Math.floor(Math.random() * WIDTH);\n    if (canPlaceWord(verticalWords[0], v1Row, v1Col, true)) {\n      placeWord(verticalWords[0], v1Row, v1Col, true);\n    }\n  }\n\n  // Place second horizontal word, possibly intersecting with first vertical\n  let h2Row = Math.floor(Math.random() * 10) + 15;\n  let h2Col = Math.floor(Math.random() * (WIDTH - horizontalWords[1].length));\n  let h2Placed = false;\n  if (intersectionPairs === 2 && v1Placed) {\n    const intersections2 = findIntersections(verticalWords[0], horizontalWords[1], 1);\n    if (intersections2.length > 0) {\n      const inter = intersections2[Math.floor(Math.random() * intersections2.length)];\n      const tryH2Row = v1Row + inter.vPos;\n      const tryH2Col = v1Col - inter.hPos;\n      if (canPlaceWord(horizontalWords[1], tryH2Row, tryH2Col, false)) {\n        h2Row = tryH2Row;\n        h2Col = tryH2Col;\n        h2Placed = true;\n      }\n    }\n  }\n  if (canPlaceWord(horizontalWords[1], h2Row, h2Col, false)) {\n    placeWord(horizontalWords[1], h2Row, h2Col, false);\n  }\n\n  // Place second vertical word, possibly intersecting with second horizontal\n  let v2Row = Math.floor(Math.random() * (HEIGHT - verticalWords[1].length));\n  let v2Col = Math.floor(Math.random() * WIDTH);\n  let v2Placed = false;\n  if (h2Placed && intersectionPairs === 2) {\n    const intersections3 = findIntersections(horizontalWords[1], verticalWords[1], 0);\n    if (intersections3.length > 0) {\n      const inter = intersections3[Math.floor(Math.random() * intersections3.length)];\n      const tryV2Col = h2Col + inter.hPos;\n      const tryV2Row = h2Row - inter.vPos;\n      if (canPlaceWord(verticalWords[1], tryV2Row, tryV2Col, true)) {\n        v2Row = tryV2Row;\n        v2Col = tryV2Col;\n        v2Placed = true;\n      }\n    }\n  }\n  if (canPlaceWord(verticalWords[1], v2Row, v2Col, true)) {\n    placeWord(verticalWords[1], v2Row, v2Col, true);\n  }\n\n  // Place third horizontal word\n  const h3Row = Math.floor(Math.random() * 10) + 25;\n  const h3Col = Math.floor(Math.random() * (WIDTH - horizontalWords[2].length));\n  if (canPlaceWord(horizontalWords[2], h3Row, h3Col, false)) {\n    placeWord(horizontalWords[2], h3Row, h3Col, false);\n  }\n\n  // Place third vertical word\n  const v3Row = Math.floor(Math.random() * (HEIGHT - verticalWords[2].length));\n  const v3Col = Math.floor(Math.random() * WIDTH);\n  if (canPlaceWord(verticalWords[2], v3Row, v3Col, true)) {\n    placeWord(verticalWords[2], v3Row, v3Col, true);\n  }\n  return {\n    grid,\n    hintWords\n  };\n}","map":{"version":3,"names":["placeWords","words","gridSize","width","height","_gridSize$width","_gridSize$height","WIDTH","HEIGHT","grid","Array","fill","map","hintWords","length","Error","canPlaceWord","word","row","col","isVertical","i","cell","placeWord","push","x","y","direction","findIntersections","word1","word2","word1Dir","intersections","j","char","hPos","vPos","shuffledWords","sort","Math","random","horizontalWords","slice","verticalWords","intersectionPairs","h1Row","floor","h1Col","v1Placed","v1Row","v1Col","intersections1","inter","h2Row","h2Col","h2Placed","intersections2","tryH2Row","tryH2Col","v2Row","v2Col","v2Placed","intersections3","tryV2Col","tryV2Row","h3Row","h3Col","v3Row","v3Col"],"sources":["C:/Users/ASUS/Documents/htm_fe/src/layouts/RoundBase/utils.ts"],"sourcesContent":["interface HintWord {\r\n    word: string;\r\n    x: number;\r\n    y: number;\r\n    direction: 'horizontal' | 'vertical';\r\n  }\r\n  \r\n  interface Intersection {\r\n    char: string;\r\n    hPos: number;\r\n    vPos: number;\r\n  }\r\n  \r\n  interface PlaceWordsResult {\r\n    grid: (string | null)[][];\r\n    hintWords: HintWord[];\r\n  }\r\n  \r\n  function placeWords(\r\n    words: string[],\r\n    gridSize: { width?: number; height?: number } = { width: 20, height: 100 }\r\n  ): PlaceWordsResult {\r\n    const WIDTH = gridSize.width ?? 20;\r\n    const HEIGHT = gridSize.height ?? 100;\r\n  \r\n    // Initialize grid\r\n    const grid: (string | null)[][] = Array(HEIGHT)\r\n      .fill(null)\r\n      .map(() => Array(WIDTH).fill(null));\r\n    const hintWords: HintWord[] = [];\r\n  \r\n    // Validation\r\n    if (words.length !== 6) {\r\n      throw new Error('Exactly 6 words are required');\r\n    }\r\n  \r\n    // Helper: Check if a word can be placed\r\n    const canPlaceWord = (\r\n      word: string,\r\n      row: number,\r\n      col: number,\r\n      isVertical: boolean\r\n    ): boolean => {\r\n      if (isVertical) {\r\n        if (row + word.length > HEIGHT) return false;\r\n        for (let i = 0; i < word.length; i++) {\r\n          const cell = grid[row + i][col];\r\n          if (cell !== null && cell !== word[i]) return false;\r\n          // Check adjacent cells to prevent unwanted adjacency\r\n          if (i === 0 && row > 0 && grid[row - 1][col] !== null) return false;\r\n          if (\r\n            i === word.length - 1 &&\r\n            row + i + 1 < HEIGHT &&\r\n            grid[row + i + 1][col] !== null\r\n          )\r\n            return false;\r\n          if (col > 0 && grid[row + i][col - 1] !== null) return false;\r\n          if (col < WIDTH - 1 && grid[row + i][col + 1] !== null) return false;\r\n        }\r\n      } else {\r\n        if (col + word.length > WIDTH) return false;\r\n        for (let i = 0; i < word.length; i++) {\r\n          const cell = grid[row][col + i];\r\n          if (cell !== null && cell !== word[i]) return false;\r\n          // Check adjacent cells\r\n          if (i === 0 && col > 0 && grid[row][col - 1] !== null) return false;\r\n          if (\r\n            i === word.length - 1 &&\r\n            col + i + 1 < WIDTH &&\r\n            grid[row][col + i + 1] !== null\r\n          )\r\n            return false;\r\n          if (row > 0 && grid[row - 1][col + i] !== null) return false;\r\n          if (row < HEIGHT - 1 && grid[row + 1][col + i] !== null) return false;\r\n        }\r\n      }\r\n      return true;\r\n    };\r\n  \r\n    // Helper: Place a word on the grid\r\n    const placeWord = (\r\n      word: string,\r\n      row: number,\r\n      col: number,\r\n      isVertical: boolean\r\n    ): void => {\r\n      for (let i = 0; i < word.length; i++) {\r\n        if (isVertical) {\r\n          grid[row + i][col] = word[i];\r\n        } else {\r\n          grid[row][col + i] = word[i];\r\n        }\r\n      }\r\n      hintWords.push({\r\n        word,\r\n        x: col,\r\n        y: row,\r\n        direction: isVertical ? 'vertical' : 'horizontal',\r\n      });\r\n    };\r\n  \r\n    // Helper: Find intersections between two words\r\n    const findIntersections = (\r\n      word1: string,\r\n      word2: string,\r\n      word1Dir: 0 | 1\r\n    ): Intersection[] => {\r\n      const intersections: Intersection[] = [];\r\n      for (let i = 0; i < word1.length; i++) {\r\n        for (let j = 0; j < word2.length; j++) {\r\n          if (word1[i] === word2[j]) {\r\n            if (word1Dir === 0) {\r\n              intersections.push({ char: word1[i], hPos: i, vPos: j });\r\n            } else {\r\n              intersections.push({ char: word1[i], vPos: i, hPos: j });\r\n            }\r\n          }\r\n        }\r\n      }\r\n      return intersections;\r\n    };\r\n  \r\n    // Shuffle words and split into horizontal and vertical\r\n    const shuffledWords = [...words].sort(() => Math.random() - 0.5);\r\n    const horizontalWords = shuffledWords.slice(0, 3);\r\n    const verticalWords = shuffledWords.slice(3, 6);\r\n    const intersectionPairs = Math.random() < 0.5 ? 1 : 2;\r\n  \r\n    // Place first horizontal word\r\n    const h1Row = Math.floor(Math.random() * 10) + 5;\r\n    const h1Col = Math.floor(Math.random() * (WIDTH - horizontalWords[0].length));\r\n    placeWord(horizontalWords[0], h1Row, h1Col, false);\r\n  \r\n    // Place first vertical word with intersection\r\n    let v1Placed = false;\r\n    let v1Row: number, v1Col: number;\r\n    const intersections1 = findIntersections(horizontalWords[0], verticalWords[0], 0);\r\n    if (intersections1.length > 0) {\r\n      const inter = intersections1[Math.floor(Math.random() * intersections1.length)];\r\n      v1Col = h1Col + inter.hPos;\r\n      v1Row = h1Row - inter.vPos;\r\n      if (canPlaceWord(verticalWords[0], v1Row, v1Col, true)) {\r\n        placeWord(verticalWords[0], v1Row, v1Col, true);\r\n        v1Placed = true;\r\n      }\r\n    }\r\n    if (!v1Placed) {\r\n      v1Row = Math.floor(Math.random() * (HEIGHT - verticalWords[0].length));\r\n      v1Col = Math.floor(Math.random() * WIDTH);\r\n      if (canPlaceWord(verticalWords[0], v1Row, v1Col, true)) {\r\n        placeWord(verticalWords[0], v1Row, v1Col, true);\r\n      }\r\n    }\r\n  \r\n    // Place second horizontal word, possibly intersecting with first vertical\r\n    let h2Row = Math.floor(Math.random() * 10) + 15;\r\n    let h2Col = Math.floor(Math.random() * (WIDTH - horizontalWords[1].length));\r\n    let h2Placed = false;\r\n    if (intersectionPairs === 2 && v1Placed) {\r\n      const intersections2 = findIntersections(verticalWords[0], horizontalWords[1], 1);\r\n      if (intersections2.length > 0) {\r\n        const inter = intersections2[Math.floor(Math.random() * intersections2.length)];\r\n        const tryH2Row = v1Row + inter.vPos;\r\n        const tryH2Col = v1Col - inter.hPos;\r\n        if (canPlaceWord(horizontalWords[1], tryH2Row, tryH2Col, false)) {\r\n          h2Row = tryH2Row;\r\n          h2Col = tryH2Col;\r\n          h2Placed = true;\r\n        }\r\n      }\r\n    }\r\n    if (canPlaceWord(horizontalWords[1], h2Row, h2Col, false)) {\r\n      placeWord(horizontalWords[1], h2Row, h2Col, false);\r\n    }\r\n  \r\n    // Place second vertical word, possibly intersecting with second horizontal\r\n    let v2Row = Math.floor(Math.random() * (HEIGHT - verticalWords[1].length));\r\n    let v2Col = Math.floor(Math.random() * WIDTH);\r\n    let v2Placed = false;\r\n    if (h2Placed && intersectionPairs === 2) {\r\n      const intersections3 = findIntersections(horizontalWords[1], verticalWords[1], 0);\r\n      if (intersections3.length > 0) {\r\n        const inter = intersections3[Math.floor(Math.random() * intersections3.length)];\r\n        const tryV2Col = h2Col + inter.hPos;\r\n        const tryV2Row = h2Row - inter.vPos;\r\n        if (canPlaceWord(verticalWords[1], tryV2Row, tryV2Col, true)) {\r\n          v2Row = tryV2Row;\r\n          v2Col = tryV2Col;\r\n          v2Placed = true;\r\n        }\r\n      }\r\n    }\r\n    if (canPlaceWord(verticalWords[1], v2Row, v2Col, true)) {\r\n      placeWord(verticalWords[1], v2Row, v2Col, true);\r\n    }\r\n  \r\n    // Place third horizontal word\r\n    const h3Row = Math.floor(Math.random() * 10) + 25;\r\n    const h3Col = Math.floor(Math.random() * (WIDTH - horizontalWords[2].length));\r\n    if (canPlaceWord(horizontalWords[2], h3Row, h3Col, false)) {\r\n      placeWord(horizontalWords[2], h3Row, h3Col, false);\r\n    }\r\n  \r\n    // Place third vertical word\r\n    const v3Row = Math.floor(Math.random() * (HEIGHT - verticalWords[2].length));\r\n    const v3Col = Math.floor(Math.random() * WIDTH);\r\n    if (canPlaceWord(verticalWords[2], v3Row, v3Col, true)) {\r\n      placeWord(verticalWords[2], v3Row, v3Col, true);\r\n    }\r\n  \r\n    return { grid, hintWords };\r\n  }"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}