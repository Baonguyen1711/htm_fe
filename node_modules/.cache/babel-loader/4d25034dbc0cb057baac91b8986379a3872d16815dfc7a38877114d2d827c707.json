{"ast":null,"code":"// T·∫°o t·ª´ kh√≥a g·ª£i √Ω v·ªõi v·ªã tr√≠ v√† h∆∞·ªõng random\n\nexport const findCommonLetterIndexes = (word1, word2) => {\n  const result = [];\n  for (let i = 0; i < word1.length; i++) {\n    for (let j = 0; j < word2.length; j++) {\n      if (word1[i] === word2[j]) {\n        result.push({\n          [word1]: i,\n          [word2]: j\n        });\n      }\n    }\n  }\n  return result;\n};\nconst canPlaceWord = (word, x, y, grid, direction) => {\n  if (direction == \"horizontal\") {\n    for (let i = 0; i < word.length; i++) {\n      if (grid[x][y + i] !== \"\" || grid[x][y + i] == undefined) return false;\n    }\n  }\n  if (direction == \"vertical\") {\n    for (let i = 0; i < word.length; i++) {\n      if (grid[x + i][y] !== \"\") return false;\n    }\n  }\n  return true;\n};\nexport const findCommonLetterPairs = (wordList, gridSize, grid) => {\n  const REQUIRE_PAIRS = Math.floor(Math.random() * 2) + 1;\n  console.log(\"REQUIRE_PAIRS\", REQUIRE_PAIRS);\n  const tempWordList = [...wordList];\n  const commonPairs = [];\n  const placedWords = new Set();\n  const wordsCoordinate = [];\n  let found = false;\n  let pairs = 0;\n  let direction = \"horizontal\";\n  let nextPosition = {\n    x: 0,\n    y: 0\n  };\n  if (REQUIRE_PAIRS == 2) {\n    while (pairs < REQUIRE_PAIRS && !found) {\n      for (let i = 0; i < tempWordList.length; i++) {\n        if (pairs == REQUIRE_PAIRS || found == true) break;\n        const word1 = tempWordList[i];\n        if (placedWords.has(word1)) continue;\n        for (let j = 0; j < tempWordList.length; j++) {\n          if (tempWordList[j] === word1) continue;\n          if (placedWords.has(tempWordList[j])) continue;\n          const result = findCommonLetterIndexes(word1, tempWordList[j]);\n          if (result.length > 0) {\n            console.log(\"result\", result);\n            const index = Math.floor(Math.random() * result.length);\n            console.log(\"index\", index);\n            commonPairs.push(result[index]);\n            console.log(\"pairs\", pairs);\n            placedWords.add(word1);\n            placedWords.add(tempWordList[j]);\n            pairs = pairs + 1;\n            break;\n          }\n          if (i == tempWordList.length - 1 && j == tempWordList.length - 1) {\n            found = true;\n            break;\n          }\n        }\n      }\n    }\n  }\n  if (REQUIRE_PAIRS == 1) {\n    const sortedTempWordList = [...tempWordList].sort((a, b) => b.length - a.length);\n    let index = -1;\n    while (!found) {\n      for (let i = 0; i < sortedTempWordList.length; i++) {\n        if (found == true) break;\n        const word1 = sortedTempWordList[i];\n        if (placedWords.has(word1)) continue;\n        for (let j = 0; j < sortedTempWordList.length; j++) {\n          if (sortedTempWordList[j] === word1) continue;\n          const result = findCommonLetterIndexes(word1, sortedTempWordList[j]);\n          if (result.length > 0) {\n            console.log(\"result\", result);\n            const index = Math.floor(Math.random() * result.length);\n            console.log(\"index\", index);\n            commonPairs.push(result[index]);\n            console.log(\"pairs\", pairs);\n            placedWords.add(word1);\n            placedWords.add(sortedTempWordList[j]);\n          }\n          if (commonPairs.length == 2) {\n            found = true;\n            break;\n          }\n          if (i == tempWordList.length - 1 && j == tempWordList.length - 1) {\n            found = true;\n            break;\n          }\n        }\n      }\n    }\n  }\n\n  //loop until 2 pairs are found or go through all the array\n\n  for (let pairs of commonPairs) {\n    const keys = Object.keys(pairs);\n    const x = Math.floor(Math.random() * gridSize);\n    const y = Math.floor(Math.random() * (gridSize - keys[0].length));\n    const word1Coordinate = {\n      word: keys[0],\n      x: x,\n      y: y,\n      direction: \"horizontal\"\n    };\n    const word2Coordinate = {\n      word: keys[1],\n      x: 1,\n      y: pairs[keys[0]] + 1,\n      direction: \"vertical\"\n    };\n    placedWords.add(word1Coordinate);\n    placedWords.add(word2Coordinate);\n  }\n  return commonPairs;\n};\nexport const generateHintWords = (words, gridSize, obstacleWord) => {\n  const grid = Array(gridSize).fill(null).map(() => Array(gridSize).fill(\"\")); // M·∫£ng ki·ªÉm tra v·ªã tr√≠\n\n  const findCommonLetterPairs = words => {\n    let results = [];\n    let usedWords = new Set(); // L∆∞u l·∫°i c√°c t·ª´ ƒë√£ d√πng\n\n    let remainingPairs = [];\n    for (let i = 0; i < words.length; i++) {\n      for (let j = i + 1; j < words.length; j++) {\n        const word1 = words[i];\n        const word2 = words[j];\n\n        // T√¨m k√Ω t·ª± chung gi·ªØa 2 t·ª´\n        const commonLetters = [...new Set(word1)].filter(letter => word2.includes(letter));\n        if (commonLetters.length >= 2) {\n          // T√≠nh ƒëi·ªÉm ∆∞u ti√™n (ch·ªØ g·∫ßn trung t√¢m h∆°n)\n          const scoredLetters = commonLetters.map(letter => {\n            const index1 = word1.indexOf(letter);\n            const index2 = word2.indexOf(letter);\n            const center1 = word1.length / 2;\n            const center2 = word2.length / 2;\n            const score = Math.abs(index1 - center1) + Math.abs(index2 - center2);\n            return {\n              letter,\n              score\n            };\n          });\n\n          // S·∫Øp x·∫øp theo ƒëi·ªÉm ∆∞u ti√™n\n          scoredLetters.sort((a, b) => a.score - b.score);\n          const prioritizedLetters = scoredLetters.map(item => item.letter);\n          remainingPairs.push({\n            word1,\n            word2,\n            commonLetters: prioritizedLetters\n          });\n        }\n      }\n    }\n\n    // B∆∞·ªõc 2: Ch·ªçn t·ªëi ƒëa 2 c·∫∑p theo quy t·∫Øc\n    for (const pair of remainingPairs) {\n      if (results.length >= 2) break; // ƒê·ªß 2 c·∫∑p th√¨ d·ª´ng\n      if (!usedWords.has(pair.word1) && !usedWords.has(pair.word2)) {\n        results.push(pair);\n        usedWords.add(pair.word1);\n        usedWords.add(pair.word2);\n      }\n    }\n\n    // N·∫øu v·∫´n ch∆∞a ƒë·ªß 2 c·∫∑p, ch·ªçn ti·∫øp t·ª´ c√°c c·∫∑p c√≥ t·ª´ ƒë√£ d√πng\n    for (const pair of remainingPairs) {\n      if (results.length >= 2) break;\n      if (!usedWords.has(pair.word1) || !usedWords.has(pair.word2)) {\n        results.push(pair);\n        usedWords.add(pair.word1);\n        usedWords.add(pair.word2);\n      }\n    }\n    return results;\n  };\n\n  // üõ† Test\n  //const testwords = [\"B∆ØUCH√çNH\", \"5G\", \"BQP\", \"T·∫¨PƒêO√ÄN\", \"H√ÄN·ªòI\", \"RED\"];\n\n  const shuffledWords = [...words].sort(() => Math.random() - 0.5);\n  const placeWordsOnGrid = (words, gridSize) => {\n    while (true) {\n      let placedWords = [];\n      let occupiedPositions = new Set();\n      let placedSet = new Set(); // Set ƒë·ªÉ theo d√µi t·ª´ ƒë√£ ƒë·∫∑t\n      let allPlaced = true; // C·ªù ki·ªÉm tra xem t·∫•t c·∫£ t·ª´ c√≥ ƒë∆∞·ª£c ƒë·∫∑t hay kh√¥ng\n\n      const getKey = (x, y) => `${x},${y}`;\n      const canPlaceWord = (word, x, y, direction, index) => {\n        for (let i = 0; i < word.length; i++) {\n          if (i === x + index) continue;\n          let newX = direction === \"horizontal\" ? x + i : x;\n          let newY = direction === \"horizontal\" ? y : y + i;\n          if (newX < 0 || newY < 0 || newX >= gridSize || newY >= gridSize || occupiedPositions.has(getKey(newX, newY))) {\n            return false;\n          }\n        }\n        return true;\n      };\n      const commonLetterPairs = findCommonLetterPairs(words);\n      console.log(commonLetterPairs);\n      for (const {\n        word1,\n        word2,\n        commonLetters\n      } of commonLetterPairs) {\n        if (placedSet.has(word1) || placedSet.has(word2)) continue; // Ki·ªÉm tra n·∫øu ƒë√£ ƒë·∫∑t th√¨ b·ªè qua\n\n        const commonLetter = commonLetters[0];\n        const index1 = word1.indexOf(commonLetter);\n        const index2 = word2.indexOf(commonLetter);\n        let placed = false;\n        for (let attempt = 0; attempt < 100; attempt++) {\n          let x = Math.floor(Math.random() * (gridSize - word1.length)) + 1;\n          let y = Math.floor(Math.random() * (gridSize - index2) + index2) + 1;\n          if (canPlaceWord(word1, x, y, \"horizontal\", index1)) {\n            placedWords.push({\n              word: word1,\n              x,\n              y,\n              direction: \"horizontal\"\n            });\n            placedSet.add(word1);\n            let intersecrX = x + index1;\n            let intersectY = y;\n            if (canPlaceWord(word2, intersecrX, intersectY - index2, \"vertical\", index2)) {\n              for (let i = 0; i < word1.length; i++) occupiedPositions.add(getKey(x + i, y));\n              placedWords.push({\n                word: word2,\n                x: intersecrX,\n                y: intersectY - index2,\n                direction: \"vertical\"\n              });\n              placedSet.add(word2);\n              for (let i = 0; i < word2.length; i++) occupiedPositions.add(getKey(intersecrX, intersectY - index2 + i));\n              placed = true;\n              break;\n            } else {\n              placedWords.pop();\n            }\n          }\n        }\n        if (!placed) {\n          console.warn(`Kh√¥ng th·ªÉ ƒë·∫∑t c·∫∑p t·ª´: ${word1} - ${word2}`);\n          allPlaced = false;\n          break;\n        }\n      }\n      for (const word of words) {\n        if (placedSet.has(word)) continue;\n        let placed = false;\n        let found = false;\n        for (let j = placedWords.length - 1; j >= 0; j--) {\n          for (let attempt = 0; attempt < 10; attempt++) {\n            let direction = placedWords[j].direction === \"horizontal\" ? \"vertical\" : \"horizontal\";\n            const shift = Math.random() < 0.5 ? 1 : -1;\n            let x = placedWords[j].direction === \"horizontal\" ? placedWords[j].word.length + placedWords[j].x : placedWords[j].x + 1;\n            let y = placedWords[j].direction === \"horizontal\" ? placedWords[j].y + 2 : placedWords[j].word.length + placedWords[j].y;\n            if (canPlaceWord(word, x, y, direction, 0)) {\n              placedWords.push({\n                word,\n                x,\n                y,\n                direction\n              });\n              placedSet.add(word);\n              for (let i = 0; i < word.length; i++) {\n                let newX = direction === \"horizontal\" ? x + i : x;\n                let newY = direction === \"horizontal\" ? y : y + i;\n                occupiedPositions.add(getKey(newX, newY));\n              }\n              placed = true;\n              found = true;\n              break;\n            }\n          }\n          if (found) break;\n        }\n        if (!placed) {\n          console.warn(`Kh√¥ng th·ªÉ ƒë·∫∑t t·ª´: ${word}`);\n          allPlaced = false;\n          break;\n        }\n      }\n      if (!allPlaced) continue; // N·∫øu c√≥ t·ª´ kh√¥ng ƒë·∫∑t ƒë∆∞·ª£c, restart v√≤ng l·∫∑p\n\n      if (allPlaced) return placedWords; // N·∫øu t·∫•t c·∫£ t·ª´ ƒë·ªÅu ƒë∆∞·ª£c ƒë·∫∑t, tho√°t kh·ªèi v√≤ng l·∫∑p v√† tr·∫£ v·ªÅ k·∫øt qu·∫£\n    }\n  };\n  const placedWords = placeWordsOnGrid(shuffledWords, gridSize);\n  console.log(placedWords);\n  return placedWords;\n};\nexport const renderGrid = (wordList, mainKeyword, GRID_SIZE) => {\n  console.log(\"wordList on render\", wordList);\n  const maxAttempts = 100;\n  const generateEmptyGrid = () => {\n    return Array(GRID_SIZE).fill(null).map(() => Array(GRID_SIZE).fill(\"\"));\n  };\n  const getKey = (x, y) => `${x},${y}`;\n  const canPlaceNumber = (x, y) => {\n    if (x < 0 || y < 0 || x >= GRID_SIZE || y >= GRID_SIZE) return false;\n    return !occupiedPositions.has(getKey(x, y));\n  };\n  const hasCommonLetter = (word1, word2) => {\n    return [...new Set(word1)].some(letter => word2.includes(letter));\n  };\n\n  // Try to place words and numbers until a valid configuration is found\n  let attempts = 0;\n  let randomHintWords = [];\n  let newGrid = generateEmptyGrid();\n  let occupiedPositions = new Set();\n  let occupiedRows = new Set();\n  let occupiedCols = new Set();\n  while (attempts < maxAttempts) {\n    randomHintWords = generateHintWords(wordList, GRID_SIZE, mainKeyword);\n    newGrid = generateEmptyGrid();\n    occupiedPositions.clear();\n    occupiedRows.clear();\n    occupiedCols.clear();\n    let canPlaceAll = true;\n\n    // First pass: Place words and mark their positions\n    for (const {\n      word,\n      x,\n      y,\n      direction\n    } of randomHintWords) {\n      if (direction === \"horizontal\") {\n        occupiedRows.add(y);\n        // Check for adjacent rows\n        for (const other of randomHintWords) {\n          if (other.word === word || other.direction !== \"horizontal\") continue; // Fixed comparison\n          if (Math.abs(other.y - y) === 1 && !hasCommonLetter(word, other.word)) {\n            canPlaceAll = false;\n            break;\n          }\n        }\n      } else {\n        occupiedCols.add(x);\n        // Check for adjacent columns\n        for (const other of randomHintWords) {\n          if (other.word === word || other.direction !== \"vertical\") continue; // Fixed comparison\n          if (Math.abs(other.x - x) === 1 && !hasCommonLetter(word, other.word)) {\n            canPlaceAll = false;\n            break;\n          }\n        }\n      }\n      if (!canPlaceAll) break;\n      for (let i = 0; i < word.length; i++) {\n        let newX = direction === \"horizontal\" ? x + i : x;\n        let newY = direction === \"horizontal\" ? y : y + i;\n        newGrid[newY][newX] = word[i];\n        occupiedPositions.add(getKey(newX, newY));\n      }\n    }\n    if (!canPlaceAll) {\n      attempts++;\n      continue;\n    }\n\n    // Second pass: Check if numbers can be placed without overlap\n\n    for (const {\n      word,\n      x,\n      y,\n      direction\n    } of randomHintWords) {\n      const wordNumber = wordList.includes(word) ? wordList.indexOf(word) + 1 : -1; // Ki·ªÉm tra tr∆∞·ªõc khi l·∫•y s·ªë\n\n      if (wordNumber === -1) {\n        console.error(`Kh√¥ng t√¨m th·∫•y t·ª´ ${word} trong wordList`);\n        continue; // N·∫øu kh√¥ng t√¨m th·∫•y, ti·∫øp t·ª•c v√≤ng l·∫∑p\n      }\n      if (direction === \"horizontal\" && x > 0) {\n        if (!canPlaceNumber(x - 1, y)) {\n          canPlaceAll = false;\n          break;\n        }\n      } else if (direction === \"vertical\" && y > 0) {\n        if (!canPlaceNumber(x, y - 1)) {\n          canPlaceAll = false;\n          break;\n        }\n      }\n    }\n    if (canPlaceAll) {\n      // Place numbers if all checks pass\n      randomHintWords.forEach(({\n        word,\n        x,\n        y,\n        direction\n      }) => {\n        const wordNumber = wordList.indexOf(word) + 1;\n        console.log(\"wordList\", wordList);\n        console.log(\"word\", word);\n        console.log(\"wordNumber\", wordNumber);\n        let newY = y; // T·∫°o bi·∫øn m·ªõi ƒë·ªÉ l∆∞u tr·ªØ v·ªã tr√≠ x ƒë√£ ƒëi·ªÅu ch·ªânh\n\n        // Ki·ªÉm tra n·∫øu √¥ b√™n tr√°i ƒë√£ b·ªã chi·∫øm, th√¨ d·ªãch sang ph·∫£i\n        if (newGrid[x][y - 1] !== '') {\n          newY = y + 1; // D·ªãch sang ph·∫£i 1 ƒë∆°n v·ªã\n\n          // N·∫øu l√† horizontal, c·∫ßn ki·ªÉm tra to√†n b·ªô c√°c √¥ c·ªßa word v√† d·ªãch ch√∫ng\n          if (direction === \"horizontal\") {\n            // Ki·ªÉm tra xem sau khi d·ªãch c√≥ ƒë·ªß kh√¥ng gian kh√¥ng\n            if (newY + word.length > newGrid[0].length) {\n              // C√≥ th·ªÉ c·∫ßn x·ª≠ l√Ω tr∆∞·ªùng h·ª£p v∆∞·ª£t qu√° k√≠ch th∆∞·ªõc grid\n              console.error(\"Kh√¥ng d·ªãch ƒë∆∞·ª£c sang ph·∫£i\");\n              return;\n            }\n            // C·∫≠p nh·∫≠t c√°c √¥ c·ªßa word ·ªü v·ªã tr√≠ m·ªõi\n            for (let i = 0; i < word.length; i++) {\n              newGrid[x][newY + i] = word[i];\n              occupiedPositions.add(getKey(x, newY + i));\n            }\n            occupiedPositions.delete(getKey(x, y));\n            newGrid[x][y] = \"\";\n          }\n        }\n        if (direction === \"horizontal\" && x > 0) {\n          newGrid[y][x - 1] = `number${wordNumber.toString()}`;\n          occupiedPositions.add(getKey(x - 1, y));\n        } else if (direction === \"vertical\" && y > 0) {\n          newGrid[y - 1][x] = `number${wordNumber.toString()}`;\n          occupiedPositions.add(getKey(x, y - 1));\n        }\n      });\n      break; // Valid configuration found, exit loop\n    }\n    attempts++;\n  }\n  if (attempts >= maxAttempts) {\n    console.warn(\"Could not find a valid grid configuration without overlapping numbers or adjacent non-shared words after max attempts.\");\n  }\n  return {\n    randomHintWords,\n    newGrid\n  };\n};\nexport function generateCrossword(wordList, board) {\n  // Ki·ªÉm tra ƒë·∫ßu v√†o\n  if (!Array.isArray(wordList) || wordList.length !== 6 || !wordList.every(w => typeof w === 'string')) {\n    return {\n      board: [],\n      wordsActive: [],\n      success: false,\n      message: 'wordList must be an array of 6 strings'\n    };\n  }\n  if (!Array.isArray(board) || board.length === 0 || board[0].length !== 20) {\n    board = Array.from({\n      length: 20\n    }, () => Array(20).fill(null));\n  }\n\n  // Kh·ªüi t·∫°o c·∫•u tr√∫c d·ªØ li·ªáu\n  const wordsActive = [];\n  const wordBank = wordList.map((word, idx) => ({\n    string: word.toUpperCase(),\n    char: word.toUpperCase().split(''),\n    index: idx,\n    successfulMatches: [],\n    totalMatches: 0,\n    effectiveMatches: 0\n  }));\n  const bounds = {\n    minX: 0,\n    maxX: 0,\n    minY: 0,\n    maxY: 0,\n    update: function (x, y) {\n      this.minX = Math.min(this.minX, x);\n      this.maxX = Math.max(this.maxX, x);\n      this.minY = Math.min(this.minY, y);\n      this.maxY = Math.max(this.maxY, y);\n    }\n  };\n\n  // H√†m ki·ªÉm tra xem √¥ c√≥ h·ª£p l·ªá ƒë·ªÉ ƒë·∫∑t k√Ω t·ª± kh√¥ng\n  function isValidPosition(x, y, char, board, dir, word, i) {\n    if (x < 0 || x >= board.length || y < 0 || y >= board[0].length) return false;\n    if (board[x][y] === null) return true;\n    if (board[x][y] === char) {\n      // Ki·ªÉm tra xung ƒë·ªôt v·ªõi t·ª´ kh√°c t·∫°i giao ƒëi·ªÉm\n      const crossDir = dir === 0 ? 1 : 0;\n      const crossVal = [crossDir === 0 ? x > 0 ? board[x - 1][y] : null : y > 0 ? board[x][y - 1] : null, board[x][y], crossDir === 0 ? x < board.length - 1 ? board[x + 1][y] : null : y < board[0].length - 1 ? board[x][y + 1] : null];\n      return crossVal[0] === null && crossVal[2] === null && board[x][y] === char;\n    }\n    return false;\n  }\n\n  // H√†m m·ªü r·ªông b·∫£ng n·∫øu c·∫ßn\n  function expandBoard(board, x, y) {\n    while (x >= board.length) {\n      board.push(Array(board[0].length).fill(null));\n    }\n    while (y >= board[0].length) {\n      for (let i = 0; i < board.length; i++) {\n        board[i].push(null);\n      }\n    }\n  }\n\n  // H√†m t√¨m c√°c v·ªã tr√≠ giao nhau h·ª£p l·ªá cho m·ªôt t·ª´\n  function findMatches(word, board, wordsActive) {\n    word.successfulMatches = [];\n    word.totalMatches = 0;\n    word.effectiveMatches = 0;\n    if (wordsActive.length === 0) {\n      // N·∫øu b·∫£ng r·ªóng, ƒë·∫∑t t·ª´ ƒë·∫ßu ti√™n ·ªü gi·ªØa\n      const x = Math.floor(board.length / 2);\n      const y = Math.floor(board[0].length / 2);\n      const dir = Math.random() < 0.5 ? 0 : 1;\n      word.successfulMatches.push({\n        x,\n        y,\n        dir\n      });\n      word.totalMatches = 1;\n      word.effectiveMatches = 1;\n      return;\n    }\n    for (const placedWord of wordsActive) {\n      for (let i = 0; i < word.char.length; i++) {\n        for (let k = 0; k < placedWord.char.length; k++) {\n          if (word.char[i] === placedWord.char[k]) {\n            word.totalMatches++;\n            // Th·ª≠ ƒë·∫∑t t·ª´ theo h∆∞·ªõng ngang (dir=0) v√† d·ªçc (dir=1)\n            for (let dir = 0; dir <= 1; dir++) {\n              const x = dir === 0 ? placedWord.x + k - i : placedWord.x + k;\n              const y = dir === 0 ? placedWord.y : placedWord.y - i;\n              let isValid = true;\n              // Ki·ªÉm tra to√†n b·ªô t·ª´ c√≥ th·ªÉ ƒë·∫∑t ƒë∆∞·ª£c kh√¥ng\n              for (let m = 0; m < word.char.length; m++) {\n                const xPos = dir === 0 ? x + m : x;\n                const yPos = dir === 0 ? y : y + m;\n                expandBoard(board, xPos, yPos);\n                if (!isValidPosition(xPos, yPos, word.char[m], board, dir, word, m)) {\n                  isValid = false;\n                  break;\n                }\n              }\n              if (isValid) {\n                word.successfulMatches.push({\n                  x,\n                  y,\n                  dir\n                });\n                word.effectiveMatches++;\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n\n  // H√†m ƒë·∫∑t t·ª´ l√™n b·∫£ng\n  function placeWord(word, board, wordsActive) {\n    if (word.successfulMatches.length === 0) return false;\n\n    // Ch·ªçn ng·∫´u nhi√™n m·ªôt v·ªã tr√≠ giao nhau h·ª£p l·ªá\n    const matchIndex = Math.floor(Math.random() * word.successfulMatches.length);\n    const matchData = word.successfulMatches[matchIndex];\n\n    // C·∫≠p nh·∫≠t th√¥ng tin t·ª´\n    word.x = matchData.x;\n    word.y = matchData.y;\n    word.dir = matchData.dir;\n\n    // ƒê·∫∑t t·ª´ng k√Ω t·ª± l√™n b·∫£ng\n    for (let i = 0; i < word.char.length; i++) {\n      const xIndex = matchData.dir === 0 ? matchData.x + i : matchData.x;\n      const yIndex = matchData.dir === 0 ? matchData.y : matchData.y + i;\n      expandBoard(board, xIndex, yIndex);\n      board[xIndex][yIndex] = word.char[i];\n      bounds.update(xIndex, yIndex);\n    }\n    wordsActive.push(word);\n    return true;\n  }\n\n  // H√†m ch√≠nh ƒë·ªÉ ƒë·∫∑t t·∫•t c·∫£ t·ª´\n  while (wordBank.length > 0) {\n    let minMatchDiff = Infinity;\n    let curIndex = -1;\n\n    // T√¨m t·ª´ t·ªët nh·∫•t ƒë·ªÉ ƒë·∫∑t\n    for (let i = 0; i < wordBank.length; i++) {\n      const curWord = wordBank[i];\n      findMatches(curWord, board, wordsActive);\n      const curMatchDiff = curWord.totalMatches - curWord.effectiveMatches;\n      if (curMatchDiff < minMatchDiff && curWord.successfulMatches.length > 0) {\n        minMatchDiff = curMatchDiff;\n        curIndex = i;\n      }\n    }\n    if (curIndex === -1) {\n      return {\n        board,\n        wordsActive,\n        success: false,\n        message: 'Failed to place all words'\n      };\n    }\n\n    // ƒê·∫∑t t·ª´ v√† lo·∫°i kh·ªèi wordBank\n    const wordToPlace = wordBank.splice(curIndex, 1)[0];\n    if (!placeWord(wordToPlace, board, wordsActive)) {\n      return {\n        board,\n        wordsActive,\n        success: false,\n        message: 'Failed to place word'\n      };\n    }\n  }\n\n  // C·∫Øt b·∫£ng theo bounds ƒë·ªÉ tr·∫£ v·ªÅ k√≠ch th∆∞·ªõc t·ªëi thi·ªÉu\n  const trimmedBoard = [];\n  for (let x = bounds.minX; x <= bounds.maxX; x++) {\n    const row = board[x].slice(bounds.minY, bounds.maxY + 1);\n    trimmedBoard.push(row);\n  }\n  return {\n    board: trimmedBoard,\n    wordsActive,\n    success: true\n  };\n}\n\n//   // V√≠ d·ª• s·ª≠ d·ª•ng\n//   const wordList: string[] = ['CROSSWORD', 'PUZZLE', 'GRID', 'WORD', 'CLUE', 'GAME'];\n//   const board: (string | null)[][] = Array.from({ length: 20 }, () => Array(20).fill(null));\n//   const result: CrosswordResult = generateCrossword(wordList, board);\n//   console.log('Success:', result.success);\n//   console.log('Words Active:', result.wordsActive);\n//   console.log('Board:');\n//   result.board.forEach(row => console.log(row.map(c => c || '.').join(' ')));\n\n// function AddWordToBoard(){\n\n//     var i, len, curIndex, curWord, curChar, curMatch, testWord, testChar,\n//         minMatchDiff = 9999, curMatchDiff;\n\n//     if(wordsActive.length < 1){\n//       curIndex = 0;\n//       for(i = 0, len = wordBank.length; i < len; i++){\n//         if (wordBank[i].totalMatches < wordBank[curIndex].totalMatches){\n//           curIndex = i;\n//         }\n//       }\n//       wordBank[curIndex].successfulMatches = [{x:12,y:12,dir:0}];\n//     }\n//     else{\n//       curIndex = -1;\n\n//       for(i = 0, len = wordBank.length; i < len; i++){\n//         curWord = wordBank[i];\n//         curWord.effectiveMatches = 0;\n//         curWord.successfulMatches = [];\n//         for(var j = 0, lenJ = curWord.char.length; j < lenJ; j++){\n//           if(j == 1) continue; // skip pos\n//           curChar = curWord.char[j];\n//           for (var k = 0, lenK = wordsActive.length; k < lenK; k++){\n//             testWord = wordsActive[k];\n//             for (var l = 0, lenL = testWord.char.length; l < lenL; l++){\n//               if(l == 1) continue; // skip pos\n//               testChar = testWord.char[l];\n//               if (curChar === testChar){\n//                 curWord.effectiveMatches++;\n\n//                 var curCross = {x:testWord.x,y:testWord.y,dir:0};\n//                 if(testWord.dir === 0){\n//                   curCross.dir = 1;\n//                   curCross.x += l;\n//                   curCross.y -= j;\n//                 }\n//                 else{\n//                   curCross.dir = 0;\n//                   curCross.y += l;\n//                   curCross.x -= j;\n//                 }\n\n//                 var isMatch = true;\n\n//                 for(var m = -1, lenM = curWord.char.length + 1; m < lenM; m++){\n//                   var crossVal = [];\n//                   if (m !== j){\n//                     if (curCross.dir === 0){\n//                       var xIndex = curCross.x + m;\n\n//                       if (xIndex < 0 || xIndex > board.length){\n//                         isMatch = false;\n//                         break;\n//                       }\n\n//                       crossVal.push(board[xIndex][curCross.y]);\n//                       crossVal.push(board[xIndex][curCross.y + 1]);\n//                       crossVal.push(board[xIndex][curCross.y - 1]);\n//                     }\n//                     else{\n//                       var yIndex = curCross.y + m;\n\n//                       if (yIndex < 0 || yIndex > board[curCross.x].length){\n//                         isMatch = false;\n//                         break;\n//                       }\n\n//                       crossVal.push(board[curCross.x][yIndex]);\n//                       crossVal.push(board[curCross.x + 1][yIndex]);\n//                       crossVal.push(board[curCross.x - 1][yIndex]);\n//                     }\n\n//                     if(m > -1 && m < lenM-1){\n//                       if (crossVal[0] !== curWord.char[m]){\n//                         if (crossVal[0] !== null){\n//                           isMatch = false;\n//                           break;\n//                         }\n//                         else if (crossVal[1] !== null){\n//                           isMatch = false;\n//                           break;\n//                         }\n//                         else if (crossVal[2] !== null){\n//                           isMatch = false;\n//                           break;\n//                         }\n//                       }\n//                     }\n//                     else if (crossVal[0] !== null){\n//                       isMatch = false;\n//                       break;\n//                     }\n//                   }\n//                 }\n\n//                 if (isMatch === true){\n//                   curWord.successfulMatches.push(curCross);\n//                 }\n//               }\n//             }\n//           }\n//         }\n\n//         curMatchDiff = curWord.totalMatches - curWord.effectiveMatches;\n\n//         if (curMatchDiff<minMatchDiff && curWord.successfulMatches.length>0){\n//           curMatchDiff = minMatchDiff;\n//           curIndex = i;\n//         }\n//         else if (curMatchDiff <= 0){\n//           return false;\n//         }\n//       }\n//     }\n\n//     if (curIndex === -1){\n//       return false;\n//     }\n\n//     var spliced = wordBank.splice(curIndex, 1);\n//     wordsActive.push(spliced[0]);\n\n//     var pushIndex = wordsActive.length - 1,\n//         rand = Math.random(),\n//         matchArr = wordsActive[pushIndex].successfulMatches,\n//         matchIndex = Math.floor(rand * matchArr.length),\n//         matchData = matchArr[matchIndex];\n\n//     wordsActive[pushIndex].x = matchData.x;\n//     wordsActive[pushIndex].y = matchData.y;\n//     wordsActive[pushIndex].dir = matchData.dir;\n\n//     let actualIndex = findWordIdx(wordsActive[pushIndex].string);\n//     console.log(wordsActive[pushIndex].string, \" ~~~ \", actualIndex);\n//     for(i = 0, len = wordsActive[pushIndex].char.length; i < len; i++){\n//       var xIndex = matchData.x,\n//           yIndex = matchData.y;\n\n//       if (matchData.dir === 0){\n//         xIndex += i;\n//       }\n//       else{\n//         yIndex += i;\n//       }\n//       board[xIndex][yIndex] = wordsActive[pushIndex].char[i];\n//       isPos[xIndex][yIndex] = (i == 1);\n//       classesOfBoard[xIndex][yIndex].push(actualIndex);\n//       console.log(xIndex, yIndex, classesOfBoard[xIndex][yIndex]);\n\n//       Bounds.Update(xIndex,yIndex);\n//     }\n\n//     return true;\n//   }\n\nconst placeWordsOnGrid = (words, gridSize = {\n  width: 20,\n  height: 20\n}) => {\n  var _gridSize$width, _gridSize$height;\n  const WIDTH = (_gridSize$width = gridSize.width) !== null && _gridSize$width !== void 0 ? _gridSize$width : 20;\n  const HEIGHT = (_gridSize$height = gridSize.height) !== null && _gridSize$height !== void 0 ? _gridSize$height : 100;\n\n  // Initialize grid\n  const grid = Array(HEIGHT).fill(null).map(() => Array(WIDTH).fill(null));\n  const hintWords = [];\n\n  // Validation\n  if (words.length !== 6) {\n    throw new Error(\"Exactly 6 words are required\");\n  }\n\n  // Helper: Check if a word can be placed\n  const canPlaceWord = (word, row, col, isVertical) => {\n    if (isVertical) {\n      if (row + word.length > HEIGHT) return false;\n      for (let i = 0; i < word.length; i++) {\n        const cell = grid[row + i][col];\n        if (cell !== null && cell !== word[i]) return false;\n        // Check adjacent cells to prevent unwanted adjacency\n        if (i === 0 && row > 0 && grid[row - 1][col] !== null) return false;\n        if (i === word.length - 1 && row + i + 1 < HEIGHT && grid[row + i + 1][col] !== null) return false;\n        if (col > 0 && grid[row + i][col - 1] !== null) return false;\n        if (col < WIDTH - 1 && grid[row + i][col + 1] !== null) return false;\n      }\n    } else {\n      if (col + word.length > WIDTH) return false;\n      for (let i = 0; i < word.length; i++) {\n        const cell = grid[row][col + i];\n        if (cell !== null && cell !== word[i]) return false;\n        // Check adjacent cells\n        if (i === 0 && col > 0 && grid[row][col - 1] !== null) return false;\n        if (i === word.length - 1 && col + i + 1 < WIDTH && grid[row][col + i + 1] !== null) return false;\n        if (row > 0 && grid[row - 1][col + i] !== null) return false;\n        if (row < HEIGHT - 1 && grid[row + 1][col + i] !== null) return false;\n      }\n    }\n    return true;\n  };\n\n  // Helper: Place a word on the grid\n  const placeWord = (word, row, col, isVertical) => {\n    for (let i = 0; i < word.length; i++) {\n      if (isVertical) {\n        grid[row + i][col] = word[i];\n      } else {\n        grid[row][col + i] = word[i];\n      }\n    }\n    hintWords.push({\n      word,\n      x: col,\n      y: row,\n      direction: isVertical ? \"vertical\" : \"horizontal\"\n    });\n  };\n\n  // Helper: Find intersections between two words\n  const findIntersections = (word1, word2, word1Dir) => {\n    const intersections = [];\n    for (let i = 0; i < word1.length; i++) {\n      for (let j = 0; j < word2.length; j++) {\n        if (word1[i] === word2[j]) {\n          if (word1Dir === 0) {\n            intersections.push({\n              char: word1[i],\n              hPos: i,\n              vPos: j\n            });\n          } else {\n            intersections.push({\n              char: word1[i],\n              vPos: i,\n              hPos: j\n            });\n          }\n        }\n      }\n    }\n    return intersections;\n  };\n\n  // Shuffle words and split into horizontal and vertical\n  const shuffledWords = [...words].sort(() => Math.random() - 0.5);\n  const horizontalWords = shuffledWords.slice(0, 3);\n  const verticalWords = shuffledWords.slice(3, 6);\n  const intersectionPairs = Math.random() < 0.5 ? 1 : 2;\n\n  // Place first horizontal word\n  const h1Row = Math.floor(Math.random() * 10) + 5;\n  const h1Col = Math.floor(Math.random() * (WIDTH - horizontalWords[0].length));\n  placeWord(horizontalWords[0], h1Row, h1Col, false);\n\n  // Place first vertical word with intersection\n  let v1Row = Math.floor(Math.random() * (HEIGHT - verticalWords[0].length));\n  let v1Col = Math.floor(Math.random() * WIDTH);\n  let v1Placed = false;\n  const intersections1 = findIntersections(horizontalWords[0], verticalWords[0], 0);\n  if (intersections1.length > 0) {\n    const inter = intersections1[Math.floor(Math.random() * intersections1.length)];\n    const tryV1Col = h1Col + inter.hPos;\n    const tryV1Row = h1Row - inter.vPos;\n    if (canPlaceWord(verticalWords[0], tryV1Row, tryV1Col, true)) {\n      v1Row = tryV1Row;\n      v1Col = tryV1Col;\n      v1Placed = true;\n    }\n  }\n  if (canPlaceWord(verticalWords[0], v1Row, v1Col, true)) {\n    placeWord(verticalWords[0], v1Row, v1Col, true);\n  }\n\n  // Place second horizontal word, possibly intersecting with first vertical\n  let h2Row = Math.floor(Math.random() * 10) + 15;\n  let h2Col = Math.floor(Math.random() * (WIDTH - horizontalWords[1].length));\n  let h2Placed = false;\n  if (intersectionPairs === 2 && v1Placed) {\n    const intersections2 = findIntersections(verticalWords[0], horizontalWords[1], 1);\n    if (intersections2.length > 0) {\n      const inter = intersections2[Math.floor(Math.random() * intersections2.length)];\n      const tryH2Row = v1Row + inter.vPos;\n      const tryH2Col = v1Col - inter.hPos;\n      if (canPlaceWord(horizontalWords[1], tryH2Row, tryH2Col, false)) {\n        h2Row = tryH2Row;\n        h2Col = tryH2Col;\n        h2Placed = true;\n      }\n    }\n  }\n  if (canPlaceWord(horizontalWords[1], h2Row, h2Col, false)) {\n    placeWord(horizontalWords[1], h2Row, h2Col, false);\n  }\n\n  // Place second vertical word, possibly intersecting with second horizontal\n  let v2Row = Math.floor(Math.random() * (HEIGHT - verticalWords[1].length));\n  let v2Col = Math.floor(Math.random() * WIDTH);\n  let v2Placed = false;\n  if (h2Placed && intersectionPairs === 2) {\n    const intersections3 = findIntersections(horizontalWords[1], verticalWords[1], 0);\n    if (intersections3.length > 0) {\n      const inter = intersections3[Math.floor(Math.random() * intersections3.length)];\n      const tryV2Col = h2Col + inter.hPos;\n      const tryV2Row = h2Row - inter.vPos;\n      if (canPlaceWord(verticalWords[1], tryV2Row, tryV2Col, true)) {\n        v2Row = tryV2Row;\n        v2Col = tryV2Col;\n        v2Placed = true;\n      }\n    }\n  }\n  if (canPlaceWord(verticalWords[1], v2Row, v2Col, true)) {\n    placeWord(verticalWords[1], v2Row, v2Col, true);\n  }\n\n  // Place third horizontal word\n  const h3Row = Math.floor(Math.random() * 10) + 25;\n  const h3Col = Math.floor(Math.random() * (WIDTH - horizontalWords[2].length));\n  if (canPlaceWord(horizontalWords[2], h3Row, h3Col, false)) {\n    placeWord(horizontalWords[2], h3Row, h3Col, false);\n  }\n\n  // Place third vertical word\n  const v3Row = Math.floor(Math.random() * (HEIGHT - verticalWords[2].length));\n  const v3Col = Math.floor(Math.random() * WIDTH);\n  if (canPlaceWord(verticalWords[2], v3Row, v3Col, true)) {\n    placeWord(verticalWords[2], v3Row, v3Col, true);\n  }\n  return {\n    grid,\n    hintWords\n  };\n};\nexport { placeWordsOnGrid };","map":{"version":3,"names":["findCommonLetterIndexes","word1","word2","result","i","length","j","push","canPlaceWord","word","x","y","grid","direction","undefined","findCommonLetterPairs","wordList","gridSize","REQUIRE_PAIRS","Math","floor","random","console","log","tempWordList","commonPairs","placedWords","Set","wordsCoordinate","found","pairs","nextPosition","has","index","add","sortedTempWordList","sort","a","b","keys","Object","word1Coordinate","word2Coordinate","generateHintWords","words","obstacleWord","Array","fill","map","results","usedWords","remainingPairs","commonLetters","filter","letter","includes","scoredLetters","index1","indexOf","index2","center1","center2","score","abs","prioritizedLetters","item","pair","shuffledWords","placeWordsOnGrid","occupiedPositions","placedSet","allPlaced","getKey","newX","newY","commonLetterPairs","commonLetter","placed","attempt","intersecrX","intersectY","pop","warn","shift","renderGrid","mainKeyword","GRID_SIZE","maxAttempts","generateEmptyGrid","canPlaceNumber","hasCommonLetter","some","attempts","randomHintWords","newGrid","occupiedRows","occupiedCols","clear","canPlaceAll","other","wordNumber","error","forEach","delete","toString","generateCrossword","board","isArray","every","w","wordsActive","success","message","from","wordBank","idx","string","toUpperCase","char","split","successfulMatches","totalMatches","effectiveMatches","bounds","minX","maxX","minY","maxY","update","min","max","isValidPosition","dir","crossDir","crossVal","expandBoard","findMatches","placedWord","k","isValid","m","xPos","yPos","placeWord","matchIndex","matchData","xIndex","yIndex","minMatchDiff","Infinity","curIndex","curWord","curMatchDiff","wordToPlace","splice","trimmedBoard","row","slice","width","height","_gridSize$width","_gridSize$height","WIDTH","HEIGHT","hintWords","Error","col","isVertical","cell","findIntersections","word1Dir","intersections","hPos","vPos","horizontalWords","verticalWords","intersectionPairs","h1Row","h1Col","v1Row","v1Col","v1Placed","intersections1","inter","tryV1Col","tryV1Row","h2Row","h2Col","h2Placed","intersections2","tryH2Row","tryH2Col","v2Row","v2Col","v2Placed","intersections3","tryV2Col","tryV2Row","h3Row","h3Col","v3Row","v3Col"],"sources":["C:/Users/ASUS/Documents/htm_fe/src/layouts/RoundBase/utils.ts"],"sourcesContent":["// T·∫°o t·ª´ kh√≥a g·ª£i √Ω v·ªõi v·ªã tr√≠ v√† h∆∞·ªõng random\r\n\r\ninterface HintWord {\r\n    word: string;\r\n    x: number;\r\n    y: number;\r\n    direction: \"horizontal\" | \"vertical\";\r\n}\r\n\r\ninterface ObstacleQuestionBoxProps {\r\n    obstacleWord: string;\r\n}\r\n\r\ntype PlacedWord = {\r\n    word: string;\r\n    x: number;\r\n    y: number;\r\n    direction: \"horizontal\" | \"vertical\";\r\n};\r\n\r\n\r\nexport const findCommonLetterIndexes = (word1: string, word2: string) => {\r\n    const result = []\r\n    for (let i=0;i<word1.length;i++) {\r\n        for(let j =0;j<word2.length;j++) {\r\n            if(word1[i] === word2[j]) {\r\n                result.push({\r\n                    [word1] : i,\r\n                    [word2] : j\r\n                })\r\n            }\r\n        }\r\n    }\r\n\r\n    return result\r\n}\r\n\r\nconst canPlaceWord = (word: string, x:number, y:number, grid:string[][], direction:\"horizontal\"|\"vertical\") => {\r\n    if(direction == \"horizontal\") {\r\n        for (let i=0;i<word.length;i++) {\r\n            if (grid[x][y+i] !== \"\" || grid[x][y+i] == undefined) return false\r\n        }\r\n    }\r\n\r\n    if(direction ==\"vertical\") {\r\n        for (let i=0;i<word.length;i++) {\r\n            if (grid[x+i][y] !== \"\") return false\r\n        }\r\n    }\r\n\r\n    return true\r\n}\r\n\r\nexport const findCommonLetterPairs = (wordList: string[], gridSize: number, grid: string[][]) => {\r\n    const REQUIRE_PAIRS = Math.floor(Math.random()*2) + 1\r\n    console.log(\"REQUIRE_PAIRS\",REQUIRE_PAIRS);\r\n    \r\n    const tempWordList = [...wordList]\r\n    const commonPairs = [\r\n    ]\r\n    const placedWords = new Set()\r\n    const wordsCoordinate: PlacedWord[] = []\r\n\r\n    let found = false\r\n    let pairs = 0\r\n    let direction = \"horizontal\"\r\n    let nextPosition:{x:number, y:number} = {\r\n        x: 0,\r\n        y: 0\r\n    }\r\n\r\n    \r\n    if(REQUIRE_PAIRS == 2) {\r\n        while (pairs <REQUIRE_PAIRS && !found) {\r\n        \r\n            for (let i =0;i<tempWordList.length;i++) {\r\n                if(pairs==REQUIRE_PAIRS || found == true) break\r\n    \r\n                const word1 = tempWordList[i]\r\n                if(placedWords.has(word1)) continue\r\n    \r\n                for (let j =0;j<tempWordList.length;j++) {\r\n                    if (tempWordList[j] === word1) continue\r\n    \r\n                    if(placedWords.has(tempWordList[j])) continue\r\n    \r\n                    const result = findCommonLetterIndexes(word1,tempWordList[j])\r\n    \r\n                    if(result.length >0) {\r\n                        console.log(\"result\",result);\r\n                        const index = Math.floor(Math.random() * result.length)\r\n                        console.log(\"index\",index);\r\n                        \r\n                        commonPairs.push(result[index])\r\n                        console.log(\"pairs\",pairs);\r\n                        placedWords.add(word1)\r\n                        placedWords.add(tempWordList[j])\r\n                        pairs = pairs + 1\r\n                        break\r\n                    }\r\n    \r\n                    if(i==tempWordList.length-1 && j==tempWordList.length-1) {\r\n                        found = true\r\n                        break\r\n                    }\r\n    \r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    if(REQUIRE_PAIRS == 1) {\r\n        const sortedTempWordList = [...tempWordList].sort((a, b) => b.length - a.length);\r\n        let index = -1\r\n        while (!found) {\r\n        \r\n            for (let i =0;i<sortedTempWordList.length;i++) {\r\n                if(found == true) break\r\n    \r\n                const word1 = sortedTempWordList[i]\r\n                if(placedWords.has(word1)) continue\r\n    \r\n                for (let j =0;j<sortedTempWordList.length;j++) {\r\n                    if (sortedTempWordList[j] === word1) continue\r\n    \r\n                    const result = findCommonLetterIndexes(word1,sortedTempWordList[j])\r\n    \r\n                    if(result.length >0) {\r\n                        console.log(\"result\",result);\r\n                        const index = Math.floor(Math.random() * result.length)\r\n                        console.log(\"index\",index);\r\n                        \r\n                        commonPairs.push(result[index])\r\n                        console.log(\"pairs\",pairs);\r\n                        placedWords.add(word1)\r\n                        placedWords.add(sortedTempWordList[j])\r\n\r\n                        \r\n                    }\r\n\r\n                    if(commonPairs.length ==2) {\r\n                        found = true\r\n                        break\r\n                    }\r\n    \r\n                    if(i==tempWordList.length-1 && j==tempWordList.length-1) {\r\n                        found = true\r\n                        break\r\n                    }\r\n    \r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    //loop until 2 pairs are found or go through all the array\r\n    \r\n\r\n    for (let pairs of commonPairs){\r\n        const keys = Object.keys(pairs);\r\n        const x = Math.floor(Math.random() * gridSize)\r\n        const y = Math.floor(Math.random() * (gridSize-keys[0].length))\r\n        const word1Coordinate: PlacedWord = {\r\n            word: keys[0],\r\n            x: x,\r\n            y: y,\r\n            direction: \"horizontal\"\r\n        }\r\n\r\n        const word2Coordinate: PlacedWord = {\r\n            word: keys[1],\r\n            x: 1,\r\n            y: pairs[keys[0]] + 1,\r\n            direction: \"vertical\"\r\n        }\r\n\r\n        placedWords.add(word1Coordinate)\r\n        placedWords.add(word2Coordinate)\r\n\r\n    }\r\n\r\n    return commonPairs\r\n    \r\n}\r\n\r\n\r\n\r\nexport const generateHintWords = (words: string[], gridSize: number, obstacleWord: string): HintWord[] => {\r\n    const grid: string[][] = Array(gridSize)\r\n        .fill(null)\r\n        .map(() => Array(gridSize).fill(\"\")); // M·∫£ng ki·ªÉm tra v·ªã tr√≠\r\n\r\n    const findCommonLetterPairs = (words: string[]): { word1: string; word2: string; commonLetters: string[] }[] => {\r\n        let results: { word1: string; word2: string; commonLetters: string[] }[] = [];\r\n        let usedWords = new Set<string>(); // L∆∞u l·∫°i c√°c t·ª´ ƒë√£ d√πng\r\n\r\n        let remainingPairs: { word1: string; word2: string; commonLetters: string[] }[] = [];\r\n\r\n        for (let i = 0; i < words.length; i++) {\r\n            for (let j = i + 1; j < words.length; j++) {\r\n                const word1 = words[i];\r\n                const word2 = words[j];\r\n\r\n                // T√¨m k√Ω t·ª± chung gi·ªØa 2 t·ª´\r\n                const commonLetters = [...new Set(word1)].filter((letter) => word2.includes(letter));\r\n\r\n                if (commonLetters.length >= 2) {\r\n                    // T√≠nh ƒëi·ªÉm ∆∞u ti√™n (ch·ªØ g·∫ßn trung t√¢m h∆°n)\r\n                    const scoredLetters = commonLetters.map((letter) => {\r\n                        const index1 = word1.indexOf(letter);\r\n                        const index2 = word2.indexOf(letter);\r\n                        const center1 = word1.length / 2;\r\n                        const center2 = word2.length / 2;\r\n                        const score = Math.abs(index1 - center1) + Math.abs(index2 - center2);\r\n                        return { letter, score };\r\n                    });\r\n\r\n                    // S·∫Øp x·∫øp theo ƒëi·ªÉm ∆∞u ti√™n\r\n                    scoredLetters.sort((a, b) => a.score - b.score);\r\n                    const prioritizedLetters = scoredLetters.map((item) => item.letter);\r\n\r\n                    remainingPairs.push({ word1, word2, commonLetters: prioritizedLetters });\r\n                }\r\n            }\r\n        }\r\n\r\n        // B∆∞·ªõc 2: Ch·ªçn t·ªëi ƒëa 2 c·∫∑p theo quy t·∫Øc\r\n        for (const pair of remainingPairs) {\r\n            if (results.length >= 2) break; // ƒê·ªß 2 c·∫∑p th√¨ d·ª´ng\r\n            if (!usedWords.has(pair.word1) && !usedWords.has(pair.word2)) {\r\n                results.push(pair);\r\n                usedWords.add(pair.word1);\r\n                usedWords.add(pair.word2);\r\n            }\r\n        }\r\n\r\n        // N·∫øu v·∫´n ch∆∞a ƒë·ªß 2 c·∫∑p, ch·ªçn ti·∫øp t·ª´ c√°c c·∫∑p c√≥ t·ª´ ƒë√£ d√πng\r\n        for (const pair of remainingPairs) {\r\n            if (results.length >= 2) break;\r\n            if (!usedWords.has(pair.word1) || !usedWords.has(pair.word2)) {\r\n                results.push(pair);\r\n                usedWords.add(pair.word1);\r\n                usedWords.add(pair.word2);\r\n            }\r\n        }\r\n\r\n        return results;\r\n    };\r\n\r\n    // üõ† Test\r\n    //const testwords = [\"B∆ØUCH√çNH\", \"5G\", \"BQP\", \"T·∫¨PƒêO√ÄN\", \"H√ÄN·ªòI\", \"RED\"];\r\n\r\n    const shuffledWords = [...words].sort(() => Math.random() - 0.5);\r\n    const placeWordsOnGrid = (words: string[], gridSize: number): PlacedWord[] => {\r\n        while (true) {\r\n            let placedWords: PlacedWord[] = [];\r\n            let occupiedPositions = new Set<string>();\r\n            let placedSet = new Set<string>(); // Set ƒë·ªÉ theo d√µi t·ª´ ƒë√£ ƒë·∫∑t\r\n            let allPlaced = true; // C·ªù ki·ªÉm tra xem t·∫•t c·∫£ t·ª´ c√≥ ƒë∆∞·ª£c ƒë·∫∑t hay kh√¥ng\r\n\r\n            const getKey = (x: number, y: number) => `${x},${y}`;\r\n\r\n            const canPlaceWord = (word: string, x: number, y: number, direction: \"horizontal\" | \"vertical\", index: number) => {\r\n                for (let i = 0; i < word.length; i++) {\r\n                    if (i === x + index) continue;\r\n                    let newX = direction === \"horizontal\" ? x + i : x;\r\n                    let newY = direction === \"horizontal\" ? y : y + i;\r\n                    if (newX < 0 || newY < 0 || newX >= gridSize || newY >= gridSize || occupiedPositions.has(getKey(newX, newY))) {\r\n                        return false;\r\n                    }\r\n                }\r\n                return true;\r\n            };\r\n\r\n            const commonLetterPairs = findCommonLetterPairs(words);\r\n            console.log(commonLetterPairs);\r\n\r\n            for (const { word1, word2, commonLetters } of commonLetterPairs) {\r\n                if (placedSet.has(word1) || placedSet.has(word2)) continue; // Ki·ªÉm tra n·∫øu ƒë√£ ƒë·∫∑t th√¨ b·ªè qua\r\n\r\n                const commonLetter = commonLetters[0];\r\n                const index1 = word1.indexOf(commonLetter);\r\n                const index2 = word2.indexOf(commonLetter);\r\n\r\n                let placed = false;\r\n                for (let attempt = 0; attempt < 100; attempt++) {\r\n                    let x = Math.floor(Math.random() * (gridSize - word1.length)) + 1;\r\n                    let y = Math.floor(Math.random() * (gridSize - index2) + index2) + 1;\r\n\r\n                    if (canPlaceWord(word1, x, y, \"horizontal\", index1)) {\r\n                        placedWords.push({ word: word1, x, y, direction: \"horizontal\" });\r\n                        placedSet.add(word1);\r\n\r\n                        let intersecrX = x + index1;\r\n                        let intersectY = y;\r\n\r\n                        if (canPlaceWord(word2, intersecrX, intersectY - index2, \"vertical\", index2)) {\r\n                            for (let i = 0; i < word1.length; i++) occupiedPositions.add(getKey(x + i, y));\r\n                            placedWords.push({ word: word2, x: intersecrX, y: intersectY - index2, direction: \"vertical\" });\r\n                            placedSet.add(word2);\r\n\r\n                            for (let i = 0; i < word2.length; i++) occupiedPositions.add(getKey(intersecrX, intersectY - index2 + i));\r\n\r\n                            placed = true;\r\n                            break;\r\n                        } else {\r\n                            placedWords.pop();\r\n                        }\r\n                    }\r\n                }\r\n\r\n                if (!placed) {\r\n                    console.warn(`Kh√¥ng th·ªÉ ƒë·∫∑t c·∫∑p t·ª´: ${word1} - ${word2}`);\r\n                    allPlaced = false;\r\n                    break;\r\n                }\r\n            }\r\n\r\n\r\n\r\n            for (const word of words) {\r\n                if (placedSet.has(word)) continue;\r\n\r\n                let placed = false;\r\n                let found = false;\r\n\r\n                for (let j = placedWords.length - 1; j >= 0; j--) {\r\n                    for (let attempt = 0; attempt < 10; attempt++) {\r\n                        let direction: \"horizontal\" | \"vertical\" = placedWords[j].direction === \"horizontal\" ? \"vertical\" : \"horizontal\";\r\n                        const shift = Math.random() < 0.5 ? 1 : -1;\r\n                        let x = placedWords[j].direction === \"horizontal\" ? placedWords[j].word.length + placedWords[j].x : placedWords[j].x + 1;\r\n                        let y = placedWords[j].direction === \"horizontal\" ? placedWords[j].y + 2 : placedWords[j].word.length + placedWords[j].y;\r\n\r\n                        if (canPlaceWord(word, x, y, direction, 0)) {\r\n                            placedWords.push({ word, x, y, direction });\r\n                            placedSet.add(word);\r\n\r\n                            for (let i = 0; i < word.length; i++) {\r\n                                let newX = direction === \"horizontal\" ? x + i : x;\r\n                                let newY = direction === \"horizontal\" ? y : y + i;\r\n                                occupiedPositions.add(getKey(newX, newY));\r\n                            }\r\n\r\n                            placed = true;\r\n                            found = true;\r\n                            break;\r\n                        }\r\n                    }\r\n\r\n                    if (found) break;\r\n                }\r\n\r\n                if (!placed) {\r\n                    console.warn(`Kh√¥ng th·ªÉ ƒë·∫∑t t·ª´: ${word}`);\r\n                    allPlaced = false;\r\n                    break;\r\n                }\r\n            }\r\n            if (!allPlaced) continue; // N·∫øu c√≥ t·ª´ kh√¥ng ƒë·∫∑t ƒë∆∞·ª£c, restart v√≤ng l·∫∑p\r\n\r\n            if (allPlaced) return placedWords; // N·∫øu t·∫•t c·∫£ t·ª´ ƒë·ªÅu ƒë∆∞·ª£c ƒë·∫∑t, tho√°t kh·ªèi v√≤ng l·∫∑p v√† tr·∫£ v·ªÅ k·∫øt qu·∫£\r\n        }\r\n    };\r\n\r\n    const placedWords = placeWordsOnGrid(shuffledWords, gridSize);\r\n    console.log(placedWords);\r\n\r\n    return placedWords;\r\n};\r\n\r\n\r\nexport const renderGrid = (wordList: string[], mainKeyword:string, GRID_SIZE:number) => {\r\n    console.log(\"wordList on render\", wordList);\r\n    \r\n    const maxAttempts = 100;\r\n\r\n    const generateEmptyGrid = () => {\r\n        return Array(GRID_SIZE).fill(null).map(() => Array(GRID_SIZE).fill(\"\"));\r\n    };\r\n\r\n    const getKey = (x: number, y: number) => `${x},${y}`;\r\n\r\n    const canPlaceNumber = (x: number, y: number) => {\r\n        if (x < 0 || y < 0 || x >= GRID_SIZE || y >= GRID_SIZE) return false;\r\n        return !occupiedPositions.has(getKey(x, y));\r\n    };\r\n\r\n    const hasCommonLetter = (word1: string, word2: string) => {\r\n        return [...new Set(word1)].some((letter) => word2.includes(letter));\r\n    };\r\n\r\n    // Try to place words and numbers until a valid configuration is found\r\n    let attempts = 0;\r\n    let randomHintWords: HintWord[] = [];\r\n    let newGrid = generateEmptyGrid();\r\n    let occupiedPositions = new Set<string>();\r\n    let occupiedRows = new Set<number>();\r\n    let occupiedCols = new Set<number>();\r\n\r\n\r\n    while (attempts < maxAttempts) {\r\n        randomHintWords = generateHintWords(wordList, GRID_SIZE, mainKeyword);\r\n        newGrid = generateEmptyGrid();\r\n        occupiedPositions.clear();\r\n        occupiedRows.clear();\r\n        occupiedCols.clear();\r\n\r\n        let canPlaceAll = true;\r\n\r\n        // First pass: Place words and mark their positions\r\n        for (const { word, x, y, direction } of randomHintWords) {\r\n            if (direction === \"horizontal\") {\r\n                occupiedRows.add(y);\r\n                // Check for adjacent rows\r\n                for (const other of randomHintWords) {\r\n                    if (other.word === word || other.direction !== \"horizontal\") continue; // Fixed comparison\r\n                    if (Math.abs(other.y - y) === 1 && !hasCommonLetter(word, other.word)) {\r\n                        canPlaceAll = false;\r\n                        break;\r\n                    }\r\n                }\r\n            } else {\r\n                occupiedCols.add(x);\r\n                // Check for adjacent columns\r\n                for (const other of randomHintWords) {\r\n                    if (other.word === word || other.direction !== \"vertical\") continue; // Fixed comparison\r\n                    if (Math.abs(other.x - x) === 1 && !hasCommonLetter(word, other.word)) {\r\n                        canPlaceAll = false;\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n\r\n            if (!canPlaceAll) break;\r\n\r\n            for (let i = 0; i < word.length; i++) {\r\n                let newX = direction === \"horizontal\" ? x + i : x;\r\n                let newY = direction === \"horizontal\" ? y : y + i;\r\n                newGrid[newY][newX] = word[i];\r\n                occupiedPositions.add(getKey(newX, newY));\r\n            }\r\n        }\r\n\r\n        if (!canPlaceAll) {\r\n            attempts++;\r\n            continue;\r\n        }\r\n\r\n        // Second pass: Check if numbers can be placed without overlap\r\n\r\n        for (const { word, x, y, direction } of randomHintWords) {\r\n            const wordNumber = wordList.includes(word) ? wordList.indexOf(word) + 1 : -1; // Ki·ªÉm tra tr∆∞·ªõc khi l·∫•y s·ªë\r\n\r\n            if (wordNumber === -1) {\r\n                console.error(`Kh√¥ng t√¨m th·∫•y t·ª´ ${word} trong wordList`);\r\n                continue; // N·∫øu kh√¥ng t√¨m th·∫•y, ti·∫øp t·ª•c v√≤ng l·∫∑p\r\n            }\r\n\r\n            if (direction === \"horizontal\" && x > 0) {\r\n                if (!canPlaceNumber(x - 1, y)) {\r\n                    canPlaceAll = false;\r\n                    break;\r\n                }\r\n            } else if (direction === \"vertical\" && y > 0) {\r\n                if (!canPlaceNumber(x, y - 1)) {\r\n                    canPlaceAll = false;\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n\r\n\r\n        if (canPlaceAll) {\r\n            // Place numbers if all checks pass\r\n            randomHintWords.forEach(({ word, x, y, direction }) => {\r\n                const wordNumber = wordList.indexOf(word) + 1;\r\n                console.log(\"wordList\",wordList)\r\n                console.log(\"word\",word);\r\n                \r\n                console.log(\"wordNumber\",wordNumber)\r\n                let newY = y; // T·∫°o bi·∫øn m·ªõi ƒë·ªÉ l∆∞u tr·ªØ v·ªã tr√≠ x ƒë√£ ƒëi·ªÅu ch·ªânh\r\n\r\n                // Ki·ªÉm tra n·∫øu √¥ b√™n tr√°i ƒë√£ b·ªã chi·∫øm, th√¨ d·ªãch sang ph·∫£i\r\n                if (newGrid[x][y-1] !== '') {\r\n                    newY = y + 1; // D·ªãch sang ph·∫£i 1 ƒë∆°n v·ªã\r\n                    \r\n                    // N·∫øu l√† horizontal, c·∫ßn ki·ªÉm tra to√†n b·ªô c√°c √¥ c·ªßa word v√† d·ªãch ch√∫ng\r\n                    if (direction === \"horizontal\") {\r\n                        // Ki·ªÉm tra xem sau khi d·ªãch c√≥ ƒë·ªß kh√¥ng gian kh√¥ng\r\n                        if (newY + word.length > newGrid[0].length) {\r\n                            // C√≥ th·ªÉ c·∫ßn x·ª≠ l√Ω tr∆∞·ªùng h·ª£p v∆∞·ª£t qu√° k√≠ch th∆∞·ªõc grid\r\n                            console.error(\"Kh√¥ng d·ªãch ƒë∆∞·ª£c sang ph·∫£i\")\r\n                            return;\r\n                        }\r\n                        // C·∫≠p nh·∫≠t c√°c √¥ c·ªßa word ·ªü v·ªã tr√≠ m·ªõi\r\n                        for (let i = 0; i < word.length; i++) {\r\n                            newGrid[x][newY+i] = word[i];\r\n                            occupiedPositions.add(getKey(x, newY+i));\r\n                        }\r\n\r\n                        occupiedPositions.delete(getKey(x,y))\r\n                        newGrid[x][y] = \"\"\r\n                    }\r\n                }\r\n                if (direction === \"horizontal\" && x > 0) {\r\n                    newGrid[y][x - 1] = `number${wordNumber.toString()}`;\r\n                    occupiedPositions.add(getKey(x - 1, y));\r\n                } else if (direction === \"vertical\" && y > 0) {\r\n                    newGrid[y - 1][x] = `number${wordNumber.toString()}`;\r\n                    occupiedPositions.add(getKey(x, y - 1));\r\n                }\r\n            });\r\n\r\n\r\n            break; // Valid configuration found, exit loop\r\n        }\r\n\r\n        attempts++;\r\n    }\r\n\r\n    if (attempts >= maxAttempts) {\r\n        console.warn(\"Could not find a valid grid configuration without overlapping numbers or adjacent non-shared words after max attempts.\");\r\n    }\r\n\r\n    return {randomHintWords, newGrid}\r\n}\r\n\r\ninterface Word {\r\n    string: string;\r\n    char: string[];\r\n    index: number;\r\n    successfulMatches: Match[];\r\n    totalMatches: number;\r\n    effectiveMatches: number;\r\n    x?: number;\r\n    y?: number;\r\n    dir?: number;\r\n  }\r\n  \r\n  interface Match {\r\n    x: number;\r\n    y: number;\r\n    dir: number;\r\n  }\r\n  \r\n  interface Bounds {\r\n    minX: number;\r\n    maxX: number;\r\n    minY: number;\r\n    maxY: number;\r\n    update: (x: number, y: number) => void;\r\n  }\r\n  \r\n  interface CrosswordResult {\r\n    board: (string | null)[][];\r\n    wordsActive: Word[];\r\n    success: boolean;\r\n    message?: string;\r\n  }\r\n  \r\n  export function generateCrossword(wordList: string[], board: (string | null)[][]): CrosswordResult {\r\n    // Ki·ªÉm tra ƒë·∫ßu v√†o\r\n    if (!Array.isArray(wordList) || wordList.length !== 6 || !wordList.every(w => typeof w === 'string')) {\r\n      return { board: [], wordsActive: [], success: false, message: 'wordList must be an array of 6 strings' };\r\n    }\r\n    if (!Array.isArray(board) || board.length === 0 || board[0].length !== 20) {\r\n      board = Array.from({ length: 20 }, () => Array(20).fill(null)) as (string | null)[][];\r\n    }\r\n  \r\n    // Kh·ªüi t·∫°o c·∫•u tr√∫c d·ªØ li·ªáu\r\n    const wordsActive: Word[] = [];\r\n    const wordBank: Word[] = wordList.map((word, idx) => ({\r\n      string: word.toUpperCase(),\r\n      char: word.toUpperCase().split(''),\r\n      index: idx,\r\n      successfulMatches: [],\r\n      totalMatches: 0,\r\n      effectiveMatches: 0\r\n    }));\r\n    const bounds: Bounds = {\r\n      minX: 0,\r\n      maxX: 0,\r\n      minY: 0,\r\n      maxY: 0,\r\n      update: function(x: number, y: number) {\r\n        this.minX = Math.min(this.minX, x);\r\n        this.maxX = Math.max(this.maxX, x);\r\n        this.minY = Math.min(this.minY, y);\r\n        this.maxY = Math.max(this.maxY, y);\r\n      }\r\n    };\r\n  \r\n    // H√†m ki·ªÉm tra xem √¥ c√≥ h·ª£p l·ªá ƒë·ªÉ ƒë·∫∑t k√Ω t·ª± kh√¥ng\r\n    function isValidPosition(x: number, y: number, char: string, board: (string | null)[][], dir: number, word: Word, i: number): boolean {\r\n      if (x < 0 || x >= board.length || y < 0 || y >= board[0].length) return false;\r\n      if (board[x][y] === null) return true;\r\n      if (board[x][y] === char) {\r\n        // Ki·ªÉm tra xung ƒë·ªôt v·ªõi t·ª´ kh√°c t·∫°i giao ƒëi·ªÉm\r\n        const crossDir = dir === 0 ? 1 : 0;\r\n        const crossVal = [\r\n          crossDir === 0 ? (x > 0 ? board[x-1][y] : null) : (y > 0 ? board[x][y-1] : null),\r\n          board[x][y],\r\n          crossDir === 0 ? (x < board.length-1 ? board[x+1][y] : null) : (y < board[0].length-1 ? board[x][y+1] : null)\r\n        ];\r\n        return crossVal[0] === null && crossVal[2] === null && board[x][y] === char;\r\n      }\r\n      return false;\r\n    }\r\n  \r\n    // H√†m m·ªü r·ªông b·∫£ng n·∫øu c·∫ßn\r\n    function expandBoard(board: (string | null)[][], x: number, y: number): void {\r\n      while (x >= board.length) {\r\n        board.push(Array(board[0].length).fill(null));\r\n      }\r\n      while (y >= board[0].length) {\r\n        for (let i = 0; i < board.length; i++) {\r\n          board[i].push(null);\r\n        }\r\n      }\r\n    }\r\n  \r\n    // H√†m t√¨m c√°c v·ªã tr√≠ giao nhau h·ª£p l·ªá cho m·ªôt t·ª´\r\n    function findMatches(word: Word, board: (string | null)[][], wordsActive: Word[]): void {\r\n      word.successfulMatches = [];\r\n      word.totalMatches = 0;\r\n      word.effectiveMatches = 0;\r\n  \r\n      if (wordsActive.length === 0) {\r\n        // N·∫øu b·∫£ng r·ªóng, ƒë·∫∑t t·ª´ ƒë·∫ßu ti√™n ·ªü gi·ªØa\r\n        const x = Math.floor(board.length / 2);\r\n        const y = Math.floor(board[0].length / 2);\r\n        const dir = Math.random() < 0.5 ? 0 : 1;\r\n        word.successfulMatches.push({ x, y, dir });\r\n        word.totalMatches = 1;\r\n        word.effectiveMatches = 1;\r\n        return;\r\n      }\r\n  \r\n      for (const placedWord of wordsActive) {\r\n        for (let i = 0; i < word.char.length; i++) {\r\n          for (let k = 0; k < placedWord.char.length; k++) {\r\n            if (word.char[i] === placedWord.char[k]) {\r\n              word.totalMatches++;\r\n              // Th·ª≠ ƒë·∫∑t t·ª´ theo h∆∞·ªõng ngang (dir=0) v√† d·ªçc (dir=1)\r\n              for (let dir = 0; dir <= 1; dir++) {\r\n                const x = dir === 0 ? placedWord.x! + k - i : placedWord.x! + k;\r\n                const y = dir === 0 ? placedWord.y! : placedWord.y! - i;\r\n                let isValid = true;\r\n                // Ki·ªÉm tra to√†n b·ªô t·ª´ c√≥ th·ªÉ ƒë·∫∑t ƒë∆∞·ª£c kh√¥ng\r\n                for (let m = 0; m < word.char.length; m++) {\r\n                  const xPos = dir === 0 ? x + m : x;\r\n                  const yPos = dir === 0 ? y : y + m;\r\n                  expandBoard(board, xPos, yPos);\r\n                  if (!isValidPosition(xPos, yPos, word.char[m], board, dir, word, m)) {\r\n                    isValid = false;\r\n                    break;\r\n                  }\r\n                }\r\n                if (isValid) {\r\n                  word.successfulMatches.push({ x, y, dir });\r\n                  word.effectiveMatches++;\r\n                }\r\n              }\r\n            }\r\n          }\r\n        }\r\n      }\r\n    }\r\n  \r\n    // H√†m ƒë·∫∑t t·ª´ l√™n b·∫£ng\r\n    function placeWord(word: Word, board: (string | null)[][], wordsActive: Word[]): boolean {\r\n      if (word.successfulMatches.length === 0) return false;\r\n  \r\n      // Ch·ªçn ng·∫´u nhi√™n m·ªôt v·ªã tr√≠ giao nhau h·ª£p l·ªá\r\n      const matchIndex = Math.floor(Math.random() * word.successfulMatches.length);\r\n      const matchData = word.successfulMatches[matchIndex];\r\n  \r\n      // C·∫≠p nh·∫≠t th√¥ng tin t·ª´\r\n      word.x = matchData.x;\r\n      word.y = matchData.y;\r\n      word.dir = matchData.dir;\r\n  \r\n      // ƒê·∫∑t t·ª´ng k√Ω t·ª± l√™n b·∫£ng\r\n      for (let i = 0; i < word.char.length; i++) {\r\n        const xIndex = matchData.dir === 0 ? matchData.x + i : matchData.x;\r\n        const yIndex = matchData.dir === 0 ? matchData.y : matchData.y + i;\r\n        expandBoard(board, xIndex, yIndex);\r\n        board[xIndex][yIndex] = word.char[i];\r\n        bounds.update(xIndex, yIndex);\r\n      }\r\n  \r\n      wordsActive.push(word);\r\n      return true;\r\n    }\r\n  \r\n    // H√†m ch√≠nh ƒë·ªÉ ƒë·∫∑t t·∫•t c·∫£ t·ª´\r\n    while (wordBank.length > 0) {\r\n      let minMatchDiff = Infinity;\r\n      let curIndex = -1;\r\n  \r\n      // T√¨m t·ª´ t·ªët nh·∫•t ƒë·ªÉ ƒë·∫∑t\r\n      for (let i = 0; i < wordBank.length; i++) {\r\n        const curWord = wordBank[i];\r\n        findMatches(curWord, board, wordsActive);\r\n        const curMatchDiff = curWord.totalMatches - curWord.effectiveMatches;\r\n        if (curMatchDiff < minMatchDiff && curWord.successfulMatches.length > 0) {\r\n          minMatchDiff = curMatchDiff;\r\n          curIndex = i;\r\n        }\r\n      }\r\n  \r\n      if (curIndex === -1) {\r\n        return { board, wordsActive, success: false, message: 'Failed to place all words' };\r\n      }\r\n  \r\n      // ƒê·∫∑t t·ª´ v√† lo·∫°i kh·ªèi wordBank\r\n      const wordToPlace = wordBank.splice(curIndex, 1)[0];\r\n      if (!placeWord(wordToPlace, board, wordsActive)) {\r\n        return { board, wordsActive, success: false, message: 'Failed to place word' };\r\n      }\r\n    }\r\n  \r\n    // C·∫Øt b·∫£ng theo bounds ƒë·ªÉ tr·∫£ v·ªÅ k√≠ch th∆∞·ªõc t·ªëi thi·ªÉu\r\n    const trimmedBoard: (string | null)[][] = [];\r\n    for (let x = bounds.minX; x <= bounds.maxX; x++) {\r\n      const row = board[x].slice(bounds.minY, bounds.maxY + 1);\r\n      trimmedBoard.push(row);\r\n    }\r\n  \r\n    return { board: trimmedBoard, wordsActive, success: true };\r\n  }\r\n  \r\n//   // V√≠ d·ª• s·ª≠ d·ª•ng\r\n//   const wordList: string[] = ['CROSSWORD', 'PUZZLE', 'GRID', 'WORD', 'CLUE', 'GAME'];\r\n//   const board: (string | null)[][] = Array.from({ length: 20 }, () => Array(20).fill(null));\r\n//   const result: CrosswordResult = generateCrossword(wordList, board);\r\n//   console.log('Success:', result.success);\r\n//   console.log('Words Active:', result.wordsActive);\r\n//   console.log('Board:');\r\n//   result.board.forEach(row => console.log(row.map(c => c || '.').join(' ')));\r\n\r\n\r\n// function AddWordToBoard(){\r\n    \r\n//     var i, len, curIndex, curWord, curChar, curMatch, testWord, testChar,\r\n//         minMatchDiff = 9999, curMatchDiff;\r\n\r\n//     if(wordsActive.length < 1){\r\n//       curIndex = 0;\r\n//       for(i = 0, len = wordBank.length; i < len; i++){\r\n//         if (wordBank[i].totalMatches < wordBank[curIndex].totalMatches){\r\n//           curIndex = i;\r\n//         }\r\n//       }\r\n//       wordBank[curIndex].successfulMatches = [{x:12,y:12,dir:0}];\r\n//     }\r\n//     else{\r\n//       curIndex = -1;\r\n\r\n//       for(i = 0, len = wordBank.length; i < len; i++){\r\n//         curWord = wordBank[i];\r\n//         curWord.effectiveMatches = 0;\r\n//         curWord.successfulMatches = [];\r\n//         for(var j = 0, lenJ = curWord.char.length; j < lenJ; j++){\r\n//           if(j == 1) continue; // skip pos\r\n//           curChar = curWord.char[j];\r\n//           for (var k = 0, lenK = wordsActive.length; k < lenK; k++){\r\n//             testWord = wordsActive[k];\r\n//             for (var l = 0, lenL = testWord.char.length; l < lenL; l++){\r\n//               if(l == 1) continue; // skip pos\r\n//               testChar = testWord.char[l];\r\n//               if (curChar === testChar){\r\n//                 curWord.effectiveMatches++;\r\n\r\n//                 var curCross = {x:testWord.x,y:testWord.y,dir:0};\r\n//                 if(testWord.dir === 0){\r\n//                   curCross.dir = 1;\r\n//                   curCross.x += l;\r\n//                   curCross.y -= j;\r\n//                 }\r\n//                 else{\r\n//                   curCross.dir = 0;\r\n//                   curCross.y += l;\r\n//                   curCross.x -= j;\r\n//                 }\r\n\r\n//                 var isMatch = true;\r\n\r\n//                 for(var m = -1, lenM = curWord.char.length + 1; m < lenM; m++){\r\n//                   var crossVal = [];\r\n//                   if (m !== j){\r\n//                     if (curCross.dir === 0){\r\n//                       var xIndex = curCross.x + m;\r\n\r\n//                       if (xIndex < 0 || xIndex > board.length){\r\n//                         isMatch = false;\r\n//                         break;\r\n//                       }\r\n\r\n//                       crossVal.push(board[xIndex][curCross.y]);\r\n//                       crossVal.push(board[xIndex][curCross.y + 1]);\r\n//                       crossVal.push(board[xIndex][curCross.y - 1]);\r\n//                     }\r\n//                     else{\r\n//                       var yIndex = curCross.y + m;\r\n\r\n//                       if (yIndex < 0 || yIndex > board[curCross.x].length){\r\n//                         isMatch = false;\r\n//                         break;\r\n//                       }\r\n\r\n//                       crossVal.push(board[curCross.x][yIndex]);\r\n//                       crossVal.push(board[curCross.x + 1][yIndex]);\r\n//                       crossVal.push(board[curCross.x - 1][yIndex]);\r\n//                     }\r\n\r\n//                     if(m > -1 && m < lenM-1){\r\n//                       if (crossVal[0] !== curWord.char[m]){\r\n//                         if (crossVal[0] !== null){\r\n//                           isMatch = false;\r\n//                           break;\r\n//                         }\r\n//                         else if (crossVal[1] !== null){\r\n//                           isMatch = false;\r\n//                           break;\r\n//                         }\r\n//                         else if (crossVal[2] !== null){\r\n//                           isMatch = false;\r\n//                           break;\r\n//                         }\r\n//                       }\r\n//                     }\r\n//                     else if (crossVal[0] !== null){\r\n//                       isMatch = false;\r\n//                       break;\r\n//                     }\r\n//                   }\r\n//                 }\r\n\r\n//                 if (isMatch === true){\r\n//                   curWord.successfulMatches.push(curCross);\r\n//                 }\r\n//               }\r\n//             }\r\n//           }\r\n//         }\r\n\r\n//         curMatchDiff = curWord.totalMatches - curWord.effectiveMatches;\r\n\r\n//         if (curMatchDiff<minMatchDiff && curWord.successfulMatches.length>0){\r\n//           curMatchDiff = minMatchDiff;\r\n//           curIndex = i;\r\n//         }\r\n//         else if (curMatchDiff <= 0){\r\n//           return false;\r\n//         }\r\n//       }\r\n//     }\r\n\r\n//     if (curIndex === -1){\r\n//       return false;\r\n//     }\r\n\r\n//     var spliced = wordBank.splice(curIndex, 1);\r\n//     wordsActive.push(spliced[0]);\r\n\r\n//     var pushIndex = wordsActive.length - 1,\r\n//         rand = Math.random(),\r\n//         matchArr = wordsActive[pushIndex].successfulMatches,\r\n//         matchIndex = Math.floor(rand * matchArr.length),\r\n//         matchData = matchArr[matchIndex];\r\n\r\n//     wordsActive[pushIndex].x = matchData.x;\r\n//     wordsActive[pushIndex].y = matchData.y;\r\n//     wordsActive[pushIndex].dir = matchData.dir;\r\n\r\n//     let actualIndex = findWordIdx(wordsActive[pushIndex].string);\r\n//     console.log(wordsActive[pushIndex].string, \" ~~~ \", actualIndex);\r\n//     for(i = 0, len = wordsActive[pushIndex].char.length; i < len; i++){\r\n//       var xIndex = matchData.x,\r\n//           yIndex = matchData.y;\r\n\r\n//       if (matchData.dir === 0){\r\n//         xIndex += i;\r\n//       }\r\n//       else{\r\n//         yIndex += i;\r\n//       }\r\n//       board[xIndex][yIndex] = wordsActive[pushIndex].char[i];\r\n//       isPos[xIndex][yIndex] = (i == 1);\r\n//       classesOfBoard[xIndex][yIndex].push(actualIndex);\r\n//       console.log(xIndex, yIndex, classesOfBoard[xIndex][yIndex]);\r\n\r\n//       Bounds.Update(xIndex,yIndex);\r\n//     }\r\n\r\n//     return true;\r\n//   }\r\n\r\ninterface HintWord {\r\n    word: string;\r\n    x: number;\r\n    y: number;\r\n    direction: \"horizontal\" | \"vertical\";\r\n  }\r\n  \r\n  interface Intersection {\r\n    char: string;\r\n    hPos: number;\r\n    vPos: number;\r\n  }\r\n  \r\n  interface PlaceWordsResult {\r\n    grid: (string | null)[][];\r\n    hintWords: HintWord[];\r\n  }\r\n  \r\n  const placeWordsOnGrid = (\r\n    words: string[],\r\n    gridSize: { width?: number; height?: number } = { width: 20, height: 20 }\r\n  ): PlaceWordsResult => {\r\n    const WIDTH = gridSize.width ?? 20;\r\n    const HEIGHT = gridSize.height ?? 100;\r\n  \r\n    // Initialize grid\r\n    const grid: (string | null)[][] = Array(HEIGHT)\r\n      .fill(null)\r\n      .map(() => Array(WIDTH).fill(null));\r\n    const hintWords: HintWord[] = [];\r\n  \r\n    // Validation\r\n    if (words.length !== 6) {\r\n      throw new Error(\"Exactly 6 words are required\");\r\n    }\r\n  \r\n    // Helper: Check if a word can be placed\r\n    const canPlaceWord = (\r\n      word: string,\r\n      row: number,\r\n      col: number,\r\n      isVertical: boolean\r\n    ): boolean => {\r\n      if (isVertical) {\r\n        if (row + word.length > HEIGHT) return false;\r\n        for (let i = 0; i < word.length; i++) {\r\n          const cell = grid[row + i][col];\r\n          if (cell !== null && cell !== word[i]) return false;\r\n          // Check adjacent cells to prevent unwanted adjacency\r\n          if (i === 0 && row > 0 && grid[row - 1][col] !== null) return false;\r\n          if (\r\n            i === word.length - 1 &&\r\n            row + i + 1 < HEIGHT &&\r\n            grid[row + i + 1][col] !== null\r\n          )\r\n            return false;\r\n          if (col > 0 && grid[row + i][col - 1] !== null) return false;\r\n          if (col < WIDTH - 1 && grid[row + i][col + 1] !== null) return false;\r\n        }\r\n      } else {\r\n        if (col + word.length > WIDTH) return false;\r\n        for (let i = 0; i < word.length; i++) {\r\n          const cell = grid[row][col + i];\r\n          if (cell !== null && cell !== word[i]) return false;\r\n          // Check adjacent cells\r\n          if (i === 0 && col > 0 && grid[row][col - 1] !== null) return false;\r\n          if (\r\n            i === word.length - 1 &&\r\n            col + i + 1 < WIDTH &&\r\n            grid[row][col + i + 1] !== null\r\n          )\r\n            return false;\r\n          if (row > 0 && grid[row - 1][col + i] !== null) return false;\r\n          if (row < HEIGHT - 1 && grid[row + 1][col + i] !== null) return false;\r\n        }\r\n      }\r\n      return true;\r\n    };\r\n  \r\n    // Helper: Place a word on the grid\r\n    const placeWord = (\r\n      word: string,\r\n      row: number,\r\n      col: number,\r\n      isVertical: boolean\r\n    ): void => {\r\n      for (let i = 0; i < word.length; i++) {\r\n        if (isVertical) {\r\n          grid[row + i][col] = word[i];\r\n        } else {\r\n          grid[row][col + i] = word[i];\r\n        }\r\n      }\r\n      hintWords.push({\r\n        word,\r\n        x: col,\r\n        y: row,\r\n        direction: isVertical ? \"vertical\" : \"horizontal\",\r\n      });\r\n    };\r\n  \r\n    // Helper: Find intersections between two words\r\n    const findIntersections = (\r\n      word1: string,\r\n      word2: string,\r\n      word1Dir: 0 | 1\r\n    ): Intersection[] => {\r\n      const intersections: Intersection[] = [];\r\n      for (let i = 0; i < word1.length; i++) {\r\n        for (let j = 0; j < word2.length; j++) {\r\n          if (word1[i] === word2[j]) {\r\n            if (word1Dir === 0) {\r\n              intersections.push({ char: word1[i], hPos: i, vPos: j });\r\n            } else {\r\n              intersections.push({ char: word1[i], vPos: i, hPos: j });\r\n            }\r\n          }\r\n        }\r\n      }\r\n      return intersections;\r\n    };\r\n  \r\n    // Shuffle words and split into horizontal and vertical\r\n    const shuffledWords = [...words].sort(() => Math.random() - 0.5);\r\n    const horizontalWords = shuffledWords.slice(0, 3);\r\n    const verticalWords = shuffledWords.slice(3, 6);\r\n    const intersectionPairs = Math.random() < 0.5 ? 1 : 2;\r\n  \r\n    // Place first horizontal word\r\n    const h1Row = Math.floor(Math.random() * 10) + 5;\r\n    const h1Col = Math.floor(Math.random() * (WIDTH - horizontalWords[0].length));\r\n    placeWord(horizontalWords[0], h1Row, h1Col, false);\r\n  \r\n    // Place first vertical word with intersection\r\n    let v1Row = Math.floor(Math.random() * (HEIGHT - verticalWords[0].length));\r\n    let v1Col = Math.floor(Math.random() * WIDTH);\r\n    let v1Placed = false;\r\n    const intersections1 = findIntersections(horizontalWords[0], verticalWords[0], 0);\r\n    if (intersections1.length > 0) {\r\n      const inter = intersections1[Math.floor(Math.random() * intersections1.length)];\r\n      const tryV1Col = h1Col + inter.hPos;\r\n      const tryV1Row = h1Row - inter.vPos;\r\n      if (canPlaceWord(verticalWords[0], tryV1Row, tryV1Col, true)) {\r\n        v1Row = tryV1Row;\r\n        v1Col = tryV1Col;\r\n        v1Placed = true;\r\n      }\r\n    }\r\n    if (canPlaceWord(verticalWords[0], v1Row, v1Col, true)) {\r\n      placeWord(verticalWords[0], v1Row, v1Col, true);\r\n    }\r\n  \r\n    // Place second horizontal word, possibly intersecting with first vertical\r\n    let h2Row = Math.floor(Math.random() * 10) + 15;\r\n    let h2Col = Math.floor(Math.random() * (WIDTH - horizontalWords[1].length));\r\n    let h2Placed = false;\r\n    if (intersectionPairs === 2 && v1Placed) {\r\n      const intersections2 = findIntersections(verticalWords[0], horizontalWords[1], 1);\r\n      if (intersections2.length > 0) {\r\n        const inter = intersections2[Math.floor(Math.random() * intersections2.length)];\r\n        const tryH2Row = v1Row + inter.vPos;\r\n        const tryH2Col = v1Col - inter.hPos;\r\n        if (canPlaceWord(horizontalWords[1], tryH2Row, tryH2Col, false)) {\r\n          h2Row = tryH2Row;\r\n          h2Col = tryH2Col;\r\n          h2Placed = true;\r\n        }\r\n      }\r\n    }\r\n    if (canPlaceWord(horizontalWords[1], h2Row, h2Col, false)) {\r\n      placeWord(horizontalWords[1], h2Row, h2Col, false);\r\n    }\r\n  \r\n    // Place second vertical word, possibly intersecting with second horizontal\r\n    let v2Row = Math.floor(Math.random() * (HEIGHT - verticalWords[1].length));\r\n    let v2Col = Math.floor(Math.random() * WIDTH);\r\n    let v2Placed = false;\r\n    if (h2Placed && intersectionPairs === 2) {\r\n      const intersections3 = findIntersections(horizontalWords[1], verticalWords[1], 0);\r\n      if (intersections3.length > 0) {\r\n        const inter = intersections3[Math.floor(Math.random() * intersections3.length)];\r\n        const tryV2Col = h2Col + inter.hPos;\r\n        const tryV2Row = h2Row - inter.vPos;\r\n        if (canPlaceWord(verticalWords[1], tryV2Row, tryV2Col, true)) {\r\n          v2Row = tryV2Row;\r\n          v2Col = tryV2Col;\r\n          v2Placed = true;\r\n        }\r\n      }\r\n    }\r\n    if (canPlaceWord(verticalWords[1], v2Row, v2Col, true)) {\r\n      placeWord(verticalWords[1], v2Row, v2Col, true);\r\n    }\r\n  \r\n    // Place third horizontal word\r\n    const h3Row = Math.floor(Math.random() * 10) + 25;\r\n    const h3Col = Math.floor(Math.random() * (WIDTH - horizontalWords[2].length));\r\n    if (canPlaceWord(horizontalWords[2], h3Row, h3Col, false)) {\r\n      placeWord(horizontalWords[2], h3Row, h3Col, false);\r\n    }\r\n  \r\n    // Place third vertical word\r\n    const v3Row = Math.floor(Math.random() * (HEIGHT - verticalWords[2].length));\r\n    const v3Col = Math.floor(Math.random() * WIDTH);\r\n    if (canPlaceWord(verticalWords[2], v3Row, v3Col, true)) {\r\n      placeWord(verticalWords[2], v3Row, v3Col, true);\r\n    }\r\n  \r\n    return { grid, hintWords };\r\n  }\r\n  \r\n  export { placeWordsOnGrid, HintWord, PlaceWordsResult };"],"mappings":"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AACJ,QAAQ,EAAE,CAAC,CAAC,CAAC,CAAC,CAAC;IACnD,IAAI,CAACP,SAAS,CAACU,WAAW,EAAE/C,KAAK,EAAEI,WAAW,CAAC,EAAE;MAC/C,OAAO;QAAEJ,KAAK;QAAEI,WAAW;QAAEC,OAAO,EAAE,KAAK;QAAEC,OAAO,EAAE;MAAuB,CAAC;IAChF;EACF;;EAEA;EACA,MAAM2C,YAAiC,GAAG,EAAE;EAC5C,KAAK,IAAIjJ,CAAC,GAAGiH,MAAM,CAACC,IAAI,EAAElH,CAAC,IAAIiH,MAAM,CAACE,IAAI,EAAEnH,CAAC,EAAE,EAAE;IAC/C,MAAMkJ,GAAG,GAAGlD,KAAK,CAAChG,CAAC,CAAC,CAACmJ,KAAK,CAAClC,MAAM,CAACG,IAAI,EAAEH,MAAM,CAACI,IAAI,GAAG,CAAC,CAAC;IACxD4B,YAAY,CAACpJ,IAAI,CAACqJ,GAAG,CAAC;EACxB;EAEA,OAAO;IAAElD,KAAK,EAAEiD,YAAY;IAAE7C,WAAW;IAAEC,OAAO,EAAE;EAAK,CAAC;AAC5D;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAGA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}