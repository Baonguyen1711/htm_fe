{"ast":null,"code":"export const generateGrid = async (hintWordArray, cellWidth) => {\n  const wordArr = hintWordArray;\n  let board = [[]],\n    wordBank = [],\n    wordsActive = [];\n  let isPos = [[]];\n  let classesOfBoard = [[[]]];\n  class WordObj {\n    constructor(str) {\n      this.string = void 0;\n      this.char = void 0;\n      this.totalMatches = 0;\n      this.effectiveMatches = 0;\n      this.successfulMatches = [];\n      this.x = 0;\n      this.y = 0;\n      this.dir = 0;\n      this.string = str;\n      this.char = str.split('');\n    }\n  }\n  const Bounds = {\n    top: 0,\n    right: 0,\n    bottom: 0,\n    left: 0,\n    Update: function (x, y) {\n      if (x < 0 || x >= 100 || y < 0 || y >= 100) {\n        console.error(\"Invalid coordinates:\", x, y);\n        return;\n      }\n      this.top = Math.min(y, this.top);\n      this.right = Math.max(x, this.right);\n      this.bottom = Math.max(y, this.bottom);\n      this.left = Math.min(x, this.left);\n    },\n    Clean: function () {\n      this.top = 999;\n      this.right = 0;\n      this.bottom = 0;\n      this.left = 999;\n    }\n  };\n  Bounds.Clean();\n  for (let i = 0; i < 100; i++) {\n    board[i] = [];\n    isPos[i] = [];\n    classesOfBoard[i] = [];\n    for (let j = 0; j < 100; j++) {\n      board[i][j] = \"\";\n      isPos[i][j] = false;\n      classesOfBoard[i][j] = [];\n    }\n  }\n  console.log(\"Board initialized:\", board[12][12] === \"\", typeof board[12][12]);\n  function PrepareBoard() {\n    wordBank = [];\n    for (let i = 0; i < wordArr.length; i++) {\n      const actualPos = i + 1;\n      wordBank.push(new WordObj(' ' + actualPos.toString() + wordArr[i] + ' '));\n    }\n    for (let i = 0; i < wordBank.length; i++) {\n      const wA = wordBank[i];\n      for (let j = 0; j < wA.char.length; j++) {\n        const cA = wA.char[j].normalize('NFD').toLowerCase().replace(/[\\u0300-\\u036f]/g, '');\n        for (let k = 0; k < wordBank.length; k++) {\n          if (i !== k) {\n            const wB = wordBank[k];\n            for (let l = 0; l < wB.char.length; l++) {\n              const cB = wB.char[l].normalize('NFD').toLowerCase().replace(/[\\u0300-\\u036f]/g, '');\n              if (cA === cB) {\n                wA.totalMatches++;\n                console.log(`Match: ${wA.char[j]} in ${wA.string} with ${wB.char[l]} in ${wB.string}`);\n              }\n            }\n          }\n        }\n      }\n      console.log(`Word ${wA.string}: totalMatches = ${wA.totalMatches}`);\n    }\n  }\n  function findWordIdx(givenWord) {\n    givenWord = givenWord.substring(2, givenWord.length - 1);\n    for (let i = 0; i < wordArr.length; i++) {\n      if (givenWord === wordArr[i]) return i + 1;\n    }\n    return undefined;\n  }\n  function AddWordToBoard() {\n    let i,\n      len,\n      curIndex,\n      curWord,\n      curChar,\n      testWord,\n      testChar,\n      minMatchDiff = 9999,\n      curMatchDiff;\n    if (wordsActive.length < 1) {\n      curIndex = 0;\n      for (i = 0, len = wordBank.length; i < len; i++) {\n        if (wordBank[i].totalMatches < wordBank[curIndex].totalMatches) {\n          curIndex = i;\n        }\n      }\n      wordBank[curIndex].successfulMatches = [{\n        x: 12,\n        y: 12,\n        dir: 0\n      }];\n    } else {\n      curIndex = -1;\n      for (i = 0, len = wordBank.length; i < len; i++) {\n        curWord = wordBank[i];\n        curWord.effectiveMatches = 0;\n        curWord.successfulMatches = [];\n        for (let j = 0, lenJ = curWord.char.length; j < lenJ; j++) {\n          if (j === 1) continue;\n          curChar = curWord.char[j].normalize('NFD').toLowerCase().replace(/[\\u0300-\\u036f]/g, '');\n          for (let k = 0, lenK = wordsActive.length; k < lenK; k++) {\n            testWord = wordsActive[k];\n            for (let l = 0, lenL = testWord.char.length; l < lenL; l++) {\n              if (l === 1) continue;\n              testChar = testWord.char[l].normalize('NFD').toLowerCase().replace(/[\\u0300-\\u036f]/g, '');\n              if (curChar === testChar) {\n                console.log(`Letter match: ${curWord.char[j]} in ${curWord.string} at pos ${j} with ${testWord.char[l]} in ${testWord.string} at pos ${l}`);\n                curWord.effectiveMatches++;\n                const curCross = {\n                  x: testWord.x,\n                  y: testWord.y,\n                  dir: 0\n                };\n                if (testWord.dir === 0) {\n                  curCross.dir = 1;\n                  curCross.x += l;\n                  curCross.y -= j;\n                } else {\n                  curCross.dir = 0;\n                  curCross.y += l;\n                  curCross.x -= j;\n                }\n                console.log(`Testing intersection at x:${curCross.x}, y:${curCross.y}, dir:${curCross.dir}`);\n                let isMatch = true;\n                for (let m = -1, lenM = curWord.char.length + 1; m < lenM; m++) {\n                  if (m !== j) {\n                    const crossVal = [];\n                    if (curCross.dir === 0) {\n                      const xIndex = curCross.x + m;\n                      if (xIndex < 0 || xIndex >= board.length) {\n                        console.log(`Out of bounds: x=${xIndex}`);\n                        isMatch = false;\n                        break;\n                      }\n                      crossVal.push(board[xIndex][curCross.y]);\n                    } else {\n                      const yIndex = curCross.y + m;\n                      if (yIndex < 0 || yIndex >= board[curCross.x].length) {\n                        console.log(`Out of bounds: y=${yIndex}`);\n                        isMatch = false;\n                        break;\n                      }\n                      crossVal.push(board[curCross.x][yIndex]);\n                    }\n                    console.log(`Checking pos m=${m}: crossVal=${JSON.stringify(crossVal)}`);\n                    if (m > -1 && m < lenM - 1) {\n                      const expectedChar = curWord.char[m].normalize('NFD').toLowerCase().replace(/[\\u0300-\\u036f]/g, '');\n                      if (crossVal[0] !== expectedChar && crossVal[0] !== \"\") {\n                        console.log(`Conflict: board[${curCross.x}][${curCross.y + m}]='${crossVal[0]}' != '${curWord.char[m]}'`);\n                        isMatch = false;\n                        break;\n                      }\n                    } else if (crossVal[0] !== \"\") {\n                      console.log(`End conflict: board[${curCross.x}][${curCross.y + m}]='${crossVal[0]}'`);\n                      isMatch = false;\n                      break;\n                    }\n                  }\n                }\n                if (isMatch) {\n                  console.log(\"Valid intersection for\", curWord.string, \"at\", curCross);\n                  curWord.successfulMatches.push(curCross);\n                }\n              }\n            }\n          }\n        }\n        curMatchDiff = curWord.totalMatches - curWord.effectiveMatches;\n        if (curMatchDiff < minMatchDiff && curWord.successfulMatches.length > 0) {\n          minMatchDiff = curMatchDiff;\n          curIndex = i;\n        }\n      }\n      if (curIndex === -1) {\n        var _wordBank$i;\n        console.log(\"No valid intersections for:\", ((_wordBank$i = wordBank[i]) === null || _wordBank$i === void 0 ? void 0 : _wordBank$i.string) || \"unknown\", \"placing randomly\");\n        if (i < wordBank.length) {\n          wordBank[i].successfulMatches = [{\n            x: Math.floor(Math.random() * 50) + 10,\n            y: Math.floor(Math.random() * 50) + 10,\n            dir: Math.random() > 0.5 ? 0 : 1\n          }];\n          curIndex = i;\n        } else {\n          return false;\n        }\n      }\n    }\n    const spliced = wordBank.splice(curIndex, 1);\n    wordsActive.push(spliced[0]);\n    const pushIndex = wordsActive.length - 1;\n    const rand = Math.random();\n    const matchArr = wordsActive[pushIndex].successfulMatches;\n    const matchIndex = Math.floor(rand * matchArr.length);\n    const matchData = matchArr[matchIndex];\n    wordsActive[pushIndex].x = matchData.x;\n    wordsActive[pushIndex].y = matchData.y;\n    wordsActive[pushIndex].dir = matchData.dir;\n    const actualIndex = findWordIdx(wordsActive[pushIndex].string);\n    console.log(\"Placing\", wordsActive[pushIndex].string, \"at x:\", matchData.x, \"y:\", matchData.y, \"dir:\", matchData.dir === 0 ? \"horizontal\" : \"vertical\");\n    for (i = 0, len = wordsActive[pushIndex].char.length; i < len; i++) {\n      let xIndex = matchData.x,\n        yIndex = matchData.y;\n      if (matchData.dir === 0) {\n        xIndex += i;\n      } else {\n        yIndex += i;\n      }\n      board[xIndex][yIndex] = wordsActive[pushIndex].char[i];\n      isPos[xIndex][yIndex] = i === 1;\n      if (actualIndex !== undefined) {\n        classesOfBoard[xIndex][yIndex].push(actualIndex);\n      }\n      console.log(\"Placed char at x:\", xIndex, \"y:\", yIndex, \"char:\", board[xIndex][yIndex], \"classes:\", classesOfBoard[xIndex][yIndex]);\n      Bounds.Update(xIndex, yIndex);\n    }\n    console.log(\"Board after placing\", wordsActive[pushIndex].string);\n    for (let i = Math.max(0, Bounds.top - 2); i <= Bounds.bottom + 2; i++) {\n      console.log(`Row ${i}:`, board[i].slice(Bounds.left - 2, Bounds.right + 3).join(\"\"));\n    }\n    return true;\n  }\n  function PopulateBoard() {\n    PrepareBoard();\n    let placedWords = 0;\n    for (let i = 0; i < wordBank.length; i++) {\n      if (AddWordToBoard()) {\n        placedWords++;\n      } else {\n        var _wordBank$;\n        console.log(\"Failed to place\", ((_wordBank$ = wordBank[0]) === null || _wordBank$ === void 0 ? void 0 : _wordBank$.string) || \"unknown\", \"removing\");\n        wordBank.splice(0, 1);\n        i--;\n      }\n    }\n    console.log(`Placed ${placedWords} words`);\n    return placedWords > 0;\n  }\n  const isSuccess = PopulateBoard();\n  console.log(\"PopulateBoard success:\", isSuccess);\n  const top = Bounds.top;\n  const bottom = Bounds.bottom;\n  const left = Bounds.left;\n  const right = Bounds.right;\n  console.log(\"Final Bounds:\", {\n    top,\n    bottom,\n    left,\n    right\n  });\n  for (let i = Math.max(0, Bounds.top - 2); i <= Bounds.bottom + 2; i++) {\n    console.log(`Row ${i}:`, board[i].slice(Bounds.left - 2, Bounds.right + 3).join(\"\"));\n  }\n  const wordHeight = bottom - top + 1;\n  const wordWidth = right - left + 1;\n  let startRow = top;\n  let startCol = left;\n  if (wordHeight < cellWidth) {\n    const padding = Math.floor((cellWidth - wordHeight) / 2);\n    startRow = Math.max(0, top - padding);\n  }\n  if (wordWidth < cellWidth) {\n    const padding = Math.floor((cellWidth - wordWidth) / 2);\n    startCol = Math.max(0, left - padding);\n  }\n  startRow = Math.min(startRow, 100 - cellWidth);\n  startCol = Math.min(startCol, 100 - cellWidth);\n  const slicedBoard = board.slice(startRow, startRow + cellWidth).map(row => row.slice(startCol, startCol + cellWidth));\n  console.log(\"Sliced Board:\", slicedBoard.map(row => row.join(\"\")));\n  return {\n    board: slicedBoard,\n    bounds: {\n      top,\n      bottom,\n      left,\n      right\n    },\n    wordsActive\n  };\n};","map":{"version":3,"names":["generateGrid","hintWordArray","cellWidth","wordArr","board","wordBank","wordsActive","isPos","classesOfBoard","WordObj","constructor","str","string","char","totalMatches","effectiveMatches","successfulMatches","x","y","dir","split","Bounds","top","right","bottom","left","Update","console","error","Math","min","max","Clean","i","j","log","PrepareBoard","length","actualPos","push","toString","wA","cA","normalize","toLowerCase","replace","k","wB","l","cB","findWordIdx","givenWord","substring","undefined","AddWordToBoard","len","curIndex","curWord","curChar","testWord","testChar","minMatchDiff","curMatchDiff","lenJ","lenK","lenL","curCross","isMatch","m","lenM","crossVal","xIndex","yIndex","JSON","stringify","expectedChar","_wordBank$i","floor","random","spliced","splice","pushIndex","rand","matchArr","matchIndex","matchData","actualIndex","slice","join","PopulateBoard","placedWords","_wordBank$","isSuccess","wordHeight","wordWidth","startRow","startCol","padding","slicedBoard","map","row","bounds"],"sources":["C:/Users/ASUS/Documents/htm_fe/src/pages/User/Round2/utils.ts"],"sourcesContent":["export const generateGrid = async (hintWordArray: string[], cellWidth: number) => {\r\n  const wordArr = hintWordArray;\r\n  let board: string[][] = [[]], wordBank: WordObj[] = [], wordsActive: WordObj[] = [];\r\n\r\n  interface MatchPosition {\r\n    x: number;\r\n    y: number;\r\n    dir: number; // 0 = horizontal, 1 = vertical\r\n  }\r\n\r\n  let isPos: boolean[][] = [[]];\r\n  let classesOfBoard: number[][][] = [[[]]];\r\n\r\n  class WordObj {\r\n    string: string;\r\n    char: string[];\r\n    totalMatches: number = 0;\r\n    effectiveMatches: number = 0;\r\n    successfulMatches: MatchPosition[] = [];\r\n    x: number = 0;\r\n    y: number = 0;\r\n    dir: number = 0;\r\n\r\n    constructor(str: string) {\r\n      this.string = str;\r\n      this.char = str.split('');\r\n    }\r\n  }\r\n\r\n  const Bounds = {\r\n    top: 0,\r\n    right: 0,\r\n    bottom: 0,\r\n    left: 0,\r\n\r\n    Update: function (x: number, y: number) {\r\n      if (x < 0 || x >= 100 || y < 0 || y >= 100) {\r\n        console.error(\"Invalid coordinates:\", x, y);\r\n        return;\r\n      }\r\n      this.top = Math.min(y, this.top);\r\n      this.right = Math.max(x, this.right);\r\n      this.bottom = Math.max(y, this.bottom);\r\n      this.left = Math.min(x, this.left);\r\n    },\r\n\r\n    Clean: function () {\r\n      this.top = 999;\r\n      this.right = 0;\r\n      this.bottom = 0;\r\n      this.left = 999;\r\n    }\r\n  };\r\n\r\n  Bounds.Clean();\r\n  for (let i = 0; i < 100; i++) {\r\n    board[i] = [];\r\n    isPos[i] = [];\r\n    classesOfBoard[i] = [];\r\n    for (let j = 0; j < 100; j++) {\r\n      board[i][j] = \"\";\r\n      isPos[i][j] = false;\r\n      classesOfBoard[i][j] = [];\r\n    }\r\n  }\r\n  console.log(\"Board initialized:\", board[12][12] === \"\", typeof board[12][12]);\r\n\r\n  function PrepareBoard(): void {\r\n    wordBank = [];\r\n    for (let i = 0; i < wordArr.length; i++) {\r\n      const actualPos = i + 1;\r\n      wordBank.push(new WordObj(' ' + actualPos.toString() + wordArr[i] + ' '));\r\n    }\r\n    for (let i = 0; i < wordBank.length; i++) {\r\n      const wA = wordBank[i];\r\n      for (let j = 0; j < wA.char.length; j++) {\r\n        const cA = wA.char[j].normalize('NFD').toLowerCase().replace(/[\\u0300-\\u036f]/g, '');\r\n        for (let k = 0; k < wordBank.length; k++) {\r\n          if (i !== k) {\r\n            const wB = wordBank[k];\r\n            for (let l = 0; l < wB.char.length; l++) {\r\n              const cB = wB.char[l].normalize('NFD').toLowerCase().replace(/[\\u0300-\\u036f]/g, '');\r\n              if (cA === cB) {\r\n                wA.totalMatches++;\r\n                console.log(`Match: ${wA.char[j]} in ${wA.string} with ${wB.char[l]} in ${wB.string}`);\r\n              }\r\n            }\r\n          }\r\n        }\r\n      }\r\n      console.log(`Word ${wA.string}: totalMatches = ${wA.totalMatches}`);\r\n    }\r\n  }\r\n\r\n  function findWordIdx(givenWord: string): number | undefined {\r\n    givenWord = givenWord.substring(2, givenWord.length - 1);\r\n    for (let i = 0; i < wordArr.length; i++) {\r\n      if (givenWord === wordArr[i]) return i + 1;\r\n    }\r\n    return undefined;\r\n  }\r\n\r\n  function AddWordToBoard(): boolean {\r\n    let i: number, len: number, curIndex: number, curWord: WordObj, curChar: string, testWord: WordObj, testChar: string,\r\n      minMatchDiff = 9999, curMatchDiff: number;\r\n\r\n    if (wordsActive.length < 1) {\r\n      curIndex = 0;\r\n      for (i = 0, len = wordBank.length; i < len; i++) {\r\n        if (wordBank[i].totalMatches < wordBank[curIndex].totalMatches) {\r\n          curIndex = i;\r\n        }\r\n      }\r\n      wordBank[curIndex].successfulMatches = [{ x: 12, y: 12, dir: 0 }];\r\n    } else {\r\n      curIndex = -1;\r\n      for (i = 0, len = wordBank.length; i < len; i++) {\r\n        curWord = wordBank[i];\r\n        curWord.effectiveMatches = 0;\r\n        curWord.successfulMatches = [];\r\n        for (let j = 0, lenJ = curWord.char.length; j < lenJ; j++) {\r\n          if (j === 1) continue;\r\n          curChar = curWord.char[j].normalize('NFD').toLowerCase().replace(/[\\u0300-\\u036f]/g, '');\r\n          for (let k = 0, lenK = wordsActive.length; k < lenK; k++) {\r\n            testWord = wordsActive[k];\r\n            for (let l = 0, lenL = testWord.char.length; l < lenL; l++) {\r\n              if (l === 1) continue;\r\n              testChar = testWord.char[l].normalize('NFD').toLowerCase().replace(/[\\u0300-\\u036f]/g, '');\r\n              if (curChar === testChar) {\r\n                console.log(`Letter match: ${curWord.char[j]} in ${curWord.string} at pos ${j} with ${testWord.char[l]} in ${testWord.string} at pos ${l}`);\r\n                curWord.effectiveMatches++;\r\n                const curCross: MatchPosition = { x: testWord.x, y: testWord.y, dir: 0 };\r\n                if (testWord.dir === 0) {\r\n                  curCross.dir = 1;\r\n                  curCross.x += l;\r\n                  curCross.y -= j;\r\n                } else {\r\n                  curCross.dir = 0;\r\n                  curCross.y += l;\r\n                  curCross.x -= j;\r\n                }\r\n                console.log(`Testing intersection at x:${curCross.x}, y:${curCross.y}, dir:${curCross.dir}`);\r\n                let isMatch = true;\r\n                for (let m = -1, lenM = curWord.char.length + 1; m < lenM; m++) {\r\n                  if (m !== j) {\r\n                    const crossVal: string[] = [];\r\n                    if (curCross.dir === 0) {\r\n                      const xIndex = curCross.x + m;\r\n                      if (xIndex < 0 || xIndex >= board.length) {\r\n                        console.log(`Out of bounds: x=${xIndex}`);\r\n                        isMatch = false;\r\n                        break;\r\n                      }\r\n                      crossVal.push(board[xIndex][curCross.y]);\r\n                    } else {\r\n                      const yIndex = curCross.y + m;\r\n                      if (yIndex < 0 || yIndex >= board[curCross.x].length) {\r\n                        console.log(`Out of bounds: y=${yIndex}`);\r\n                        isMatch = false;\r\n                        break;\r\n                      }\r\n                      crossVal.push(board[curCross.x][yIndex]);\r\n                    }\r\n                    console.log(`Checking pos m=${m}: crossVal=${JSON.stringify(crossVal)}`);\r\n                    if (m > -1 && m < lenM - 1) {\r\n                      const expectedChar = curWord.char[m].normalize('NFD').toLowerCase().replace(/[\\u0300-\\u036f]/g, '');\r\n                      if (crossVal[0] !== expectedChar && crossVal[0] !== \"\") {\r\n                        console.log(`Conflict: board[${curCross.x}][${curCross.y + m}]='${crossVal[0]}' != '${curWord.char[m]}'`);\r\n                        isMatch = false;\r\n                        break;\r\n                      }\r\n                    } else if (crossVal[0] !== \"\") {\r\n                      console.log(`End conflict: board[${curCross.x}][${curCross.y + m}]='${crossVal[0]}'`);\r\n                      isMatch = false;\r\n                      break;\r\n                    }\r\n                  }\r\n                }\r\n                if (isMatch) {\r\n                  console.log(\"Valid intersection for\", curWord.string, \"at\", curCross);\r\n                  curWord.successfulMatches.push(curCross);\r\n                }\r\n              }\r\n            }\r\n          }\r\n        }\r\n        curMatchDiff = curWord.totalMatches - curWord.effectiveMatches;\r\n        if (curMatchDiff < minMatchDiff && curWord.successfulMatches.length > 0) {\r\n          minMatchDiff = curMatchDiff;\r\n          curIndex = i;\r\n        }\r\n      }\r\n      if (curIndex === -1) {\r\n        console.log(\"No valid intersections for:\", wordBank[i]?.string || \"unknown\", \"placing randomly\");\r\n        if (i < wordBank.length) {\r\n          wordBank[i].successfulMatches = [{\r\n            x: Math.floor(Math.random() * 50) + 10,\r\n            y: Math.floor(Math.random() * 50) + 10,\r\n            dir: Math.random() > 0.5 ? 0 : 1\r\n          }];\r\n          curIndex = i;\r\n        } else {\r\n          return false;\r\n        }\r\n      }\r\n    }\r\n\r\n    const spliced = wordBank.splice(curIndex, 1);\r\n    wordsActive.push(spliced[0]);\r\n\r\n    const pushIndex = wordsActive.length - 1;\r\n    const rand = Math.random();\r\n    const matchArr = wordsActive[pushIndex].successfulMatches;\r\n    const matchIndex = Math.floor(rand * matchArr.length);\r\n    const matchData = matchArr[matchIndex];\r\n\r\n    wordsActive[pushIndex].x = matchData.x;\r\n    wordsActive[pushIndex].y = matchData.y;\r\n    wordsActive[pushIndex].dir = matchData.dir;\r\n\r\n    const actualIndex = findWordIdx(wordsActive[pushIndex].string);\r\n    console.log(\"Placing\", wordsActive[pushIndex].string, \"at x:\", matchData.x, \"y:\", matchData.y, \"dir:\", matchData.dir === 0 ? \"horizontal\" : \"vertical\");\r\n    for (i = 0, len = wordsActive[pushIndex].char.length; i < len; i++) {\r\n      let xIndex = matchData.x,\r\n        yIndex = matchData.y;\r\n      if (matchData.dir === 0) {\r\n        xIndex += i;\r\n      } else {\r\n        yIndex += i;\r\n      }\r\n      board[xIndex][yIndex] = wordsActive[pushIndex].char[i];\r\n      isPos[xIndex][yIndex] = (i === 1);\r\n      if (actualIndex !== undefined) {\r\n        classesOfBoard[xIndex][yIndex].push(actualIndex);\r\n      }\r\n      console.log(\"Placed char at x:\", xIndex, \"y:\", yIndex, \"char:\", board[xIndex][yIndex], \"classes:\", classesOfBoard[xIndex][yIndex]);\r\n      Bounds.Update(xIndex, yIndex);\r\n    }\r\n    console.log(\"Board after placing\", wordsActive[pushIndex].string);\r\n    for (let i = Math.max(0, Bounds.top - 2); i <= Bounds.bottom + 2; i++) {\r\n      console.log(`Row ${i}:`, board[i].slice(Bounds.left - 2, Bounds.right + 3).join(\"\"));\r\n    }\r\n    return true;\r\n  }\r\n\r\n  function PopulateBoard() {\r\n    PrepareBoard();\r\n    let placedWords = 0;\r\n    for (let i = 0; i < wordBank.length; i++) {\r\n      if (AddWordToBoard()) {\r\n        placedWords++;\r\n      } else {\r\n        console.log(\"Failed to place\", wordBank[0]?.string || \"unknown\", \"removing\");\r\n        wordBank.splice(0, 1);\r\n        i--;\r\n      }\r\n    }\r\n    console.log(`Placed ${placedWords} words`);\r\n    return placedWords > 0;\r\n  }\r\n\r\n  const isSuccess = PopulateBoard();\r\n  console.log(\"PopulateBoard success:\", isSuccess);\r\n\r\n  const top = Bounds.top;\r\n  const bottom = Bounds.bottom;\r\n  const left = Bounds.left;\r\n  const right = Bounds.right;\r\n\r\n  console.log(\"Final Bounds:\", { top, bottom, left, right });\r\n  for (let i = Math.max(0, Bounds.top - 2); i <= Bounds.bottom + 2; i++) {\r\n    console.log(`Row ${i}:`, board[i].slice(Bounds.left - 2, Bounds.right + 3).join(\"\"));\r\n  }\r\n\r\n  const wordHeight = bottom - top + 1;\r\n  const wordWidth = right - left + 1;\r\n\r\n  let startRow = top;\r\n  let startCol = left;\r\n\r\n  if (wordHeight < cellWidth) {\r\n    const padding = Math.floor((cellWidth - wordHeight) / 2);\r\n    startRow = Math.max(0, top - padding);\r\n  }\r\n  if (wordWidth < cellWidth) {\r\n    const padding = Math.floor((cellWidth - wordWidth) / 2);\r\n    startCol = Math.max(0, left - padding);\r\n  }\r\n\r\n  startRow = Math.min(startRow, 100 - cellWidth);\r\n  startCol = Math.min(startCol, 100 - cellWidth);\r\n\r\n  const slicedBoard = board\r\n    .slice(startRow, startRow + cellWidth)\r\n    .map(row => row.slice(startCol, startCol + cellWidth));\r\n\r\n  console.log(\"Sliced Board:\", slicedBoard.map(row => row.join(\"\")));\r\n\r\n  return { board: slicedBoard, bounds: { top, bottom, left, right }, wordsActive };\r\n};"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}