{"ast":null,"code":"var _jsxFileName = \"C:\\\\Users\\\\ASUS\\\\Documents\\\\htm_fe\\\\src\\\\pages\\\\User\\\\Round2\\\\Round2.tsx\",\n  _s = $RefreshSig$();\nimport Play from \"../../../layouts/Play\";\nimport React, { useState, useEffect } from \"react\";\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\n// Từ khóa chướng ngại vật\nconst mainKeyword = \"VIETTEL\";\nconst ObstacleQuestionBox = ({\n  obstacleWord\n}) => {\n  _s();\n  // Increased grid size\n  const GRID_SIZE = 15;\n  const generateEmptyGrid = () => {\n    return Array(GRID_SIZE).fill(null).map(() => Array(GRID_SIZE).fill(\"\"));\n  };\n  const [grid, setGrid] = useState(generateEmptyGrid());\n  const [revealedRows, setRevealedRows] = useState(Array(GRID_SIZE).fill(false));\n  const [revealedCols, setRevealedCols] = useState(Array(GRID_SIZE).fill(false));\n  const [hintWords, setHintWords] = useState([]);\n  useEffect(() => {\n    const wordList = [\"BƯUCHÍNH\", \"5G\", \"BQP\", \"TẬPĐOÀN\", \"HÀNỘI\", \"RED\"];\n    let randomHintWords = [];\n    let newGrid = generateEmptyGrid();\n    let occupiedPositions = new Set();\n    let occupiedRows = new Set();\n    let occupiedCols = new Set();\n    const getKey = (x, y) => `${x},${y}`;\n    const canPlaceNumber = (x, y) => {\n      if (x < 0 || y < 0 || x >= GRID_SIZE || y >= GRID_SIZE) return false;\n      return !occupiedPositions.has(getKey(x, y));\n    };\n    const hasCommonLetter = (word1, word2) => {\n      return [...new Set(word1)].some(letter => word2.includes(letter));\n    };\n\n    // Try to place words and numbers until a valid configuration is found\n    let attempts = 0;\n    const maxAttempts = 100;\n    while (attempts < maxAttempts) {\n      randomHintWords = generateHintWords(wordList, GRID_SIZE, mainKeyword);\n      newGrid = generateEmptyGrid();\n      occupiedPositions.clear();\n      occupiedRows.clear();\n      occupiedCols.clear();\n      let canPlaceAll = true;\n\n      // First pass: Place words and mark their positions\n      for (const {\n        word,\n        x,\n        y,\n        direction\n      } of randomHintWords) {\n        if (direction === \"horizontal\") {\n          occupiedRows.add(y);\n          // Check for adjacent rows\n          for (const other of randomHintWords) {\n            if (other.word === word || other.direction !== \"horizontal\") continue; // Fixed comparison\n            if (Math.abs(other.y - y) === 1 && !hasCommonLetter(word, other.word)) {\n              canPlaceAll = false;\n              break;\n            }\n          }\n        } else {\n          occupiedCols.add(x);\n          // Check for adjacent columns\n          for (const other of randomHintWords) {\n            if (other.word === word || other.direction !== \"vertical\") continue; // Fixed comparison\n            if (Math.abs(other.x - x) === 1 && !hasCommonLetter(word, other.word)) {\n              canPlaceAll = false;\n              break;\n            }\n          }\n        }\n        if (!canPlaceAll) break;\n        for (let i = 0; i < word.length; i++) {\n          let newX = direction === \"horizontal\" ? x + i : x;\n          let newY = direction === \"horizontal\" ? y : y + i;\n          newGrid[newY][newX] = word[i];\n          occupiedPositions.add(getKey(newX, newY));\n        }\n      }\n      if (!canPlaceAll) {\n        attempts++;\n        continue;\n      }\n\n      // Second pass: Check if numbers can be placed without overlap\n\n      for (const {\n        word,\n        x,\n        y,\n        direction\n      } of randomHintWords) {\n        const wordNumber = wordList.includes(word) ? wordList.indexOf(word) + 1 : -1; // Kiểm tra trước khi lấy số\n\n        if (wordNumber === -1) {\n          console.error(`Không tìm thấy từ ${word} trong wordList`);\n          continue; // Nếu không tìm thấy, tiếp tục vòng lặp\n        }\n        if (direction === \"horizontal\" && x > 0) {\n          if (!canPlaceNumber(x - 1, y)) {\n            canPlaceAll = false;\n            break;\n          }\n        } else if (direction === \"vertical\" && y > 0) {\n          if (!canPlaceNumber(x, y - 1)) {\n            canPlaceAll = false;\n            break;\n          }\n        }\n      }\n      if (canPlaceAll) {\n        // Place numbers if all checks pass\n        randomHintWords.forEach(({\n          word,\n          x,\n          y,\n          direction\n        }) => {\n          const wordNumber = wordList.indexOf(word) + 1;\n          if (direction === \"horizontal\" && x > 0) {\n            newGrid[y][x - 1] = wordNumber.toString();\n            occupiedPositions.add(getKey(x - 1, y));\n          } else if (direction === \"vertical\" && y > 0) {\n            newGrid[y - 1][x] = wordNumber.toString();\n            occupiedPositions.add(getKey(x, y - 1));\n          }\n        });\n        break; // Valid configuration found, exit loop\n      }\n      attempts++;\n    }\n    if (attempts >= maxAttempts) {\n      console.warn(\"Could not find a valid grid configuration without overlapping numbers or adjacent non-shared words after max attempts.\");\n    }\n    setHintWords(randomHintWords);\n    setGrid(newGrid);\n  }, []);\n\n  // Hàm toggle hiển thị hàng/cột\n  const toggleRow = rowIndex => {\n    setRevealedRows(prev => {\n      const newRevealed = [...prev];\n      newRevealed[rowIndex] = !newRevealed[rowIndex];\n      return newRevealed;\n    });\n  };\n  const toggleCol = colIndex => {\n    setRevealedCols(prev => {\n      const newRevealed = [...prev];\n      newRevealed[colIndex] = !newRevealed[colIndex];\n      return newRevealed;\n    });\n  };\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    className: \"flex flex-col items-center bg-white rounded-lg shadow-md p-6\",\n    children: /*#__PURE__*/_jsxDEV(\"div\", {\n      className: \"grid grid-cols-[40px_repeat(15,40px)] gap-1\",\n      children: [Array.from({\n        length: GRID_SIZE\n      }).map((_, colIndex) => /*#__PURE__*/_jsxDEV(\"div\", {\n        className: \"w-10 h-10 bg-white\"\n      }, colIndex, false, {\n        fileName: _jsxFileName,\n        lineNumber: 185,\n        columnNumber: 21\n      }, this)), grid.map((row, rowIndex) => /*#__PURE__*/_jsxDEV(React.Fragment, {\n        children: [/*#__PURE__*/_jsxDEV(\"div\", {\n          className: \"w-10 h-10 bg-white\"\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 191,\n          columnNumber: 25\n        }, this), row.map((cell, colIndex) => {\n          const isRevealed = revealedRows[rowIndex] && hintWords.some(word => word.y === rowIndex && word.direction === \"horizontal\") || revealedCols[colIndex] && hintWords.some(word => word.x === colIndex && word.direction === \"vertical\");\n          return /*#__PURE__*/_jsxDEV(\"div\", {\n            className: `w-10 h-10 flex items-center justify-center text-lg font-semibold select-none \n                                    \n                                    ${!isNaN(Number(cell)) ? \"blue-500 font-bold \" : \"\"}\n                                    ${cell === \"\" ? \"bg-white border-none\" : \"border-gray-400 bg-gray-50\"} \n                                    ${isRevealed && isNaN(Number(cell)) ? \"text-black\" : isNaN(Number(cell)) ? \"text-transparent\" : \"text-blue-500\"}\n                                    ${obstacleWord.includes(cell) && isRevealed && isNaN(Number(cell)) ? \"font-bold text-red-500\" : \"\"}\n                                `,\n            onClick: () => {\n              if (hintWords.some(word => word.y === rowIndex && word.direction === \"horizontal\")) {\n                toggleRow(rowIndex);\n              } else if (hintWords.some(word => word.x === colIndex && word.direction === \"vertical\")) {\n                toggleCol(colIndex);\n              }\n            },\n            style: {\n              cursor: hintWords.some(word => word.y === rowIndex || word.x === colIndex) ? \"pointer\" : \"default\"\n            },\n            children: cell\n          }, colIndex, false, {\n            fileName: _jsxFileName,\n            lineNumber: 202,\n            columnNumber: 33\n          }, this);\n        })]\n      }, rowIndex, true, {\n        fileName: _jsxFileName,\n        lineNumber: 190,\n        columnNumber: 21\n      }, this))]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 181,\n      columnNumber: 13\n    }, this)\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 180,\n    columnNumber: 9\n  }, this);\n};\n_s(ObstacleQuestionBox, \"0tXfE1RkmpIdWy/liPKPIQWuBnQ=\");\n_c = ObstacleQuestionBox;\nfunction Round2() {\n  return /*#__PURE__*/_jsxDEV(Play, {\n    questionComponent: /*#__PURE__*/_jsxDEV(ObstacleQuestionBox, {\n      obstacleWord: mainKeyword\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 235,\n      columnNumber: 37\n    }, this)\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 235,\n    columnNumber: 12\n  }, this);\n}\n_c2 = Round2;\nexport default Round2;\nvar _c, _c2;\n$RefreshReg$(_c, \"ObstacleQuestionBox\");\n$RefreshReg$(_c2, \"Round2\");","map":{"version":3,"names":["Play","React","useState","useEffect","jsxDEV","_jsxDEV","mainKeyword","ObstacleQuestionBox","obstacleWord","_s","GRID_SIZE","generateEmptyGrid","Array","fill","map","grid","setGrid","revealedRows","setRevealedRows","revealedCols","setRevealedCols","hintWords","setHintWords","wordList","randomHintWords","newGrid","occupiedPositions","Set","occupiedRows","occupiedCols","getKey","x","y","canPlaceNumber","has","hasCommonLetter","word1","word2","some","letter","includes","attempts","maxAttempts","generateHintWords","clear","canPlaceAll","word","direction","add","other","Math","abs","i","length","newX","newY","wordNumber","indexOf","console","error","forEach","toString","warn","toggleRow","rowIndex","prev","newRevealed","toggleCol","colIndex","className","children","from","_","fileName","_jsxFileName","lineNumber","columnNumber","row","Fragment","cell","isRevealed","isNaN","Number","onClick","style","cursor","_c","Round2","questionComponent","_c2","$RefreshReg$"],"sources":["C:/Users/ASUS/Documents/htm_fe/src/pages/User/Round2/Round2.tsx"],"sourcesContent":["import Play from \"../../../layouts/Play\";\r\nimport React, { useState, useEffect } from \"react\";\r\n\r\ninterface HintWord {\r\n    word: string;\r\n    x: number;\r\n    y: number;\r\n    direction: \"horizontal\" | \"vertical\";\r\n}\r\n\r\ninterface ObstacleQuestionBoxProps {\r\n    obstacleWord: string;\r\n}\r\n\r\ntype PlacedWord = {\r\n    word: string;\r\n    x: number;\r\n    y: number;\r\n    direction: \"horizontal\" | \"vertical\";\r\n};\r\n\r\n// Từ khóa chướng ngại vật\r\nconst mainKeyword = \"VIETTEL\";\r\n\r\n\r\nconst ObstacleQuestionBox: React.FC<ObstacleQuestionBoxProps> = ({ obstacleWord }) => {\r\n\r\n    // Increased grid size\r\n    const GRID_SIZE = 15;\r\n\r\n    const generateEmptyGrid = () => {\r\n        return Array(GRID_SIZE).fill(null).map(() => Array(GRID_SIZE).fill(\"\"));\r\n    };\r\n    const [grid, setGrid] = useState<string[][]>(generateEmptyGrid());\r\n    const [revealedRows, setRevealedRows] = useState<boolean[]>(Array(GRID_SIZE).fill(false));\r\n    const [revealedCols, setRevealedCols] = useState<boolean[]>(Array(GRID_SIZE).fill(false));\r\n    const [hintWords, setHintWords] = useState<HintWord[]>([]);\r\n\r\n\r\n\r\n    useEffect(() => {\r\n        const wordList = [\"BƯUCHÍNH\", \"5G\", \"BQP\", \"TẬPĐOÀN\", \"HÀNỘI\", \"RED\"];\r\n        let randomHintWords: HintWord[] = [];\r\n        let newGrid = generateEmptyGrid();\r\n        let occupiedPositions = new Set<string>();\r\n        let occupiedRows = new Set<number>();\r\n        let occupiedCols = new Set<number>();\r\n\r\n        const getKey = (x: number, y: number) => `${x},${y}`;\r\n\r\n        const canPlaceNumber = (x: number, y: number) => {\r\n            if (x < 0 || y < 0 || x >= GRID_SIZE || y >= GRID_SIZE) return false;\r\n            return !occupiedPositions.has(getKey(x, y));\r\n        };\r\n\r\n        const hasCommonLetter = (word1: string, word2: string) => {\r\n            return [...new Set(word1)].some((letter) => word2.includes(letter));\r\n        };\r\n\r\n        // Try to place words and numbers until a valid configuration is found\r\n        let attempts = 0;\r\n        const maxAttempts = 100;\r\n\r\n        while (attempts < maxAttempts) {\r\n            randomHintWords = generateHintWords(wordList, GRID_SIZE, mainKeyword);\r\n            newGrid = generateEmptyGrid();\r\n            occupiedPositions.clear();\r\n            occupiedRows.clear();\r\n            occupiedCols.clear();\r\n\r\n            let canPlaceAll = true;\r\n\r\n            // First pass: Place words and mark their positions\r\n            for (const { word, x, y, direction } of randomHintWords) {\r\n                if (direction === \"horizontal\") {\r\n                    occupiedRows.add(y);\r\n                    // Check for adjacent rows\r\n                    for (const other of randomHintWords) {\r\n                        if (other.word === word || other.direction !== \"horizontal\") continue; // Fixed comparison\r\n                        if (Math.abs(other.y - y) === 1 && !hasCommonLetter(word, other.word)) {\r\n                            canPlaceAll = false;\r\n                            break;\r\n                        }\r\n                    }\r\n                } else {\r\n                    occupiedCols.add(x);\r\n                    // Check for adjacent columns\r\n                    for (const other of randomHintWords) {\r\n                        if (other.word === word || other.direction !== \"vertical\") continue; // Fixed comparison\r\n                        if (Math.abs(other.x - x) === 1 && !hasCommonLetter(word, other.word)) {\r\n                            canPlaceAll = false;\r\n                            break;\r\n                        }\r\n                    }\r\n                }\r\n\r\n                if (!canPlaceAll) break;\r\n\r\n                for (let i = 0; i < word.length; i++) {\r\n                    let newX = direction === \"horizontal\" ? x + i : x;\r\n                    let newY = direction === \"horizontal\" ? y : y + i;\r\n                    newGrid[newY][newX] = word[i];\r\n                    occupiedPositions.add(getKey(newX, newY));\r\n                }\r\n            }\r\n\r\n            if (!canPlaceAll) {\r\n                attempts++;\r\n                continue;\r\n            }\r\n\r\n            // Second pass: Check if numbers can be placed without overlap\r\n\r\n            for (const { word, x, y, direction } of randomHintWords) {\r\n                const wordNumber = wordList.includes(word) ? wordList.indexOf(word) + 1 : -1; // Kiểm tra trước khi lấy số\r\n            \r\n                if (wordNumber === -1) {\r\n                    console.error(`Không tìm thấy từ ${word} trong wordList`);\r\n                    continue; // Nếu không tìm thấy, tiếp tục vòng lặp\r\n                }\r\n            \r\n                if (direction === \"horizontal\" && x > 0) {\r\n                    if (!canPlaceNumber(x - 1, y)) {\r\n                        canPlaceAll = false;\r\n                        break;\r\n                    }\r\n                } else if (direction === \"vertical\" && y > 0) {\r\n                    if (!canPlaceNumber(x, y - 1)) {\r\n                        canPlaceAll = false;\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n            \r\n\r\n            if (canPlaceAll) {\r\n                // Place numbers if all checks pass\r\n                randomHintWords.forEach(({ word, x, y, direction }) => {\r\n                    const wordNumber = wordList.indexOf(word) + 1;\r\n                    if (direction === \"horizontal\" && x > 0) {\r\n                        newGrid[y][x - 1] = wordNumber.toString();\r\n                        occupiedPositions.add(getKey(x - 1, y));\r\n                    } else if (direction === \"vertical\" && y > 0) {\r\n                        newGrid[y - 1][x] = wordNumber.toString();\r\n                        occupiedPositions.add(getKey(x, y - 1));\r\n                    }\r\n                });\r\n                break; // Valid configuration found, exit loop\r\n            }\r\n\r\n            attempts++;\r\n        }\r\n\r\n        if (attempts >= maxAttempts) {\r\n            console.warn(\"Could not find a valid grid configuration without overlapping numbers or adjacent non-shared words after max attempts.\");\r\n        }\r\n\r\n        setHintWords(randomHintWords);\r\n        setGrid(newGrid);\r\n    }, []);\r\n\r\n    // Hàm toggle hiển thị hàng/cột\r\n    const toggleRow = (rowIndex: number) => {\r\n        setRevealedRows((prev) => {\r\n            const newRevealed = [...prev];\r\n            newRevealed[rowIndex] = !newRevealed[rowIndex];\r\n            return newRevealed;\r\n        });\r\n    };\r\n\r\n    const toggleCol = (colIndex: number) => {\r\n        setRevealedCols((prev) => {\r\n            const newRevealed = [...prev];\r\n            newRevealed[colIndex] = !newRevealed[colIndex];\r\n            return newRevealed;\r\n        });\r\n    };\r\n\r\n    return (\r\n        <div className=\"flex flex-col items-center bg-white rounded-lg shadow-md p-6\">\r\n            <div className=\"grid grid-cols-[40px_repeat(15,40px)] gap-1\">\r\n                {/* Empty header for alignment */}\r\n                {/* <div className=\"w-10 h-10 bg-white\" /> */}\r\n                {Array.from({ length: GRID_SIZE }).map((_, colIndex) => (\r\n                    <div key={colIndex} className=\"w-10 h-10 bg-white\" />\r\n                ))}\r\n\r\n                {/* Grid with numbers and cells */}\r\n                {grid.map((row, rowIndex) => (\r\n                    <React.Fragment key={rowIndex}>\r\n                        <div className=\"w-10 h-10 bg-white\" /> \r\n                        {row.map((cell, colIndex) => {\r\n                            const isRevealed =\r\n                                (revealedRows[rowIndex] &&\r\n                                    hintWords.some(\r\n                                        (word) => word.y === rowIndex && word.direction === \"horizontal\"\r\n                                    )) ||\r\n                                (revealedCols[colIndex] &&\r\n                                    hintWords.some((word) => word.x === colIndex && word.direction === \"vertical\"));\r\n\r\n                            return (\r\n                                <div\r\n                                    key={colIndex}\r\n                                    className={`w-10 h-10 flex items-center justify-center text-lg font-semibold select-none \r\n                                    \r\n                                    ${!isNaN(Number(cell)) ? \"blue-500 font-bold \" : \"\"}\r\n                                    ${cell === \"\" ? \"bg-white border-none\" : \"border-gray-400 bg-gray-50\"} \r\n                                    ${isRevealed && isNaN(Number(cell)) ? \"text-black\" : isNaN(Number(cell)) ? \"text-transparent\" : \"text-blue-500\"}\r\n                                    ${obstacleWord.includes(cell) && isRevealed && isNaN(Number(cell)) ? \"font-bold text-red-500\" : \"\"}\r\n                                `}\r\n                                    onClick={() => {\r\n                                        if (hintWords.some((word) => word.y === rowIndex && word.direction === \"horizontal\")) {\r\n                                            toggleRow(rowIndex);\r\n                                        } else if (hintWords.some((word) => word.x === colIndex && word.direction === \"vertical\")) {\r\n                                            toggleCol(colIndex);\r\n                                        }\r\n                                    }}\r\n                                    style={{\r\n                                        cursor: hintWords.some((word) => word.y === rowIndex || word.x === colIndex)\r\n                                            ? \"pointer\"\r\n                                            : \"default\",\r\n                                    }}\r\n                                >\r\n                                    {cell}\r\n                                </div>\r\n                            );\r\n                        })}\r\n                    </React.Fragment>\r\n                ))}\r\n            </div>\r\n        </div>\r\n    );\r\n};\r\nfunction Round2() {\r\n    return <Play questionComponent={<ObstacleQuestionBox obstacleWord={mainKeyword} />} />;\r\n}\r\n\r\nexport default Round2;"],"mappings":";;AAAA,OAAOA,IAAI,MAAM,uBAAuB;AACxC,OAAOC,KAAK,IAAIC,QAAQ,EAAEC,SAAS,QAAQ,OAAO;AAAC,SAAAC,MAAA,IAAAC,OAAA;AAoBnD;AACA,MAAMC,WAAW,GAAG,SAAS;AAG7B,MAAMC,mBAAuD,GAAGA,CAAC;EAAEC;AAAa,CAAC,KAAK;EAAAC,EAAA;EAElF;EACA,MAAMC,SAAS,GAAG,EAAE;EAEpB,MAAMC,iBAAiB,GAAGA,CAAA,KAAM;IAC5B,OAAOC,KAAK,CAACF,SAAS,CAAC,CAACG,IAAI,CAAC,IAAI,CAAC,CAACC,GAAG,CAAC,MAAMF,KAAK,CAACF,SAAS,CAAC,CAACG,IAAI,CAAC,EAAE,CAAC,CAAC;EAC3E,CAAC;EACD,MAAM,CAACE,IAAI,EAAEC,OAAO,CAAC,GAAGd,QAAQ,CAAaS,iBAAiB,CAAC,CAAC,CAAC;EACjE,MAAM,CAACM,YAAY,EAAEC,eAAe,CAAC,GAAGhB,QAAQ,CAAYU,KAAK,CAACF,SAAS,CAAC,CAACG,IAAI,CAAC,KAAK,CAAC,CAAC;EACzF,MAAM,CAACM,YAAY,EAAEC,eAAe,CAAC,GAAGlB,QAAQ,CAAYU,KAAK,CAACF,SAAS,CAAC,CAACG,IAAI,CAAC,KAAK,CAAC,CAAC;EACzF,MAAM,CAACQ,SAAS,EAAEC,YAAY,CAAC,GAAGpB,QAAQ,CAAa,EAAE,CAAC;EAI1DC,SAAS,CAAC,MAAM;IACZ,MAAMoB,QAAQ,GAAG,CAAC,UAAU,EAAE,IAAI,EAAE,KAAK,EAAE,SAAS,EAAE,OAAO,EAAE,KAAK,CAAC;IACrE,IAAIC,eAA2B,GAAG,EAAE;IACpC,IAAIC,OAAO,GAAGd,iBAAiB,CAAC,CAAC;IACjC,IAAIe,iBAAiB,GAAG,IAAIC,GAAG,CAAS,CAAC;IACzC,IAAIC,YAAY,GAAG,IAAID,GAAG,CAAS,CAAC;IACpC,IAAIE,YAAY,GAAG,IAAIF,GAAG,CAAS,CAAC;IAEpC,MAAMG,MAAM,GAAGA,CAACC,CAAS,EAAEC,CAAS,KAAK,GAAGD,CAAC,IAAIC,CAAC,EAAE;IAEpD,MAAMC,cAAc,GAAGA,CAACF,CAAS,EAAEC,CAAS,KAAK;MAC7C,IAAID,CAAC,GAAG,CAAC,IAAIC,CAAC,GAAG,CAAC,IAAID,CAAC,IAAIrB,SAAS,IAAIsB,CAAC,IAAItB,SAAS,EAAE,OAAO,KAAK;MACpE,OAAO,CAACgB,iBAAiB,CAACQ,GAAG,CAACJ,MAAM,CAACC,CAAC,EAAEC,CAAC,CAAC,CAAC;IAC/C,CAAC;IAED,MAAMG,eAAe,GAAGA,CAACC,KAAa,EAAEC,KAAa,KAAK;MACtD,OAAO,CAAC,GAAG,IAAIV,GAAG,CAACS,KAAK,CAAC,CAAC,CAACE,IAAI,CAAEC,MAAM,IAAKF,KAAK,CAACG,QAAQ,CAACD,MAAM,CAAC,CAAC;IACvE,CAAC;;IAED;IACA,IAAIE,QAAQ,GAAG,CAAC;IAChB,MAAMC,WAAW,GAAG,GAAG;IAEvB,OAAOD,QAAQ,GAAGC,WAAW,EAAE;MAC3BlB,eAAe,GAAGmB,iBAAiB,CAACpB,QAAQ,EAAEb,SAAS,EAAEJ,WAAW,CAAC;MACrEmB,OAAO,GAAGd,iBAAiB,CAAC,CAAC;MAC7Be,iBAAiB,CAACkB,KAAK,CAAC,CAAC;MACzBhB,YAAY,CAACgB,KAAK,CAAC,CAAC;MACpBf,YAAY,CAACe,KAAK,CAAC,CAAC;MAEpB,IAAIC,WAAW,GAAG,IAAI;;MAEtB;MACA,KAAK,MAAM;QAAEC,IAAI;QAAEf,CAAC;QAAEC,CAAC;QAAEe;MAAU,CAAC,IAAIvB,eAAe,EAAE;QACrD,IAAIuB,SAAS,KAAK,YAAY,EAAE;UAC5BnB,YAAY,CAACoB,GAAG,CAAChB,CAAC,CAAC;UACnB;UACA,KAAK,MAAMiB,KAAK,IAAIzB,eAAe,EAAE;YACjC,IAAIyB,KAAK,CAACH,IAAI,KAAKA,IAAI,IAAIG,KAAK,CAACF,SAAS,KAAK,YAAY,EAAE,SAAS,CAAC;YACvE,IAAIG,IAAI,CAACC,GAAG,CAACF,KAAK,CAACjB,CAAC,GAAGA,CAAC,CAAC,KAAK,CAAC,IAAI,CAACG,eAAe,CAACW,IAAI,EAAEG,KAAK,CAACH,IAAI,CAAC,EAAE;cACnED,WAAW,GAAG,KAAK;cACnB;YACJ;UACJ;QACJ,CAAC,MAAM;UACHhB,YAAY,CAACmB,GAAG,CAACjB,CAAC,CAAC;UACnB;UACA,KAAK,MAAMkB,KAAK,IAAIzB,eAAe,EAAE;YACjC,IAAIyB,KAAK,CAACH,IAAI,KAAKA,IAAI,IAAIG,KAAK,CAACF,SAAS,KAAK,UAAU,EAAE,SAAS,CAAC;YACrE,IAAIG,IAAI,CAACC,GAAG,CAACF,KAAK,CAAClB,CAAC,GAAGA,CAAC,CAAC,KAAK,CAAC,IAAI,CAACI,eAAe,CAACW,IAAI,EAAEG,KAAK,CAACH,IAAI,CAAC,EAAE;cACnED,WAAW,GAAG,KAAK;cACnB;YACJ;UACJ;QACJ;QAEA,IAAI,CAACA,WAAW,EAAE;QAElB,KAAK,IAAIO,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGN,IAAI,CAACO,MAAM,EAAED,CAAC,EAAE,EAAE;UAClC,IAAIE,IAAI,GAAGP,SAAS,KAAK,YAAY,GAAGhB,CAAC,GAAGqB,CAAC,GAAGrB,CAAC;UACjD,IAAIwB,IAAI,GAAGR,SAAS,KAAK,YAAY,GAAGf,CAAC,GAAGA,CAAC,GAAGoB,CAAC;UACjD3B,OAAO,CAAC8B,IAAI,CAAC,CAACD,IAAI,CAAC,GAAGR,IAAI,CAACM,CAAC,CAAC;UAC7B1B,iBAAiB,CAACsB,GAAG,CAAClB,MAAM,CAACwB,IAAI,EAAEC,IAAI,CAAC,CAAC;QAC7C;MACJ;MAEA,IAAI,CAACV,WAAW,EAAE;QACdJ,QAAQ,EAAE;QACV;MACJ;;MAEA;;MAEA,KAAK,MAAM;QAAEK,IAAI;QAAEf,CAAC;QAAEC,CAAC;QAAEe;MAAU,CAAC,IAAIvB,eAAe,EAAE;QACrD,MAAMgC,UAAU,GAAGjC,QAAQ,CAACiB,QAAQ,CAACM,IAAI,CAAC,GAAGvB,QAAQ,CAACkC,OAAO,CAACX,IAAI,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC;;QAE9E,IAAIU,UAAU,KAAK,CAAC,CAAC,EAAE;UACnBE,OAAO,CAACC,KAAK,CAAC,qBAAqBb,IAAI,iBAAiB,CAAC;UACzD,SAAS,CAAC;QACd;QAEA,IAAIC,SAAS,KAAK,YAAY,IAAIhB,CAAC,GAAG,CAAC,EAAE;UACrC,IAAI,CAACE,cAAc,CAACF,CAAC,GAAG,CAAC,EAAEC,CAAC,CAAC,EAAE;YAC3Ba,WAAW,GAAG,KAAK;YACnB;UACJ;QACJ,CAAC,MAAM,IAAIE,SAAS,KAAK,UAAU,IAAIf,CAAC,GAAG,CAAC,EAAE;UAC1C,IAAI,CAACC,cAAc,CAACF,CAAC,EAAEC,CAAC,GAAG,CAAC,CAAC,EAAE;YAC3Ba,WAAW,GAAG,KAAK;YACnB;UACJ;QACJ;MACJ;MAGA,IAAIA,WAAW,EAAE;QACb;QACArB,eAAe,CAACoC,OAAO,CAAC,CAAC;UAAEd,IAAI;UAAEf,CAAC;UAAEC,CAAC;UAAEe;QAAU,CAAC,KAAK;UACnD,MAAMS,UAAU,GAAGjC,QAAQ,CAACkC,OAAO,CAACX,IAAI,CAAC,GAAG,CAAC;UAC7C,IAAIC,SAAS,KAAK,YAAY,IAAIhB,CAAC,GAAG,CAAC,EAAE;YACrCN,OAAO,CAACO,CAAC,CAAC,CAACD,CAAC,GAAG,CAAC,CAAC,GAAGyB,UAAU,CAACK,QAAQ,CAAC,CAAC;YACzCnC,iBAAiB,CAACsB,GAAG,CAAClB,MAAM,CAACC,CAAC,GAAG,CAAC,EAAEC,CAAC,CAAC,CAAC;UAC3C,CAAC,MAAM,IAAIe,SAAS,KAAK,UAAU,IAAIf,CAAC,GAAG,CAAC,EAAE;YAC1CP,OAAO,CAACO,CAAC,GAAG,CAAC,CAAC,CAACD,CAAC,CAAC,GAAGyB,UAAU,CAACK,QAAQ,CAAC,CAAC;YACzCnC,iBAAiB,CAACsB,GAAG,CAAClB,MAAM,CAACC,CAAC,EAAEC,CAAC,GAAG,CAAC,CAAC,CAAC;UAC3C;QACJ,CAAC,CAAC;QACF,MAAM,CAAC;MACX;MAEAS,QAAQ,EAAE;IACd;IAEA,IAAIA,QAAQ,IAAIC,WAAW,EAAE;MACzBgB,OAAO,CAACI,IAAI,CAAC,wHAAwH,CAAC;IAC1I;IAEAxC,YAAY,CAACE,eAAe,CAAC;IAC7BR,OAAO,CAACS,OAAO,CAAC;EACpB,CAAC,EAAE,EAAE,CAAC;;EAEN;EACA,MAAMsC,SAAS,GAAIC,QAAgB,IAAK;IACpC9C,eAAe,CAAE+C,IAAI,IAAK;MACtB,MAAMC,WAAW,GAAG,CAAC,GAAGD,IAAI,CAAC;MAC7BC,WAAW,CAACF,QAAQ,CAAC,GAAG,CAACE,WAAW,CAACF,QAAQ,CAAC;MAC9C,OAAOE,WAAW;IACtB,CAAC,CAAC;EACN,CAAC;EAED,MAAMC,SAAS,GAAIC,QAAgB,IAAK;IACpChD,eAAe,CAAE6C,IAAI,IAAK;MACtB,MAAMC,WAAW,GAAG,CAAC,GAAGD,IAAI,CAAC;MAC7BC,WAAW,CAACE,QAAQ,CAAC,GAAG,CAACF,WAAW,CAACE,QAAQ,CAAC;MAC9C,OAAOF,WAAW;IACtB,CAAC,CAAC;EACN,CAAC;EAED,oBACI7D,OAAA;IAAKgE,SAAS,EAAC,8DAA8D;IAAAC,QAAA,eACzEjE,OAAA;MAAKgE,SAAS,EAAC,6CAA6C;MAAAC,QAAA,GAGvD1D,KAAK,CAAC2D,IAAI,CAAC;QAAElB,MAAM,EAAE3C;MAAU,CAAC,CAAC,CAACI,GAAG,CAAC,CAAC0D,CAAC,EAAEJ,QAAQ,kBAC/C/D,OAAA;QAAoBgE,SAAS,EAAC;MAAoB,GAAxCD,QAAQ;QAAAK,QAAA,EAAAC,YAAA;QAAAC,UAAA;QAAAC,YAAA;MAAA,OAAkC,CACvD,CAAC,EAGD7D,IAAI,CAACD,GAAG,CAAC,CAAC+D,GAAG,EAAEb,QAAQ,kBACpB3D,OAAA,CAACJ,KAAK,CAAC6E,QAAQ;QAAAR,QAAA,gBACXjE,OAAA;UAAKgE,SAAS,EAAC;QAAoB;UAAAI,QAAA,EAAAC,YAAA;UAAAC,UAAA;UAAAC,YAAA;QAAA,OAAE,CAAC,EACrCC,GAAG,CAAC/D,GAAG,CAAC,CAACiE,IAAI,EAAEX,QAAQ,KAAK;UACzB,MAAMY,UAAU,GACX/D,YAAY,CAAC+C,QAAQ,CAAC,IACnB3C,SAAS,CAACiB,IAAI,CACTQ,IAAI,IAAKA,IAAI,CAACd,CAAC,KAAKgC,QAAQ,IAAIlB,IAAI,CAACC,SAAS,KAAK,YACxD,CAAC,IACJ5B,YAAY,CAACiD,QAAQ,CAAC,IACnB/C,SAAS,CAACiB,IAAI,CAAEQ,IAAI,IAAKA,IAAI,CAACf,CAAC,KAAKqC,QAAQ,IAAItB,IAAI,CAACC,SAAS,KAAK,UAAU,CAAE;UAEvF,oBACI1C,OAAA;YAEIgE,SAAS,EAAE;AAC/C;AACA,sCAAsC,CAACY,KAAK,CAACC,MAAM,CAACH,IAAI,CAAC,CAAC,GAAG,qBAAqB,GAAG,EAAE;AACvF,sCAAsCA,IAAI,KAAK,EAAE,GAAG,sBAAsB,GAAG,4BAA4B;AACzG,sCAAsCC,UAAU,IAAIC,KAAK,CAACC,MAAM,CAACH,IAAI,CAAC,CAAC,GAAG,YAAY,GAAGE,KAAK,CAACC,MAAM,CAACH,IAAI,CAAC,CAAC,GAAG,kBAAkB,GAAG,eAAe;AACnJ,sCAAsCvE,YAAY,CAACgC,QAAQ,CAACuC,IAAI,CAAC,IAAIC,UAAU,IAAIC,KAAK,CAACC,MAAM,CAACH,IAAI,CAAC,CAAC,GAAG,wBAAwB,GAAG,EAAE;AACtI,iCAAkC;YACEI,OAAO,EAAEA,CAAA,KAAM;cACX,IAAI9D,SAAS,CAACiB,IAAI,CAAEQ,IAAI,IAAKA,IAAI,CAACd,CAAC,KAAKgC,QAAQ,IAAIlB,IAAI,CAACC,SAAS,KAAK,YAAY,CAAC,EAAE;gBAClFgB,SAAS,CAACC,QAAQ,CAAC;cACvB,CAAC,MAAM,IAAI3C,SAAS,CAACiB,IAAI,CAAEQ,IAAI,IAAKA,IAAI,CAACf,CAAC,KAAKqC,QAAQ,IAAItB,IAAI,CAACC,SAAS,KAAK,UAAU,CAAC,EAAE;gBACvFoB,SAAS,CAACC,QAAQ,CAAC;cACvB;YACJ,CAAE;YACFgB,KAAK,EAAE;cACHC,MAAM,EAAEhE,SAAS,CAACiB,IAAI,CAAEQ,IAAI,IAAKA,IAAI,CAACd,CAAC,KAAKgC,QAAQ,IAAIlB,IAAI,CAACf,CAAC,KAAKqC,QAAQ,CAAC,GACtE,SAAS,GACT;YACV,CAAE;YAAAE,QAAA,EAEDS;UAAI,GArBAX,QAAQ;YAAAK,QAAA,EAAAC,YAAA;YAAAC,UAAA;YAAAC,YAAA;UAAA,OAsBZ,CAAC;QAEd,CAAC,CAAC;MAAA,GArCeZ,QAAQ;QAAAS,QAAA,EAAAC,YAAA;QAAAC,UAAA;QAAAC,YAAA;MAAA,OAsCb,CACnB,CAAC;IAAA;MAAAH,QAAA,EAAAC,YAAA;MAAAC,UAAA;MAAAC,YAAA;IAAA,OACD;EAAC;IAAAH,QAAA,EAAAC,YAAA;IAAAC,UAAA;IAAAC,YAAA;EAAA,OACL,CAAC;AAEd,CAAC;AAACnE,EAAA,CA/MIF,mBAAuD;AAAA+E,EAAA,GAAvD/E,mBAAuD;AAgN7D,SAASgF,MAAMA,CAAA,EAAG;EACd,oBAAOlF,OAAA,CAACL,IAAI;IAACwF,iBAAiB,eAAEnF,OAAA,CAACE,mBAAmB;MAACC,YAAY,EAAEF;IAAY;MAAAmE,QAAA,EAAAC,YAAA;MAAAC,UAAA;MAAAC,YAAA;IAAA,OAAE;EAAE;IAAAH,QAAA,EAAAC,YAAA;IAAAC,UAAA;IAAAC,YAAA;EAAA,OAAE,CAAC;AAC1F;AAACa,GAAA,GAFQF,MAAM;AAIf,eAAeA,MAAM;AAAC,IAAAD,EAAA,EAAAG,GAAA;AAAAC,YAAA,CAAAJ,EAAA;AAAAI,YAAA,CAAAD,GAAA","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}