{"ast":null,"code":"// Tạo từ khóa gợi ý với vị trí và hướng random\n\nexport const generateHintWords = (words, gridSize, obstacleWord) => {\n  const grid = Array(gridSize).fill(null).map(() => Array(gridSize).fill(\"\"));\n\n  // Validate input\n  const maxWordLength = Math.max(...words.map(word => word.length));\n  if (maxWordLength > gridSize) {\n    throw new Error(`Word length (${maxWordLength}) exceeds grid size (${gridSize})`);\n  }\n  if (words.length > gridSize * 2) {\n    throw new Error(`Too many words (${words.length}) for grid size (${gridSize})`);\n  }\n  const findCommonLetterPairs = words => {\n    let results = [];\n    let usedWords = new Set();\n    let remainingPairs = [];\n    for (let i = 0; i < words.length; i++) {\n      for (let j = i + 1; j < words.length; j++) {\n        const word1 = words[i];\n        const word2 = words[j];\n\n        // Find common letters\n        const commonLetters = [...new Set(word1)].filter(letter => word2.includes(letter));\n        if (commonLetters.length >= 1) {\n          // Relaxed to 1 for more flexibility\n          // Prioritize letters near the center\n          const scoredLetters = commonLetters.map(letter => {\n            const index1 = word1.indexOf(letter);\n            const index2 = word2.indexOf(letter);\n            const center1 = word1.length / 2;\n            const center2 = word2.length / 2;\n            const score = Math.abs(index1 - center1) + Math.abs(index2 - center2);\n            return {\n              letter,\n              score\n            };\n          });\n          scoredLetters.sort((a, b) => a.score - b.score);\n          const prioritizedLetters = scoredLetters.map(item => item.letter);\n          remainingPairs.push({\n            word1,\n            word2,\n            commonLetters: prioritizedLetters\n          });\n        }\n      }\n    }\n\n    // Sort pairs by number of common letters (more is better)\n    remainingPairs.sort((a, b) => b.commonLetters.length - a.commonLetters.length);\n\n    // Select up to 2 pairs\n    for (const pair of remainingPairs) {\n      if (results.length >= 2) break;\n      if (!usedWords.has(pair.word1) && !usedWords.has(pair.word2)) {\n        results.push(pair);\n        usedWords.add(pair.word1);\n        usedWords.add(pair.word2);\n      }\n    }\n\n    // If fewer than 2 pairs, allow reuse of words\n    for (const pair of remainingPairs) {\n      if (results.length >= 2) break;\n      if (!usedWords.has(pair.word1) || !usedWords.has(pair.word2)) {\n        results.push(pair);\n        usedWords.add(pair.word1);\n        usedWords.add(pair.word2);\n      }\n    }\n    return results;\n  };\n  const placeWordsOnGrid = (words, gridSize, maxRetries = 1000) => {\n    let retries = 0;\n    while (retries < maxRetries) {\n      retries++;\n      let placedWords = [];\n      let occupiedPositions = new Set();\n      let placedSet = new Set();\n      let allPlaced = true;\n      const getKey = (x, y) => `${x},${y}`;\n      const canPlaceWord = (word, x, y, direction) => {\n        for (let i = 0; i < word.length; i++) {\n          let newX = direction === \"horizontal\" ? x + i : x;\n          let newY = direction === \"horizontal\" ? y : y + i;\n          if (newX < 0 || newY < 0 || newX >= gridSize || newY >= gridSize || occupiedPositions.has(getKey(newX, newY))) {\n            return false;\n          }\n        }\n        return true;\n      };\n      const commonLetterPairs = findCommonLetterPairs(words);\n\n      // Place intersecting pairs\n      for (const {\n        word1,\n        word2,\n        commonLetters\n      } of commonLetterPairs) {\n        if (placedSet.has(word1) || placedSet.has(word2)) continue;\n        const commonLetter = commonLetters[0];\n        const index1 = word1.indexOf(commonLetter);\n        const index2 = word2.indexOf(commonLetter);\n        let placed = false;\n        for (let attempt = 0; attempt < 50; attempt++) {\n          // Reduced attempts for performance\n          // Center the placement to avoid edges\n          let x = Math.floor(Math.random() * (gridSize - word1.length - 2)) + 1;\n          let y = Math.floor(Math.random() * (gridSize - word2.length - 2)) + 1;\n          if (canPlaceWord(word1, x, y, \"horizontal\")) {\n            placedWords.push({\n              word: word1,\n              x,\n              y,\n              direction: \"horizontal\"\n            });\n            for (let i = 0; i < word1.length; i++) {\n              occupiedPositions.add(getKey(x + i, y));\n            }\n            let intersectX = x + index1;\n            let intersectY = y + index2;\n            if (canPlaceWord(word2, intersectX, intersectY - index2, \"vertical\")) {\n              placedWords.push({\n                word: word2,\n                x: intersectX,\n                y: intersectY - index2,\n                direction: \"vertical\"\n              });\n              for (let i = 0; i < word2.length; i++) {\n                occupiedPositions.add(getKey(intersectX, intersectY - index2 + i));\n              }\n              placedSet.add(word1);\n              placedSet.add(word2);\n              placed = true;\n              break;\n            } else {\n              placedWords.pop();\n              occupiedPositions.clear();\n              for (const placedWord of placedWords) {\n                for (let i = 0; i < placedWord.word.length; i++) {\n                  let px = placedWord.direction === \"horizontal\" ? placedWord.x + i : placedWord.x;\n                  let py = placedWord.direction === \"horizontal\" ? placedWord.y : placedWord.y + i;\n                  occupiedPositions.add(getKey(px, py));\n                }\n              }\n            }\n          }\n        }\n        if (!placed) {\n          console.warn(`Failed to place pair: ${word1} - ${word2} (retry ${retries})`);\n          allPlaced = false;\n          break;\n        }\n      }\n\n      // Place remaining words\n      for (const word of words) {\n        if (placedSet.has(word)) continue;\n        let placed = false;\n        for (let attempt = 0; attempt < 50; attempt++) {\n          let direction = Math.random() < 0.5 ? \"horizontal\" : \"vertical\";\n          let x = Math.floor(Math.random() * (gridSize - word.length - 2)) + 1;\n          let y = Math.floor(Math.random() * (gridSize - word.length - 2)) + 1;\n          if (canPlaceWord(word, x, y, direction)) {\n            placedWords.push({\n              word,\n              x,\n              y,\n              direction\n            });\n            placedSet.add(word);\n            for (let i = 0; i < word.length; i++) {\n              let newX = direction === \"horizontal\" ? x + i : x;\n              let newY = direction === \"horizontal\" ? y : y + i;\n              occupiedPositions.add(getKey(newX, newY));\n            }\n            placed = true;\n            break;\n          }\n        }\n        if (!placed) {\n          console.warn(`Failed to place word: ${word} (retry ${retries})`);\n          allPlaced = false;\n          break;\n        }\n      }\n      if (allPlaced) {\n        console.log(`Successfully placed all words in ${retries} retries`);\n        return placedWords;\n      }\n\n      // Clear for next retry\n      placedWords = [];\n      occupiedPositions.clear();\n      placedSet.clear();\n    }\n    throw new Error(`Failed to place words after ${maxRetries} retries`);\n  };\n  const shuffledWords = words.sort(() => Math.random() - 0.5);\n  return placeWordsOnGrid(shuffledWords, gridSize);\n};\nexport const renderGrid = (wordList, mainKeyword, GRID_SIZE) => {\n  const maxAttempts = 100;\n  const generateEmptyGrid = () => {\n    return Array(GRID_SIZE).fill(null).map(() => Array(GRID_SIZE).fill(\"\"));\n  };\n  const getKey = (x, y) => `${x},${y}`;\n  const canPlaceNumber = (x, y) => {\n    if (x < 0 || y < 0 || x >= GRID_SIZE || y >= GRID_SIZE) return false;\n    return !occupiedPositions.has(getKey(x, y));\n  };\n  const hasCommonLetter = (word1, word2) => {\n    return [...new Set(word1)].some(letter => word2.includes(letter));\n  };\n\n  // Try to place words and numbers until a valid configuration is found\n  let attempts = 0;\n  let randomHintWords = [];\n  let newGrid = generateEmptyGrid();\n  let occupiedPositions = new Set();\n  let occupiedRows = new Set();\n  let occupiedCols = new Set();\n  while (attempts < maxAttempts) {\n    randomHintWords = generateHintWords(wordList, GRID_SIZE, mainKeyword);\n    newGrid = generateEmptyGrid();\n    occupiedPositions.clear();\n    occupiedRows.clear();\n    occupiedCols.clear();\n    let canPlaceAll = true;\n\n    // First pass: Place words and mark their positions\n    for (const {\n      word,\n      x,\n      y,\n      direction\n    } of randomHintWords) {\n      if (direction === \"horizontal\") {\n        occupiedRows.add(y);\n        // Check for adjacent rows\n        for (const other of randomHintWords) {\n          if (other.word === word || other.direction !== \"horizontal\") continue; // Fixed comparison\n          if (Math.abs(other.y - y) === 1 && !hasCommonLetter(word, other.word)) {\n            canPlaceAll = false;\n            break;\n          }\n        }\n      } else {\n        occupiedCols.add(x);\n        // Check for adjacent columns\n        for (const other of randomHintWords) {\n          if (other.word === word || other.direction !== \"vertical\") continue; // Fixed comparison\n          if (Math.abs(other.x - x) === 1 && !hasCommonLetter(word, other.word)) {\n            canPlaceAll = false;\n            break;\n          }\n        }\n      }\n      if (!canPlaceAll) break;\n      for (let i = 0; i < word.length; i++) {\n        let newX = direction === \"horizontal\" ? x + i : x;\n        let newY = direction === \"horizontal\" ? y : y + i;\n        newGrid[newY][newX] = word[i];\n        occupiedPositions.add(getKey(newX, newY));\n      }\n    }\n    if (!canPlaceAll) {\n      attempts++;\n      continue;\n    }\n\n    // Second pass: Check if numbers can be placed without overlap\n\n    for (const {\n      word,\n      x,\n      y,\n      direction\n    } of randomHintWords) {\n      const wordNumber = wordList.includes(word) ? wordList.indexOf(word) + 1 : -1; // Kiểm tra trước khi lấy số\n\n      if (wordNumber === -1) {\n        console.error(`Không tìm thấy từ ${word} trong wordList`);\n        continue; // Nếu không tìm thấy, tiếp tục vòng lặp\n      }\n      if (direction === \"horizontal\" && x > 0) {\n        if (!canPlaceNumber(x - 1, y)) {\n          canPlaceAll = false;\n          break;\n        }\n      } else if (direction === \"vertical\" && y > 0) {\n        if (!canPlaceNumber(x, y - 1)) {\n          canPlaceAll = false;\n          break;\n        }\n      }\n    }\n    if (canPlaceAll) {\n      // Place numbers if all checks pass\n      randomHintWords.forEach(({\n        word,\n        x,\n        y,\n        direction\n      }) => {\n        const wordNumber = wordList.indexOf(word) + 1;\n        let newY = y; // Tạo biến mới để lưu trữ vị trí x đã điều chỉnh\n\n        // Kiểm tra nếu ô bên trái đã bị chiếm, thì dịch sang phải\n        if (newGrid[x][y - 1] !== '') {\n          newY = y + 1; // Dịch sang phải 1 đơn vị\n\n          // Nếu là horizontal, cần kiểm tra toàn bộ các ô của word và dịch chúng\n          if (direction === \"horizontal\") {\n            // Kiểm tra xem sau khi dịch có đủ không gian không\n            if (newY + word.length > newGrid[0].length) {\n              // Có thể cần xử lý trường hợp vượt quá kích thước grid\n              console.error(\"Không dịch được sang phải\");\n              return;\n            }\n            // Cập nhật các ô của word ở vị trí mới\n            for (let i = 0; i < word.length; i++) {\n              newGrid[x][newY + i] = word[i];\n              occupiedPositions.add(getKey(x, newY + i));\n            }\n            occupiedPositions.delete(getKey(x, y));\n            newGrid[x][y] = \"\";\n          }\n        }\n        if (direction === \"horizontal\" && x > 0) {\n          newGrid[y][x - 1] = `number${wordNumber.toString()}`;\n          occupiedPositions.add(getKey(x - 1, y));\n        } else if (direction === \"vertical\" && y > 0) {\n          newGrid[y - 1][x] = `number${wordNumber.toString()}`;\n          occupiedPositions.add(getKey(x, y - 1));\n        }\n      });\n      break; // Valid configuration found, exit loop\n    }\n    attempts++;\n  }\n  if (attempts >= maxAttempts) {\n    console.warn(\"Could not find a valid grid configuration without overlapping numbers or adjacent non-shared words after max attempts.\");\n  }\n  return {\n    randomHintWords,\n    newGrid\n  };\n};","map":{"version":3,"names":["generateHintWords","words","gridSize","obstacleWord","grid","Array","fill","map","maxWordLength","Math","max","word","length","Error","findCommonLetterPairs","results","usedWords","Set","remainingPairs","i","j","word1","word2","commonLetters","filter","letter","includes","scoredLetters","index1","indexOf","index2","center1","center2","score","abs","sort","a","b","prioritizedLetters","item","push","pair","has","add","placeWordsOnGrid","maxRetries","retries","placedWords","occupiedPositions","placedSet","allPlaced","getKey","x","y","canPlaceWord","direction","newX","newY","commonLetterPairs","commonLetter","placed","attempt","floor","random","intersectX","intersectY","pop","clear","placedWord","px","py","console","warn","log","shuffledWords","renderGrid","wordList","mainKeyword","GRID_SIZE","maxAttempts","generateEmptyGrid","canPlaceNumber","hasCommonLetter","some","attempts","randomHintWords","newGrid","occupiedRows","occupiedCols","canPlaceAll","other","wordNumber","error","forEach","delete","toString"],"sources":["C:/Users/ASUS/Documents/htm_fe/src/layouts/RoundBase/utils.ts"],"sourcesContent":["// Tạo từ khóa gợi ý với vị trí và hướng random\r\n\r\ninterface HintWord {\r\n    word: string;\r\n    x: number;\r\n    y: number;\r\n    direction: \"horizontal\" | \"vertical\";\r\n}\r\n\r\ninterface ObstacleQuestionBoxProps {\r\n    obstacleWord: string;\r\n}\r\n\r\ninterface PlacedWord {\r\n    word: string;\r\n    x: number;\r\n    y: number;\r\n    direction: \"horizontal\" | \"vertical\";\r\n  }\r\n  \r\n  export const generateHintWords = (words: string[], gridSize: number, obstacleWord: string): PlacedWord[] => {\r\n    const grid: string[][] = Array(gridSize)\r\n      .fill(null)\r\n      .map(() => Array(gridSize).fill(\"\"));\r\n  \r\n    // Validate input\r\n    const maxWordLength = Math.max(...words.map((word) => word.length));\r\n    if (maxWordLength > gridSize) {\r\n      throw new Error(`Word length (${maxWordLength}) exceeds grid size (${gridSize})`);\r\n    }\r\n    if (words.length > gridSize * 2) {\r\n      throw new Error(`Too many words (${words.length}) for grid size (${gridSize})`);\r\n    }\r\n  \r\n    const findCommonLetterPairs = (words: string[]): { word1: string; word2: string; commonLetters: string[] }[] => {\r\n      let results: { word1: string; word2: string; commonLetters: string[] }[] = [];\r\n      let usedWords = new Set<string>();\r\n  \r\n      let remainingPairs: { word1: string; word2: string; commonLetters: string[] }[] = [];\r\n  \r\n      for (let i = 0; i < words.length; i++) {\r\n        for (let j = i + 1; j < words.length; j++) {\r\n          const word1 = words[i];\r\n          const word2 = words[j];\r\n  \r\n          // Find common letters\r\n          const commonLetters = [...new Set(word1)].filter((letter) => word2.includes(letter));\r\n  \r\n          if (commonLetters.length >= 1) { // Relaxed to 1 for more flexibility\r\n            // Prioritize letters near the center\r\n            const scoredLetters = commonLetters.map((letter) => {\r\n              const index1 = word1.indexOf(letter);\r\n              const index2 = word2.indexOf(letter);\r\n              const center1 = word1.length / 2;\r\n              const center2 = word2.length / 2;\r\n              const score = Math.abs(index1 - center1) + Math.abs(index2 - center2);\r\n              return { letter, score };\r\n            });\r\n  \r\n            scoredLetters.sort((a, b) => a.score - b.score);\r\n            const prioritizedLetters = scoredLetters.map((item) => item.letter);\r\n  \r\n            remainingPairs.push({ word1, word2, commonLetters: prioritizedLetters });\r\n          }\r\n        }\r\n      }\r\n  \r\n      // Sort pairs by number of common letters (more is better)\r\n      remainingPairs.sort((a, b) => b.commonLetters.length - a.commonLetters.length);\r\n  \r\n      // Select up to 2 pairs\r\n      for (const pair of remainingPairs) {\r\n        if (results.length >= 2) break;\r\n        if (!usedWords.has(pair.word1) && !usedWords.has(pair.word2)) {\r\n          results.push(pair);\r\n          usedWords.add(pair.word1);\r\n          usedWords.add(pair.word2);\r\n        }\r\n      }\r\n  \r\n      // If fewer than 2 pairs, allow reuse of words\r\n      for (const pair of remainingPairs) {\r\n        if (results.length >= 2) break;\r\n        if (!usedWords.has(pair.word1) || !usedWords.has(pair.word2)) {\r\n          results.push(pair);\r\n          usedWords.add(pair.word1);\r\n          usedWords.add(pair.word2);\r\n        }\r\n      }\r\n  \r\n      return results;\r\n    };\r\n  \r\n    const placeWordsOnGrid = (words: string[], gridSize: number, maxRetries: number = 1000): PlacedWord[] => {\r\n      let retries = 0;\r\n  \r\n      while (retries < maxRetries) {\r\n        retries++;\r\n        let placedWords: PlacedWord[] = [];\r\n        let occupiedPositions = new Set<string>();\r\n        let placedSet = new Set<string>();\r\n        let allPlaced = true;\r\n  \r\n        const getKey = (x: number, y: number) => `${x},${y}`;\r\n  \r\n        const canPlaceWord = (word: string, x: number, y: number, direction: \"horizontal\" | \"vertical\") => {\r\n          for (let i = 0; i < word.length; i++) {\r\n            let newX = direction === \"horizontal\" ? x + i : x;\r\n            let newY = direction === \"horizontal\" ? y : y + i;\r\n            if (\r\n              newX < 0 ||\r\n              newY < 0 ||\r\n              newX >= gridSize ||\r\n              newY >= gridSize ||\r\n              occupiedPositions.has(getKey(newX, newY))\r\n            ) {\r\n              return false;\r\n            }\r\n          }\r\n          return true;\r\n        };\r\n  \r\n        const commonLetterPairs = findCommonLetterPairs(words);\r\n  \r\n        // Place intersecting pairs\r\n        for (const { word1, word2, commonLetters } of commonLetterPairs) {\r\n          if (placedSet.has(word1) || placedSet.has(word2)) continue;\r\n  \r\n          const commonLetter = commonLetters[0];\r\n          const index1 = word1.indexOf(commonLetter);\r\n          const index2 = word2.indexOf(commonLetter);\r\n  \r\n          let placed = false;\r\n          for (let attempt = 0; attempt < 50; attempt++) { // Reduced attempts for performance\r\n            // Center the placement to avoid edges\r\n            let x = Math.floor(Math.random() * (gridSize - word1.length - 2)) + 1;\r\n            let y = Math.floor(Math.random() * (gridSize - word2.length - 2)) + 1;\r\n  \r\n            if (canPlaceWord(word1, x, y, \"horizontal\")) {\r\n              placedWords.push({ word: word1, x, y, direction: \"horizontal\" });\r\n              for (let i = 0; i < word1.length; i++) {\r\n                occupiedPositions.add(getKey(x + i, y));\r\n              }\r\n  \r\n              let intersectX = x + index1;\r\n              let intersectY = y + index2;\r\n  \r\n              if (canPlaceWord(word2, intersectX, intersectY - index2, \"vertical\")) {\r\n                placedWords.push({\r\n                  word: word2,\r\n                  x: intersectX,\r\n                  y: intersectY - index2,\r\n                  direction: \"vertical\",\r\n                });\r\n                for (let i = 0; i < word2.length; i++) {\r\n                  occupiedPositions.add(getKey(intersectX, intersectY - index2 + i));\r\n                }\r\n                placedSet.add(word1);\r\n                placedSet.add(word2);\r\n                placed = true;\r\n                break;\r\n              } else {\r\n                placedWords.pop();\r\n                occupiedPositions.clear();\r\n                for (const placedWord of placedWords) {\r\n                  for (let i = 0; i < placedWord.word.length; i++) {\r\n                    let px = placedWord.direction === \"horizontal\" ? placedWord.x + i : placedWord.x;\r\n                    let py = placedWord.direction === \"horizontal\" ? placedWord.y : placedWord.y + i;\r\n                    occupiedPositions.add(getKey(px, py));\r\n                  }\r\n                }\r\n              }\r\n            }\r\n          }\r\n  \r\n          if (!placed) {\r\n            console.warn(`Failed to place pair: ${word1} - ${word2} (retry ${retries})`);\r\n            allPlaced = false;\r\n            break;\r\n          }\r\n        }\r\n  \r\n        // Place remaining words\r\n        for (const word of words) {\r\n          if (placedSet.has(word)) continue;\r\n  \r\n          let placed = false;\r\n          for (let attempt = 0; attempt < 50; attempt++) {\r\n            let direction: \"horizontal\" | \"vertical\" = Math.random() < 0.5 ? \"horizontal\" : \"vertical\";\r\n            let x = Math.floor(Math.random() * (gridSize - word.length - 2)) + 1;\r\n            let y = Math.floor(Math.random() * (gridSize - word.length - 2)) + 1;\r\n  \r\n            if (canPlaceWord(word, x, y, direction)) {\r\n              placedWords.push({ word, x, y, direction });\r\n              placedSet.add(word);\r\n              for (let i = 0; i < word.length; i++) {\r\n                let newX = direction === \"horizontal\" ? x + i : x;\r\n                let newY = direction === \"horizontal\" ? y : y + i;\r\n                occupiedPositions.add(getKey(newX, newY));\r\n              }\r\n              placed = true;\r\n              break;\r\n            }\r\n          }\r\n  \r\n          if (!placed) {\r\n            console.warn(`Failed to place word: ${word} (retry ${retries})`);\r\n            allPlaced = false;\r\n            break;\r\n          }\r\n        }\r\n  \r\n        if (allPlaced) {\r\n          console.log(`Successfully placed all words in ${retries} retries`);\r\n          return placedWords;\r\n        }\r\n  \r\n        // Clear for next retry\r\n        placedWords = [];\r\n        occupiedPositions.clear();\r\n        placedSet.clear();\r\n      }\r\n  \r\n      throw new Error(`Failed to place words after ${maxRetries} retries`);\r\n    };\r\n  \r\n    const shuffledWords = words.sort(() => Math.random() - 0.5);\r\n    return placeWordsOnGrid(shuffledWords, gridSize);\r\n  };\r\n\r\n\r\nexport const renderGrid = (wordList: string[], mainKeyword:string, GRID_SIZE:number) => {\r\n    const maxAttempts = 100;\r\n\r\n    const generateEmptyGrid = () => {\r\n        return Array(GRID_SIZE).fill(null).map(() => Array(GRID_SIZE).fill(\"\"));\r\n    };\r\n\r\n    const getKey = (x: number, y: number) => `${x},${y}`;\r\n\r\n    const canPlaceNumber = (x: number, y: number) => {\r\n        if (x < 0 || y < 0 || x >= GRID_SIZE || y >= GRID_SIZE) return false;\r\n        return !occupiedPositions.has(getKey(x, y));\r\n    };\r\n\r\n    const hasCommonLetter = (word1: string, word2: string) => {\r\n        return [...new Set(word1)].some((letter) => word2.includes(letter));\r\n    };\r\n\r\n    // Try to place words and numbers until a valid configuration is found\r\n    let attempts = 0;\r\n    let randomHintWords: HintWord[] = [];\r\n    let newGrid = generateEmptyGrid();\r\n    let occupiedPositions = new Set<string>();\r\n    let occupiedRows = new Set<number>();\r\n    let occupiedCols = new Set<number>();\r\n\r\n\r\n    while (attempts < maxAttempts) {\r\n        randomHintWords = generateHintWords(wordList, GRID_SIZE, mainKeyword);\r\n        newGrid = generateEmptyGrid();\r\n        occupiedPositions.clear();\r\n        occupiedRows.clear();\r\n        occupiedCols.clear();\r\n\r\n        let canPlaceAll = true;\r\n\r\n        // First pass: Place words and mark their positions\r\n        for (const { word, x, y, direction } of randomHintWords) {\r\n            if (direction === \"horizontal\") {\r\n                occupiedRows.add(y);\r\n                // Check for adjacent rows\r\n                for (const other of randomHintWords) {\r\n                    if (other.word === word || other.direction !== \"horizontal\") continue; // Fixed comparison\r\n                    if (Math.abs(other.y - y) === 1 && !hasCommonLetter(word, other.word)) {\r\n                        canPlaceAll = false;\r\n                        break;\r\n                    }\r\n                }\r\n            } else {\r\n                occupiedCols.add(x);\r\n                // Check for adjacent columns\r\n                for (const other of randomHintWords) {\r\n                    if (other.word === word || other.direction !== \"vertical\") continue; // Fixed comparison\r\n                    if (Math.abs(other.x - x) === 1 && !hasCommonLetter(word, other.word)) {\r\n                        canPlaceAll = false;\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n\r\n            if (!canPlaceAll) break;\r\n\r\n            for (let i = 0; i < word.length; i++) {\r\n                let newX = direction === \"horizontal\" ? x + i : x;\r\n                let newY = direction === \"horizontal\" ? y : y + i;\r\n                newGrid[newY][newX] = word[i];\r\n                occupiedPositions.add(getKey(newX, newY));\r\n            }\r\n        }\r\n\r\n        if (!canPlaceAll) {\r\n            attempts++;\r\n            continue;\r\n        }\r\n\r\n        // Second pass: Check if numbers can be placed without overlap\r\n\r\n        for (const { word, x, y, direction } of randomHintWords) {\r\n            const wordNumber = wordList.includes(word) ? wordList.indexOf(word) + 1 : -1; // Kiểm tra trước khi lấy số\r\n\r\n            if (wordNumber === -1) {\r\n                console.error(`Không tìm thấy từ ${word} trong wordList`);\r\n                continue; // Nếu không tìm thấy, tiếp tục vòng lặp\r\n            }\r\n\r\n            if (direction === \"horizontal\" && x > 0) {\r\n                if (!canPlaceNumber(x - 1, y)) {\r\n                    canPlaceAll = false;\r\n                    break;\r\n                }\r\n            } else if (direction === \"vertical\" && y > 0) {\r\n                if (!canPlaceNumber(x, y - 1)) {\r\n                    canPlaceAll = false;\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n\r\n\r\n        if (canPlaceAll) {\r\n            // Place numbers if all checks pass\r\n            randomHintWords.forEach(({ word, x, y, direction }) => {\r\n                const wordNumber = wordList.indexOf(word) + 1;\r\n                let newY = y; // Tạo biến mới để lưu trữ vị trí x đã điều chỉnh\r\n\r\n                // Kiểm tra nếu ô bên trái đã bị chiếm, thì dịch sang phải\r\n                if (newGrid[x][y-1] !== '') {\r\n                    newY = y + 1; // Dịch sang phải 1 đơn vị\r\n                    \r\n                    // Nếu là horizontal, cần kiểm tra toàn bộ các ô của word và dịch chúng\r\n                    if (direction === \"horizontal\") {\r\n                        // Kiểm tra xem sau khi dịch có đủ không gian không\r\n                        if (newY + word.length > newGrid[0].length) {\r\n                            // Có thể cần xử lý trường hợp vượt quá kích thước grid\r\n                            console.error(\"Không dịch được sang phải\")\r\n                            return;\r\n                        }\r\n                        // Cập nhật các ô của word ở vị trí mới\r\n                        for (let i = 0; i < word.length; i++) {\r\n                            newGrid[x][newY+i] = word[i];\r\n                            occupiedPositions.add(getKey(x, newY+i));\r\n                        }\r\n\r\n                        occupiedPositions.delete(getKey(x,y))\r\n                        newGrid[x][y] = \"\"\r\n                    }\r\n                }\r\n                if (direction === \"horizontal\" && x > 0) {\r\n                    newGrid[y][x - 1] = `number${wordNumber.toString()}`;\r\n                    occupiedPositions.add(getKey(x - 1, y));\r\n                } else if (direction === \"vertical\" && y > 0) {\r\n                    newGrid[y - 1][x] = `number${wordNumber.toString()}`;\r\n                    occupiedPositions.add(getKey(x, y - 1));\r\n                }\r\n            });\r\n\r\n\r\n            break; // Valid configuration found, exit loop\r\n        }\r\n\r\n        attempts++;\r\n    }\r\n\r\n    if (attempts >= maxAttempts) {\r\n        console.warn(\"Could not find a valid grid configuration without overlapping numbers or adjacent non-shared words after max attempts.\");\r\n    }\r\n\r\n    return {randomHintWords, newGrid}\r\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}