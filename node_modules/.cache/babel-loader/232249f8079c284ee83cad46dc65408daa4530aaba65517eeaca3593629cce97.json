{"ast":null,"code":"var _jsxFileName = \"C:\\\\Users\\\\ASUS\\\\Documents\\\\htm_fe\\\\src\\\\pages\\\\User\\\\Round2.tsx\",\n  _s = $RefreshSig$();\nimport Play from \"../../layouts/Play\";\nimport React, { useState, useEffect } from \"react\";\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\n// T·ª´ kh√≥a ch∆∞·ªõng ng·∫°i v·∫≠t\nconst mainKeyword = \"VIETTEL\";\n\n// T·∫°o t·ª´ kh√≥a g·ª£i √Ω v·ªõi v·ªã tr√≠ v√† h∆∞·ªõng random\nconst generateHintWords = (words, gridSize, obstacleWord) => {\n  const grid = Array(gridSize).fill(null).map(() => Array(gridSize).fill(\"\")); // M·∫£ng ki·ªÉm tra v·ªã tr√≠\n\n  const findCommonLetterPairs = words => {\n    let results = [];\n    let usedWords = new Set(); // L∆∞u l·∫°i c√°c t·ª´ ƒë√£ d√πng\n\n    let remainingPairs = [];\n    for (let i = 0; i < words.length; i++) {\n      for (let j = i + 1; j < words.length; j++) {\n        const word1 = words[i];\n        const word2 = words[j];\n\n        // T√¨m k√Ω t·ª± chung gi·ªØa 2 t·ª´\n        const commonLetters = [...new Set(word1)].filter(letter => word2.includes(letter));\n        if (commonLetters.length >= 2) {\n          // T√≠nh ƒëi·ªÉm ∆∞u ti√™n (ch·ªØ g·∫ßn trung t√¢m h∆°n)\n          const scoredLetters = commonLetters.map(letter => {\n            const index1 = word1.indexOf(letter);\n            const index2 = word2.indexOf(letter);\n            const center1 = word1.length / 2;\n            const center2 = word2.length / 2;\n            const score = Math.abs(index1 - center1) + Math.abs(index2 - center2);\n            return {\n              letter,\n              score\n            };\n          });\n\n          // S·∫Øp x·∫øp theo ƒëi·ªÉm ∆∞u ti√™n\n          scoredLetters.sort((a, b) => a.score - b.score);\n          const prioritizedLetters = scoredLetters.map(item => item.letter);\n          remainingPairs.push({\n            word1,\n            word2,\n            commonLetters: prioritizedLetters\n          });\n        }\n      }\n    }\n\n    // B∆∞·ªõc 2: Ch·ªçn t·ªëi ƒëa 2 c·∫∑p theo quy t·∫Øc\n    for (const pair of remainingPairs) {\n      if (results.length >= 2) break; // ƒê·ªß 2 c·∫∑p th√¨ d·ª´ng\n      if (!usedWords.has(pair.word1) && !usedWords.has(pair.word2)) {\n        results.push(pair);\n        usedWords.add(pair.word1);\n        usedWords.add(pair.word2);\n      }\n    }\n\n    // N·∫øu v·∫´n ch∆∞a ƒë·ªß 2 c·∫∑p, ch·ªçn ti·∫øp t·ª´ c√°c c·∫∑p c√≥ t·ª´ ƒë√£ d√πng\n    for (const pair of remainingPairs) {\n      if (results.length >= 2) break;\n      if (!usedWords.has(pair.word1) || !usedWords.has(pair.word2)) {\n        results.push(pair);\n        usedWords.add(pair.word1);\n        usedWords.add(pair.word2);\n      }\n    }\n    return results;\n  };\n\n  // üõ† Test\n  const testwords = [\"B∆ØUCH√çNH\", \"5G\", \"BQP\", \"T·∫¨PƒêO√ÄN\", \"H√ÄN·ªòI\", \"red\"];\n  const shuffledWords = testwords.sort(() => Math.random() - 0.5);\n  const placeWordsOnGrid = (words, gridSize) => {\n    while (true) {\n      let placedWords = [];\n      let occupiedPositions = new Set();\n      let placedSet = new Set(); // Set ƒë·ªÉ theo d√µi t·ª´ ƒë√£ ƒë·∫∑t\n      let allPlaced = true; // C·ªù ki·ªÉm tra xem t·∫•t c·∫£ t·ª´ c√≥ ƒë∆∞·ª£c ƒë·∫∑t hay kh√¥ng\n\n      const getKey = (x, y) => `${x},${y}`;\n      const canPlaceWord = (word, x, y, direction, index) => {\n        for (let i = 0; i < word.length; i++) {\n          if (i === x + index) continue;\n          let newX = direction === \"horizontal\" ? x + i : x;\n          let newY = direction === \"horizontal\" ? y : y + i;\n          if (newX < 0 || newY < 0 || newX >= gridSize || newY >= gridSize || occupiedPositions.has(getKey(newX, newY))) {\n            return false;\n          }\n        }\n        return true;\n      };\n      const commonLetterPairs = findCommonLetterPairs(words);\n      console.log(commonLetterPairs);\n      for (const {\n        word1,\n        word2,\n        commonLetters\n      } of commonLetterPairs) {\n        if (placedSet.has(word1) || placedSet.has(word2)) continue; // Ki·ªÉm tra n·∫øu ƒë√£ ƒë·∫∑t th√¨ b·ªè qua\n\n        const commonLetter = commonLetters[0];\n        const index1 = word1.indexOf(commonLetter);\n        const index2 = word2.indexOf(commonLetter);\n        let placed = false;\n        for (let attempt = 0; attempt < 100; attempt++) {\n          let x = Math.floor(Math.random() * (gridSize - word1.length));\n          let y = Math.floor(Math.random() * (gridSize - index2) + index2);\n          if (canPlaceWord(word1, x, y, \"horizontal\", index1)) {\n            placedWords.push({\n              word: word1,\n              x,\n              y,\n              direction: \"horizontal\"\n            });\n            placedSet.add(word1);\n            let intersecrX = x + index1;\n            let intersectY = y;\n            if (canPlaceWord(word2, intersecrX, intersectY - index2, \"vertical\", index2)) {\n              for (let i = 0; i < word1.length; i++) occupiedPositions.add(getKey(x + i, y));\n              placedWords.push({\n                word: word2,\n                x: intersecrX,\n                y: intersectY - index2,\n                direction: \"vertical\"\n              });\n              placedSet.add(word2);\n              for (let i = 0; i < word2.length; i++) occupiedPositions.add(getKey(intersecrX, intersectY - index2 + i));\n              placed = true;\n              break;\n            } else {\n              placedWords.pop();\n            }\n          }\n        }\n        if (!placed) {\n          console.warn(`Kh√¥ng th·ªÉ ƒë·∫∑t c·∫∑p t·ª´: ${word1} - ${word2}`);\n          allPlaced = false;\n          break;\n        }\n      }\n      if (!allPlaced) continue; // N·∫øu c√≥ t·ª´ kh√¥ng ƒë·∫∑t ƒë∆∞·ª£c, restart v√≤ng l·∫∑p\n\n      for (const word of words) {\n        if (placedSet.has(word)) continue;\n        let placed = false;\n        let found = false;\n        for (let j = placedWords.length - 1; j >= 0; j--) {\n          for (let attempt = 0; attempt < 10; attempt++) {\n            let direction = placedWords[j].direction === \"horizontal\" ? \"vertical\" : \"horizontal\";\n            const shift = Math.random() < 0.5 ? 1 : -1;\n            let x = placedWords[j].direction === \"horizontal\" ? placedWords[j].word.length + placedWords[j].x : placedWords[j].x + shift + 1;\n            let y = placedWords[j].direction === \"horizontal\" ? placedWords[j].y + shift + 1 : placedWords[j].word.length + placedWords[j].y;\n            if (canPlaceWord(word, x, y, direction, 0)) {\n              placedWords.push({\n                word,\n                x,\n                y,\n                direction\n              });\n              placedSet.add(word);\n              for (let i = 0; i < word.length; i++) {\n                let newX = direction === \"horizontal\" ? x + i : x;\n                let newY = direction === \"horizontal\" ? y : y + i;\n                occupiedPositions.add(getKey(newX, newY));\n              }\n              placed = true;\n              found = true;\n              break;\n            }\n          }\n          if (found) break;\n        }\n        if (!placed) {\n          console.warn(`Kh√¥ng th·ªÉ ƒë·∫∑t t·ª´: ${word}`);\n          allPlaced = false;\n          break;\n        }\n      }\n      if (allPlaced) return placedWords; // N·∫øu t·∫•t c·∫£ t·ª´ ƒë·ªÅu ƒë∆∞·ª£c ƒë·∫∑t, tho√°t kh·ªèi v√≤ng l·∫∑p v√† tr·∫£ v·ªÅ k·∫øt qu·∫£\n    }\n  };\n  const placedWords = placeWordsOnGrid(shuffledWords, gridSize);\n  console.log(placedWords);\n  return placedWords;\n};\nconst ObstacleQuestionBox = ({\n  obstacleWord\n}) => {\n  _s();\n  // Increased grid size\n  const GRID_SIZE = 15;\n  const generateEmptyGrid = () => {\n    return Array(GRID_SIZE).fill(null).map(() => Array(GRID_SIZE).fill(\"\"));\n  };\n  const [grid, setGrid] = useState(generateEmptyGrid());\n  const [revealedRows, setRevealedRows] = useState(Array(GRID_SIZE).fill(false));\n  const [revealedCols, setRevealedCols] = useState(Array(GRID_SIZE).fill(false));\n  const [hintWords, setHintWords] = useState([]);\n  useEffect(() => {\n    const wordList = [\"b∆∞uch√≠nh\", \"5G\", \"bqp\", \"t·∫≠pƒëo√†n\", \"h√†n·ªôi\", \"red\"];\n    let randomHintWords = [];\n    let newGrid = generateEmptyGrid();\n    let occupiedPositions = new Set();\n    let occupiedRows = new Set();\n    let occupiedCols = new Set();\n    const getKey = (x, y) => `${x},${y}`;\n    const canPlaceNumber = (x, y) => {\n      if (x < 0 || y < 0 || x >= GRID_SIZE || y >= GRID_SIZE) return false;\n      return !occupiedPositions.has(getKey(x, y));\n    };\n    const hasCommonLetter = (word1, word2) => {\n      return [...new Set(word1)].some(letter => word2.includes(letter));\n    };\n\n    // Try to place words and numbers until a valid configuration is found\n    let attempts = 0;\n    const maxAttempts = 100;\n    while (attempts < maxAttempts) {\n      randomHintWords = generateHintWords(wordList, GRID_SIZE, mainKeyword);\n      newGrid = generateEmptyGrid();\n      occupiedPositions.clear();\n      occupiedRows.clear();\n      occupiedCols.clear();\n      let canPlaceAll = true;\n\n      // First pass: Place words and mark their positions\n      for (const {\n        word,\n        x,\n        y,\n        direction\n      } of randomHintWords) {\n        if (direction === \"horizontal\") {\n          occupiedRows.add(y);\n          // Check for adjacent rows\n          for (const other of randomHintWords) {\n            if (other.word === word || other.direction !== \"horizontal\") continue; // Fixed comparison\n            if (Math.abs(other.y - y) === 1 && !hasCommonLetter(word, other.word)) {\n              canPlaceAll = false;\n              break;\n            }\n          }\n        } else {\n          occupiedCols.add(x);\n          // Check for adjacent columns\n          for (const other of randomHintWords) {\n            if (other.word === word || other.direction !== \"vertical\") continue; // Fixed comparison\n            if (Math.abs(other.x - x) === 1 && !hasCommonLetter(word, other.word)) {\n              canPlaceAll = false;\n              break;\n            }\n          }\n        }\n        if (!canPlaceAll) break;\n        for (let i = 0; i < word.length; i++) {\n          let newX = direction === \"horizontal\" ? x + i : x;\n          let newY = direction === \"horizontal\" ? y : y + i;\n          newGrid[newY][newX] = word[i];\n          occupiedPositions.add(getKey(newX, newY));\n        }\n      }\n      if (!canPlaceAll) {\n        attempts++;\n        continue;\n      }\n\n      // Second pass: Check if numbers can be placed without overlap\n      for (const {\n        word,\n        x,\n        y,\n        direction\n      } of randomHintWords) {\n        const wordNumber = wordList.indexOf(word) + 1;\n        if (direction === \"horizontal\" && x > 0) {\n          if (!canPlaceNumber(x - 1, y)) {\n            canPlaceAll = false;\n            break;\n          }\n        } else if (direction === \"vertical\" && y > 0) {\n          if (!canPlaceNumber(x, y - 1)) {\n            canPlaceAll = false;\n            break;\n          }\n        }\n      }\n      if (canPlaceAll) {\n        // Place numbers if all checks pass\n        randomHintWords.forEach(({\n          word,\n          x,\n          y,\n          direction\n        }) => {\n          const wordNumber = wordList.indexOf(word) + 1;\n          if (direction === \"horizontal\" && x > 0) {\n            newGrid[y][x - 1] = wordNumber.toString();\n            occupiedPositions.add(getKey(x - 1, y));\n          } else if (direction === \"vertical\" && y > 0) {\n            newGrid[y - 1][x] = wordNumber.toString();\n            occupiedPositions.add(getKey(x, y - 1));\n          }\n        });\n        break; // Valid configuration found, exit loop\n      }\n      attempts++;\n    }\n    if (attempts >= maxAttempts) {\n      console.warn(\"Could not find a valid grid configuration without overlapping numbers or adjacent non-shared words after max attempts.\");\n    }\n    setHintWords(randomHintWords);\n    setGrid(newGrid);\n  }, []);\n\n  // H√†m toggle hi·ªÉn th·ªã h√†ng/c·ªôt\n  const toggleRow = rowIndex => {\n    setRevealedRows(prev => {\n      const newRevealed = [...prev];\n      newRevealed[rowIndex] = !newRevealed[rowIndex];\n      return newRevealed;\n    });\n  };\n  const toggleCol = colIndex => {\n    setRevealedCols(prev => {\n      const newRevealed = [...prev];\n      newRevealed[colIndex] = !newRevealed[colIndex];\n      return newRevealed;\n    });\n  };\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    className: \"flex flex-col items-center bg-white rounded-lg shadow-md p-6\",\n    children: /*#__PURE__*/_jsxDEV(\"div\", {\n      className: \"grid grid-cols-[40px_repeat(15,40px)] gap-1\",\n      children: [/*#__PURE__*/_jsxDEV(\"div\", {\n        className: \"w-10 h-10 bg-white\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 357,\n        columnNumber: 17\n      }, this), Array.from({\n        length: GRID_SIZE\n      }).map((_, colIndex) => /*#__PURE__*/_jsxDEV(\"div\", {\n        className: \"w-10 h-10 bg-white\"\n      }, colIndex, false, {\n        fileName: _jsxFileName,\n        lineNumber: 359,\n        columnNumber: 21\n      }, this)), grid.map((row, rowIndex) => /*#__PURE__*/_jsxDEV(React.Fragment, {\n        children: [/*#__PURE__*/_jsxDEV(\"div\", {\n          className: \"w-10 h-10 bg-white\"\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 365,\n          columnNumber: 25\n        }, this), \" \", row.map((cell, colIndex) => {\n          const isRevealed = revealedRows[rowIndex] && hintWords.some(word => word.y === rowIndex && word.direction === \"horizontal\") || revealedCols[colIndex] && hintWords.some(word => word.x === colIndex && word.direction === \"vertical\");\n          return /*#__PURE__*/_jsxDEV(\"div\", {\n            className: `w-10 h-10 flex items-center justify-center text-lg font-semibold select-none \n                                    \n                                    ${!isNaN(Number(cell)) ? \"blue-500 font-bold \" : \"\"}\n                                    ${cell === \"\" ? \"bg-white border-none\" : \"border-gray-400 bg-gray-50\"} \n                                    ${isRevealed && isNaN(Number(cell)) ? \"text-black\" : isNaN(Number(cell)) ? \"text-transparent\" : \"text-blue-500\"}\n                                    ${obstacleWord.includes(cell) && isRevealed && isNaN(Number(cell)) ? \"font-bold text-red-500\" : \"\"}\n                                `,\n            onClick: () => {\n              if (hintWords.some(word => word.y === rowIndex && word.direction === \"horizontal\")) {\n                toggleRow(rowIndex);\n              } else if (hintWords.some(word => word.x === colIndex && word.direction === \"vertical\")) {\n                toggleCol(colIndex);\n              }\n            },\n            style: {\n              cursor: hintWords.some(word => word.y === rowIndex || word.x === colIndex) ? \"pointer\" : \"default\"\n            },\n            children: cell\n          }, colIndex, false, {\n            fileName: _jsxFileName,\n            lineNumber: 376,\n            columnNumber: 33\n          }, this);\n        })]\n      }, rowIndex, true, {\n        fileName: _jsxFileName,\n        lineNumber: 364,\n        columnNumber: 21\n      }, this))]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 355,\n      columnNumber: 13\n    }, this)\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 354,\n    columnNumber: 9\n  }, this);\n};\n_s(ObstacleQuestionBox, \"0tXfE1RkmpIdWy/liPKPIQWuBnQ=\");\n_c = ObstacleQuestionBox;\nfunction Round2() {\n  return /*#__PURE__*/_jsxDEV(Play, {\n    questionComponent: /*#__PURE__*/_jsxDEV(ObstacleQuestionBox, {\n      obstacleWord: mainKeyword\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 409,\n      columnNumber: 37\n    }, this)\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 409,\n    columnNumber: 12\n  }, this);\n}\n_c2 = Round2;\nexport default Round2;\nvar _c, _c2;\n$RefreshReg$(_c, \"ObstacleQuestionBox\");\n$RefreshReg$(_c2, \"Round2\");","map":{"version":3,"names":["Play","React","useState","useEffect","jsxDEV","_jsxDEV","mainKeyword","generateHintWords","words","gridSize","obstacleWord","grid","Array","fill","map","findCommonLetterPairs","results","usedWords","Set","remainingPairs","i","length","j","word1","word2","commonLetters","filter","letter","includes","scoredLetters","index1","indexOf","index2","center1","center2","score","Math","abs","sort","a","b","prioritizedLetters","item","push","pair","has","add","testwords","shuffledWords","random","placeWordsOnGrid","placedWords","occupiedPositions","placedSet","allPlaced","getKey","x","y","canPlaceWord","word","direction","index","newX","newY","commonLetterPairs","console","log","commonLetter","placed","attempt","floor","intersecrX","intersectY","pop","warn","found","shift","ObstacleQuestionBox","_s","GRID_SIZE","generateEmptyGrid","setGrid","revealedRows","setRevealedRows","revealedCols","setRevealedCols","hintWords","setHintWords","wordList","randomHintWords","newGrid","occupiedRows","occupiedCols","canPlaceNumber","hasCommonLetter","some","attempts","maxAttempts","clear","canPlaceAll","other","wordNumber","forEach","toString","toggleRow","rowIndex","prev","newRevealed","toggleCol","colIndex","className","children","fileName","_jsxFileName","lineNumber","columnNumber","from","_","row","Fragment","cell","isRevealed","isNaN","Number","onClick","style","cursor","_c","Round2","questionComponent","_c2","$RefreshReg$"],"sources":["C:/Users/ASUS/Documents/htm_fe/src/pages/User/Round2.tsx"],"sourcesContent":["import Play from \"../../layouts/Play\";\r\nimport React, { useState, useEffect } from \"react\";\r\n\r\ninterface HintWord {\r\n    word: string;\r\n    x: number;\r\n    y: number;\r\n    direction: \"horizontal\" | \"vertical\";\r\n}\r\n\r\ninterface ObstacleQuestionBoxProps {\r\n    obstacleWord: string;\r\n}\r\n\r\ntype PlacedWord = {\r\n    word: string;\r\n    x: number;\r\n    y: number;\r\n    direction: \"horizontal\" | \"vertical\";\r\n};\r\n\r\n// T·ª´ kh√≥a ch∆∞·ªõng ng·∫°i v·∫≠t\r\nconst mainKeyword = \"VIETTEL\";\r\n\r\n// T·∫°o t·ª´ kh√≥a g·ª£i √Ω v·ªõi v·ªã tr√≠ v√† h∆∞·ªõng random\r\nconst generateHintWords = (words: string[], gridSize: number, obstacleWord: string): HintWord[] => {\r\n    const grid: string[][] = Array(gridSize)\r\n        .fill(null)\r\n        .map(() => Array(gridSize).fill(\"\")); // M·∫£ng ki·ªÉm tra v·ªã tr√≠\r\n\r\n    const findCommonLetterPairs = (words: string[]): { word1: string; word2: string; commonLetters: string[] }[] => {\r\n        let results: { word1: string; word2: string; commonLetters: string[] }[] = [];\r\n        let usedWords = new Set<string>(); // L∆∞u l·∫°i c√°c t·ª´ ƒë√£ d√πng\r\n\r\n        let remainingPairs: { word1: string; word2: string; commonLetters: string[] }[] = [];\r\n\r\n        for (let i = 0; i < words.length; i++) {\r\n            for (let j = i + 1; j < words.length; j++) {\r\n                const word1 = words[i];\r\n                const word2 = words[j];\r\n\r\n                // T√¨m k√Ω t·ª± chung gi·ªØa 2 t·ª´\r\n                const commonLetters = [...new Set(word1)].filter((letter) => word2.includes(letter));\r\n\r\n                if (commonLetters.length >= 2) {\r\n                    // T√≠nh ƒëi·ªÉm ∆∞u ti√™n (ch·ªØ g·∫ßn trung t√¢m h∆°n)\r\n                    const scoredLetters = commonLetters.map((letter) => {\r\n                        const index1 = word1.indexOf(letter);\r\n                        const index2 = word2.indexOf(letter);\r\n                        const center1 = word1.length / 2;\r\n                        const center2 = word2.length / 2;\r\n                        const score = Math.abs(index1 - center1) + Math.abs(index2 - center2);\r\n                        return { letter, score };\r\n                    });\r\n\r\n                    // S·∫Øp x·∫øp theo ƒëi·ªÉm ∆∞u ti√™n\r\n                    scoredLetters.sort((a, b) => a.score - b.score);\r\n                    const prioritizedLetters = scoredLetters.map((item) => item.letter);\r\n\r\n                    remainingPairs.push({ word1, word2, commonLetters: prioritizedLetters });\r\n                }\r\n            }\r\n        }\r\n\r\n        // B∆∞·ªõc 2: Ch·ªçn t·ªëi ƒëa 2 c·∫∑p theo quy t·∫Øc\r\n        for (const pair of remainingPairs) {\r\n            if (results.length >= 2) break; // ƒê·ªß 2 c·∫∑p th√¨ d·ª´ng\r\n            if (!usedWords.has(pair.word1) && !usedWords.has(pair.word2)) {\r\n                results.push(pair);\r\n                usedWords.add(pair.word1);\r\n                usedWords.add(pair.word2);\r\n            }\r\n        }\r\n\r\n        // N·∫øu v·∫´n ch∆∞a ƒë·ªß 2 c·∫∑p, ch·ªçn ti·∫øp t·ª´ c√°c c·∫∑p c√≥ t·ª´ ƒë√£ d√πng\r\n        for (const pair of remainingPairs) {\r\n            if (results.length >= 2) break;\r\n            if (!usedWords.has(pair.word1) || !usedWords.has(pair.word2)) {\r\n                results.push(pair);\r\n                usedWords.add(pair.word1);\r\n                usedWords.add(pair.word2);\r\n            }\r\n        }\r\n\r\n        return results;\r\n    };\r\n\r\n    // üõ† Test\r\n    const testwords = [\"B∆ØUCH√çNH\", \"5G\", \"BQP\", \"T·∫¨PƒêO√ÄN\", \"H√ÄN·ªòI\", \"red\"];\r\n\r\n    const shuffledWords = testwords.sort(() => Math.random() - 0.5);\r\n    const placeWordsOnGrid = (words: string[], gridSize: number): PlacedWord[] => {\r\n        while (true) {\r\n            let placedWords: PlacedWord[] = [];\r\n            let occupiedPositions = new Set<string>();\r\n            let placedSet = new Set<string>(); // Set ƒë·ªÉ theo d√µi t·ª´ ƒë√£ ƒë·∫∑t\r\n            let allPlaced = true; // C·ªù ki·ªÉm tra xem t·∫•t c·∫£ t·ª´ c√≥ ƒë∆∞·ª£c ƒë·∫∑t hay kh√¥ng\r\n    \r\n            const getKey = (x: number, y: number) => `${x},${y}`;\r\n    \r\n            const canPlaceWord = (word: string, x: number, y: number, direction: \"horizontal\" | \"vertical\", index: number) => {\r\n                for (let i = 0; i < word.length; i++) {\r\n                    if (i === x + index) continue;\r\n                    let newX = direction === \"horizontal\" ? x + i : x;\r\n                    let newY = direction === \"horizontal\" ? y : y + i;\r\n                    if (newX < 0 || newY < 0 || newX >= gridSize || newY >= gridSize || occupiedPositions.has(getKey(newX, newY))) {\r\n                        return false;\r\n                    }\r\n                }\r\n                return true;\r\n            };\r\n    \r\n            const commonLetterPairs = findCommonLetterPairs(words);\r\n            console.log(commonLetterPairs);\r\n    \r\n            for (const { word1, word2, commonLetters } of commonLetterPairs) {\r\n                if (placedSet.has(word1) || placedSet.has(word2)) continue; // Ki·ªÉm tra n·∫øu ƒë√£ ƒë·∫∑t th√¨ b·ªè qua\r\n    \r\n                const commonLetter = commonLetters[0];\r\n                const index1 = word1.indexOf(commonLetter);\r\n                const index2 = word2.indexOf(commonLetter);\r\n    \r\n                let placed = false;\r\n                for (let attempt = 0; attempt < 100; attempt++) {\r\n                    let x = Math.floor(Math.random() * (gridSize - word1.length));\r\n                    let y = Math.floor(Math.random() * (gridSize - index2) + index2);\r\n    \r\n                    if (canPlaceWord(word1, x, y, \"horizontal\", index1)) {\r\n                        placedWords.push({ word: word1, x, y, direction: \"horizontal\" });\r\n                        placedSet.add(word1);\r\n    \r\n                        let intersecrX = x + index1;\r\n                        let intersectY = y;\r\n    \r\n                        if (canPlaceWord(word2, intersecrX, intersectY - index2, \"vertical\", index2)) {\r\n                            for (let i = 0; i < word1.length; i++) occupiedPositions.add(getKey(x + i, y));\r\n                            placedWords.push({ word: word2, x: intersecrX, y: intersectY - index2, direction: \"vertical\" });\r\n                            placedSet.add(word2);\r\n    \r\n                            for (let i = 0; i < word2.length; i++) occupiedPositions.add(getKey(intersecrX, intersectY - index2 + i));\r\n    \r\n                            placed = true;\r\n                            break;\r\n                        } else {\r\n                            placedWords.pop();\r\n                        }\r\n                    }\r\n                }\r\n    \r\n                if (!placed) {\r\n                    console.warn(`Kh√¥ng th·ªÉ ƒë·∫∑t c·∫∑p t·ª´: ${word1} - ${word2}`);\r\n                    allPlaced = false;\r\n                    break;\r\n                }\r\n            }\r\n    \r\n            if (!allPlaced) continue; // N·∫øu c√≥ t·ª´ kh√¥ng ƒë·∫∑t ƒë∆∞·ª£c, restart v√≤ng l·∫∑p\r\n    \r\n            for (const word of words) {\r\n                if (placedSet.has(word)) continue;\r\n    \r\n                let placed = false;\r\n                let found = false;\r\n    \r\n                for (let j = placedWords.length - 1; j >= 0; j--) {\r\n                    for (let attempt = 0; attempt < 10; attempt++) {\r\n                        let direction: \"horizontal\" | \"vertical\" = placedWords[j].direction === \"horizontal\" ? \"vertical\" : \"horizontal\";\r\n                        const shift = Math.random() < 0.5 ? 1 : -1;\r\n                        let x = placedWords[j].direction === \"horizontal\" ? placedWords[j].word.length + placedWords[j].x : placedWords[j].x + shift + 1;\r\n                        let y = placedWords[j].direction === \"horizontal\" ? placedWords[j].y + shift + 1 : placedWords[j].word.length + placedWords[j].y;\r\n    \r\n                        if (canPlaceWord(word, x, y, direction, 0)) {\r\n                            placedWords.push({ word, x, y, direction });\r\n                            placedSet.add(word);\r\n    \r\n                            for (let i = 0; i < word.length; i++) {\r\n                                let newX = direction === \"horizontal\" ? x + i : x;\r\n                                let newY = direction === \"horizontal\" ? y : y + i;\r\n                                occupiedPositions.add(getKey(newX, newY));\r\n                            }\r\n    \r\n                            placed = true;\r\n                            found = true;\r\n                            break;\r\n                        }\r\n                    }\r\n    \r\n                    if (found) break;\r\n                }\r\n    \r\n                if (!placed) {\r\n                    console.warn(`Kh√¥ng th·ªÉ ƒë·∫∑t t·ª´: ${word}`);\r\n                    allPlaced = false;\r\n                    break;\r\n                }\r\n            }\r\n    \r\n            if (allPlaced) return placedWords; // N·∫øu t·∫•t c·∫£ t·ª´ ƒë·ªÅu ƒë∆∞·ª£c ƒë·∫∑t, tho√°t kh·ªèi v√≤ng l·∫∑p v√† tr·∫£ v·ªÅ k·∫øt qu·∫£\r\n        }\r\n    };\r\n    \r\n    const placedWords = placeWordsOnGrid(shuffledWords, gridSize);\r\n    console.log(placedWords);\r\n\r\n    return placedWords;\r\n};\r\nconst ObstacleQuestionBox: React.FC<ObstacleQuestionBoxProps> = ({ obstacleWord }) => {\r\n\r\n    // Increased grid size\r\n    const GRID_SIZE = 15;\r\n\r\n    const generateEmptyGrid = () => {\r\n        return Array(GRID_SIZE).fill(null).map(() => Array(GRID_SIZE).fill(\"\"));\r\n    };\r\n    const [grid, setGrid] = useState<string[][]>(generateEmptyGrid());\r\n    const [revealedRows, setRevealedRows] = useState<boolean[]>(Array(GRID_SIZE).fill(false));\r\n    const [revealedCols, setRevealedCols] = useState<boolean[]>(Array(GRID_SIZE).fill(false));\r\n    const [hintWords, setHintWords] = useState<HintWord[]>([]);\r\n\r\n\r\n\r\n    useEffect(() => {\r\n        const wordList = [\"b∆∞uch√≠nh\", \"5G\", \"bqp\", \"t·∫≠pƒëo√†n\", \"h√†n·ªôi\", \"red\"];\r\n        let randomHintWords: HintWord[] = [];\r\n        let newGrid = generateEmptyGrid();\r\n        let occupiedPositions = new Set<string>();\r\n        let occupiedRows = new Set<number>();\r\n        let occupiedCols = new Set<number>();\r\n\r\n        const getKey = (x: number, y: number) => `${x},${y}`;\r\n\r\n        const canPlaceNumber = (x: number, y: number) => {\r\n            if (x < 0 || y < 0 || x >= GRID_SIZE || y >= GRID_SIZE) return false;\r\n            return !occupiedPositions.has(getKey(x, y));\r\n        };\r\n\r\n        const hasCommonLetter = (word1: string, word2: string) => {\r\n            return [...new Set(word1)].some((letter) => word2.includes(letter));\r\n        };\r\n\r\n        // Try to place words and numbers until a valid configuration is found\r\n        let attempts = 0;\r\n        const maxAttempts = 100;\r\n\r\n        while (attempts < maxAttempts) {\r\n            randomHintWords = generateHintWords(wordList, GRID_SIZE, mainKeyword);\r\n            newGrid = generateEmptyGrid();\r\n            occupiedPositions.clear();\r\n            occupiedRows.clear();\r\n            occupiedCols.clear();\r\n\r\n            let canPlaceAll = true;\r\n\r\n            // First pass: Place words and mark their positions\r\n            for (const { word, x, y, direction } of randomHintWords) {\r\n                if (direction === \"horizontal\") {\r\n                    occupiedRows.add(y);\r\n                    // Check for adjacent rows\r\n                    for (const other of randomHintWords) {\r\n                        if (other.word === word || other.direction !== \"horizontal\") continue; // Fixed comparison\r\n                        if (Math.abs(other.y - y) === 1 && !hasCommonLetter(word, other.word)) {\r\n                            canPlaceAll = false;\r\n                            break;\r\n                        }\r\n                    }\r\n                } else {\r\n                    occupiedCols.add(x);\r\n                    // Check for adjacent columns\r\n                    for (const other of randomHintWords) {\r\n                        if (other.word === word || other.direction !== \"vertical\") continue; // Fixed comparison\r\n                        if (Math.abs(other.x - x) === 1 && !hasCommonLetter(word, other.word)) {\r\n                            canPlaceAll = false;\r\n                            break;\r\n                        }\r\n                    }\r\n                }\r\n\r\n                if (!canPlaceAll) break;\r\n\r\n                for (let i = 0; i < word.length; i++) {\r\n                    let newX = direction === \"horizontal\" ? x + i : x;\r\n                    let newY = direction === \"horizontal\" ? y : y + i;\r\n                    newGrid[newY][newX] = word[i];\r\n                    occupiedPositions.add(getKey(newX, newY));\r\n                }\r\n            }\r\n\r\n            if (!canPlaceAll) {\r\n                attempts++;\r\n                continue;\r\n            }\r\n\r\n            // Second pass: Check if numbers can be placed without overlap\r\n            for (const { word, x, y, direction } of randomHintWords) {\r\n                const wordNumber = wordList.indexOf(word) + 1;\r\n\r\n                if (direction === \"horizontal\" && x > 0) {\r\n                    if (!canPlaceNumber(x - 1, y)) {\r\n                        canPlaceAll = false;\r\n                        break;\r\n                    }\r\n                } else if (direction === \"vertical\" && y > 0) {\r\n                    if (!canPlaceNumber(x, y - 1)) {\r\n                        canPlaceAll = false;\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n\r\n            if (canPlaceAll) {\r\n                // Place numbers if all checks pass\r\n                randomHintWords.forEach(({ word, x, y, direction }) => {\r\n                    const wordNumber = wordList.indexOf(word) + 1;\r\n                    if (direction === \"horizontal\" && x > 0) {\r\n                        newGrid[y][x - 1] = wordNumber.toString();\r\n                        occupiedPositions.add(getKey(x - 1, y));\r\n                    } else if (direction === \"vertical\" && y > 0) {\r\n                        newGrid[y - 1][x] = wordNumber.toString();\r\n                        occupiedPositions.add(getKey(x, y - 1));\r\n                    }\r\n                });\r\n                break; // Valid configuration found, exit loop\r\n            }\r\n\r\n            attempts++;\r\n        }\r\n\r\n        if (attempts >= maxAttempts) {\r\n            console.warn(\"Could not find a valid grid configuration without overlapping numbers or adjacent non-shared words after max attempts.\");\r\n        }\r\n\r\n        setHintWords(randomHintWords);\r\n        setGrid(newGrid);\r\n    }, []);\r\n\r\n    // H√†m toggle hi·ªÉn th·ªã h√†ng/c·ªôt\r\n    const toggleRow = (rowIndex: number) => {\r\n        setRevealedRows((prev) => {\r\n            const newRevealed = [...prev];\r\n            newRevealed[rowIndex] = !newRevealed[rowIndex];\r\n            return newRevealed;\r\n        });\r\n    };\r\n\r\n    const toggleCol = (colIndex: number) => {\r\n        setRevealedCols((prev) => {\r\n            const newRevealed = [...prev];\r\n            newRevealed[colIndex] = !newRevealed[colIndex];\r\n            return newRevealed;\r\n        });\r\n    };\r\n\r\n    return (\r\n        <div className=\"flex flex-col items-center bg-white rounded-lg shadow-md p-6\">\r\n            <div className=\"grid grid-cols-[40px_repeat(15,40px)] gap-1\">\r\n                {/* Empty header for alignment */}\r\n                <div className=\"w-10 h-10 bg-white\" />\r\n                {Array.from({ length: GRID_SIZE }).map((_, colIndex) => (\r\n                    <div key={colIndex} className=\"w-10 h-10 bg-white\" />\r\n                ))}\r\n\r\n                {/* Grid with numbers and cells */}\r\n                {grid.map((row, rowIndex) => (\r\n                    <React.Fragment key={rowIndex}>\r\n                        <div className=\"w-10 h-10 bg-white\" /> {/* Empty row label for alignment */}\r\n                        {row.map((cell, colIndex) => {\r\n                            const isRevealed =\r\n                                (revealedRows[rowIndex] &&\r\n                                    hintWords.some(\r\n                                        (word) => word.y === rowIndex && word.direction === \"horizontal\"\r\n                                    )) ||\r\n                                (revealedCols[colIndex] &&\r\n                                    hintWords.some((word) => word.x === colIndex && word.direction === \"vertical\"));\r\n\r\n                            return (\r\n                                <div\r\n                                    key={colIndex}\r\n                                    className={`w-10 h-10 flex items-center justify-center text-lg font-semibold select-none \r\n                                    \r\n                                    ${!isNaN(Number(cell)) ? \"blue-500 font-bold \" : \"\"}\r\n                                    ${cell === \"\" ? \"bg-white border-none\" : \"border-gray-400 bg-gray-50\"} \r\n                                    ${isRevealed && isNaN(Number(cell)) ? \"text-black\" : isNaN(Number(cell)) ? \"text-transparent\" : \"text-blue-500\"}\r\n                                    ${obstacleWord.includes(cell) && isRevealed && isNaN(Number(cell)) ? \"font-bold text-red-500\" : \"\"}\r\n                                `}\r\n                                    onClick={() => {\r\n                                        if (hintWords.some((word) => word.y === rowIndex && word.direction === \"horizontal\")) {\r\n                                            toggleRow(rowIndex);\r\n                                        } else if (hintWords.some((word) => word.x === colIndex && word.direction === \"vertical\")) {\r\n                                            toggleCol(colIndex);\r\n                                        }\r\n                                    }}\r\n                                    style={{\r\n                                        cursor: hintWords.some((word) => word.y === rowIndex || word.x === colIndex)\r\n                                            ? \"pointer\"\r\n                                            : \"default\",\r\n                                    }}\r\n                                >\r\n                                    {cell}\r\n                                </div>\r\n                            );\r\n                        })}\r\n                    </React.Fragment>\r\n                ))}\r\n            </div>\r\n        </div>\r\n    );\r\n};\r\nfunction Round2() {\r\n    return <Play questionComponent={<ObstacleQuestionBox obstacleWord={mainKeyword} />} />;\r\n}\r\n\r\nexport default Round2;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}